14

Mapping BPMN Models to WS-BPEL

Note – The contents of this chapter is REQUIRED for BPMN BPEL Process Execution Conformance or for BPMN
Complete Conformance . However, this chapter is NOT REQUIRED for BPMN Process Modeling Conformance, BPMN
Process Choreography Conformance, or BPMN Process Execution Conformance. For more information about BPMN
conformance types, see page 2.
This chapter covers a mapping of a BPMN model to WS-BPEL that is derived by analyzing the BPMN objects and the
relationships between these objects.
A Business Process Diagram can be made up of a set of (semi-) independent components, which are shown as
separate Pools, each of which represents an orchestration Process. There is not a specific mapping of the diagram
itself, but rather, each of these orchestration Processes maps to an individual WS-BPEL process.
Not all BPMN orchestration Processes can be mapped to WS-BPEL in a straight-forward way. That is because BPMN
allows the modeler to draw almost arbitrary graphs to model control flow, whereas in WS-BPEL, there are certain
restrictions such as control-flow being either block-structured or not containing cycles. For example, an unstructured loop
cannot directly be represented in WS-BPEL.
To map a BPMN orchestration Process to WS-BPEL it MUST be sound, that is it MUST contain neither a deadlock nor
a lack of synchronization. A deadlock is a reachable state of the Process that contains a token on some Sequence
Flow that cannot be removed in any possible future. A lack of synchronization is a reachable state of the Process where
there is more than one token on some Sequence Flow. For further explanation of these terms, we refer to the literature.
To define the structure of BPMN Processes, we introduce the following concepts and terminology. The Gateways
and the Sequence Flows of the BPMN orchestration Process form a directed graph. A block of the diagram is a
connected sub-graph that is connected to the rest of the graph only through exactly two Sequence Flows: exactly one
Sequence Flow entering the block and exactly one Sequence Flow leaving the block. A block hierarchy for a
Process model is a set of blocks of the Process model in which each pair of blocks is either nested or disjoint and
which contains the maximal block (i.e. the whole Process model) A block that is nested in another block B is also called
a subblock of B (cf. Figure 14.1). Each block of the block hierarchy of a given BPMN orchestration Process has a
certain structure (or pattern) which provides the basis for defining the BPEL mapping.

Business Process Model and Notation, v2.0

457

Figure 14.1 - A BPMN orchestration process and its block hierarchy

The following sections define a syntactical BPEL mapping prescribing the resulting BPEL model at the syntactical level,
and a semantic BPEL mapping prescribing the resulting BPEL model in terms of its observable behavior. The syntactical
BPEL mapping is defined for a subset of BPMN models based on certain patterns of BPMN blocks, whereas the
semantical BPEL mapping (which extends the syntactical mapping) does not enforce block patterns, allowing for the
mapping a larger class of BPMN models without prescribing the exact syntactical representation in BPEL.

14.1 Basic BPMN-BPEL Mapping
This section introduces a partial mapping function from BPMN orchestration Process models to WS-BPEL executable
Process models by recursively defining the mapping for elementary BPMN constructs such as Tasks and Events, and
for blocks following the patterns described here. Mapping a BPMN block to WS-BPEL includes mapping all of its
associated attributes. The observable behavior of a WS-BPEL process resulting from a BPEL mapping is the same as that
of the original BPMN orchestration Process.
We use the notation [BPMN construct] to denote the WS-BPEL construct resulting from mapping the BPMN construct.
Examples are
[ServiceTask] = Invoke Activity
which says that a BPMN Service Task is mapped to a WS-BPEL Invoke Activity, or

458

Business Process Model and Notation, v2.0

p1

[

G1

p2

]

G2

G3

=

<i f><cond iti on>[p1]</co ndi tio n>
[G1]
<el se if><cond iti on>[p2]</co ndi tio n>
[G2]
</el se if>
<el se >
[G3]
</el se>
</if>

which says that the data-based exclusive choice controlled by the two predicates p1 and p2, containing the three BPMN
blocks G1, G2 and G3 is mapped to the WS-BPEL on the right hand side, which recursively uses the mappings of those
predicates and those sub-graphs. Note that we use the “waved rectangle” symbol throughout this section to denote BPMN
blocks.

14.1.1 Process

Q2

The following figure describes the mapping of a Process, represented by its defining Collaboration, to WS-BPEL.
The process itself is described by a contained graph G of flow elements) to WS-BPEL. The Process interacts with
Participants Q1…Qn via Conversations C1…Cm:

G

P

C1
Q1

[

C2

]

<process name="[P-n ame]"
targetNamespace="[targetNamespace ]"
e xp ressi onLa ngua ge="[expression Lang uage]"
sup pressJoi nFai lure="yes"
xmlns="http://d ocs.o asis-op en.org /wsbpel/2.0/p rocess/executabl e">
<pa rtnerL inks>
[ {P-In terfa ce s} UNION {Qi-Inte rfaces } ]
</p artne rLin ks>
=
<varia bles>
[ {data Obje cts} UNION {prop erti es} ]
</vari abl es>
<correla tio nSe ts>
[ {Ci-Co rre lation Keys} ]
</correl ati onS ets>
[G]
</pro ce ss>

The partner links of the corresponding WS-BPEL process are derived from the set of interfaces associated with each
participant. Each interface of the Participant containing the Process P itself is mapped to a WS-BPEL partner link
with a “myRole” specification, each interface of each other Participant Qi is mapped to a WS-BPEL partner link with a
“partnerRole” specification.

Business Process Model and Notation, v2.0

459

The variables of the corresponding WS-BPEL process are derived from the set “{dataObjects}” of all Data Objects
occurring within G, united with the set “{properties}” of all properties occurring within G, without Data Objects or
properties contained in nested Sub-Processes. See Section “Handling Data” on page 477 for more details of this
mapping.
The correlation sets of the corresponding WS-BPEL process are derived from the CorrelationKeys of the
set of Conversations C1…Cn.. See page 462 for more details of this mapping.

14.1.2 Activities
Common Activity Mappings
The following table displays a set of mappings of general BPMN Activity attributes to WS-BPEL activity attributes.
Table 14.1 – Common Activity Mappings to WS-BPEL

Activity

Mapping to WS-BPEL

name

The name attribute of a BPMN activity is mapped to the name attribute of a WS-BPEL
activity by removing all characters not allowed in an XML NCName, and ensuring
uniqueness by adding an appropriate suffix. In the subsequent diagrams, this mapping
is represented as [name].

Task Mappings
The following sections contain the mappings of the variations of a Task to WS-BPEL.
Service Task
The following figure shows the mapping of a Service Task to WS-BPEL:

[ ]

<i nvoke na me ="[Task-na me ]"
p artne rLink="[Q , Task- opera tio n- interfa ce ]"
= p ortType="[Task-ope rati on-in terfa ce ]"
o peration="[Task-op eration]">
</i nvoke>

Q

S ervice
Task

The partner link associated with the WS-BPEL invoke is derived from both the participant Q that the Service Task is
connected to by Mesage Flows, and from the interface referenced by the operation of the Service Task.
Receive Task
The following figure shows the mapping of a Receive Task to WS-BPEL:

460

Business Process Model and Notation, v2.0

[ ]
Recei ve
Task

<recei ve name="[Task-n ame]"
createInsta nce ="[insta nti ate ? 'yes':'no ']"
pa rtnerL ink="[Task-opera tio n-interface ]"
=
po rtTyp e="[Task-opera tio n-interfa ce ]"
op erati on="[Ta sk- ope rati on]">
</recei ve>

The partner link associated with the WS-BPEL receive is derived from the interface referenced by the operation of the
Receive Task.
Send Task
The following figure shows the mapping of a Send Task to WS-BPEL:

[ ]

<i nvoke na me ="[Task-na me ]"
p artne rLink="[Q , Task- opera tio n- interfa ce ]"
= p ortType="[Task-ope rati on-in terfa ce ]"
o peration="[Task-op eration]">
</i nvoke>

Q

Se nd
Task

The partner link associated with the WS-BPEL invoke is derived from both the participant Q that the Send Task is
connected to by a Message Flow, and from the interface referenced by the operation of the Send Task.
Abstract Task
The following figure shows the mapping of an Abstract Task to WS-BPEL:

[ ]
Abstract
Task

=

<empty name="[Task-name]">
</empty>

Service Package
Message
For Messages with a scalar data item definition typed by an XML schema definition, the following figure shows the
mapping to WS-BPEL, using WSDL 1.1:

Business Process Model and Notation, v2.0

461

[

<Me ssag e name="msg -name">
<Structure Defi niti on typeL angu age=
"h ttp :// www.w3.o rg/20 01/XMLSche ma ">
xmlSche ma
</StructureDe fin iti on>
</Me ssage >

]

=

<wsdl:messa ge n ame="[msg -na me ]">
[xmlS ch ema]
</wsdl:message>

The top-level child elements of the XML schema defining the structure of the BPMN Message are mapped to the
WSDL’s message’s parts.
Interface and Operation
The following figure shows the mapping of a BPMN interface with its operations to WS-BPEL, using WSDL 1.1:

[

<In terfa ce name="if- na me">
<Operation s>
<Opera tio n name="op1- name">
<i nMessa geRef ref="msg 1i-na me "/>
<o utMessageRe f ref="msg1o- name"/>
<e rrorRef re f="e rro r1a -name"/>
...
</Ope rati on >
...
</Operation s>
</Interface >

]

<wsdl:p ortType na me ="[if-n ame]">
<ope rati on na me ="[op1-n ame]">
<wsdl:i nput messa ge="[msg1 i- na me]" />
<wsdl:ou tpu t messag e="[msg1 o-name]" />
<wsdl:fault name="[e rro r1a -fau ltn ame ]"
=
me ssag e="[error1a- na me]" />
...
</ope rati on>
...
</wsd l:portType >

Conversations and Correlation
For those BPMN nodes sending or receiving Messages (i.e., Message Events, Service, send or Receive Tasks)
that have an associated key-based Correlation Key, the mapping of that key-based Correlation Key is as
follows:

462

Business Process Model and Notation, v2.0

< v prop:prop erty nam e=" [k -n am e1]" typ e ="[k- ty pe1 ]" />
...
< v prop:prop erty nam e=" [k -n am eN ]" />

[

< Key Ba se dC orrel ati onS et na me= "c -s et">
<Ke y nam e=" k -na me1 " ty pe=" k -ty pe1"
m es sa geR ef=" ms g-na me1 ">
< M es sa geK ey Ex pres s ion
ex pres s ion Lan guag e=" lang 1">
e xp r1
< /M es s ageK ey Ex pre ss io n>
</Key >
...
<Ke y nam e=" k -na meN " />
...
< /Key Ba se dC orrel ati onS et>

]

=

< v prop:prop erty Al ias pro perty N am e= "[k N am e1 ]"
m es sa geT y pe=" [m s g-n am e1]"
pa rt= "[ex pr1 -part]" >
< vp rop:qu ery que ryL angu age= "[lang1]">
[ex pr1]
< /vp ro p:q uery >
< /v prop :pro perty A lia s>
...
< v prop:prop erty Al ias pro perty N am e= "[k N am eN]" />
< c orrela tio nSe ts>
< co rre lation Set nam e=" [c -se t]"
prop erti es ="[k -nam e1 ] ... [ k-n am eN ]" />
...
< /c orrel ati onS ets >

The messageType of the BPEL property alias is appropriately derived from the itemDefinition of the Message
referenced by the BPMN Message key Expression. The name of the Message part is derived from the Message
key Expression. The Message key Expression itself is transformed into an Expression relative to that part.
The mapping of Activities with an associated key-based Correlation Key is extended to reference the above BPEL
correlation set in the corresponding BPEL correlations element. The following figure shows that mapping in the
case of a Service Task with an associated key-based Correlation Key.

[ ]
S ervice
Task

<in vo ke name="[Ta sk-name]"
p artn erLin k="[Q, Task-ope ratio n-in terfa ce ]"
p ortType ="[Task-o pera tion -interface]"
o peration ="[Ta sk- ope rati on]">
= <correl ati ons>
<correla tio n set="[Task-me ssage Flow-co nversa tio n-correla tio nKe y]"
ini tia te="[initial InCo nversati on? 'joi n':'n o']"/>
</co rre lation s>
</i nvoke>

The initiate attribute of the BPEL correlation element is set depending on whether or not the associated Message
Flow initiates the associated Conversations, or participates in an already existing Conversation. If there are multiple
CorrelationKeys associated with the Conversation, multiple correlation elements are used.
Sub-Process Mappings
The following table displays the mapping of an embedded Sub-Process with Adhoc=”False” to a WS-BPEL scope.
(This extends the mappings that are defined for all Activities--see page 460):
The following figure shows the mapping of a BPMN Sub-Process without an Event Sub-Process:

Business Process Model and Notation, v2.0

463

The following figure shows the mapping of a BPMN Sub-Process with an Event Sub-Process. (Event SubProcesses could also be added to a top-level Process, in which case their mapping extends correspondingly.)

[

]

S ubp ro ce ss
G

=

<scop e>
[G]
</sco pe>

Note that in case of multiple Event Sub-Processes, there would be multiple WS-BPEL handlers.
Mapping of Event Sub-Processes
Note that if a Sub-Process contains multiple Event Sub-Processes, all become handlers of the associated WSBPEL scope, ordered and grouped as specified by WS-BPEL.
Non-interrupting Message Event Sub-Processes are mapped to WS-BPEL event handlers as follows:

[

Message Handler
G
e

]

<eventHa ndl ers>
<onE vent partnerLi nk="[e -opera tio n-interfa ce]"
ope ratio n="[e- op erati on]">
=
<scope >[G]</scope >
</on Event>
</eventHa ndl ers>

Timer Event Sub-Processes are mapped to WS-BPEL event handlers as follows:

[

Timeout Handler
G
e

]

<even tHan dle rs>
<on Al arm>[timer- sp ec]
=
<scope >[G]</scope >
</on Al arm>
</eventHa ndl ers>

Error Event Sub-Processes are mapped to WS-BPEL fault handlers as follows:

[
464

Error Handler
G
e

]

<faul tHan dle rs>
<catch fa ultName="[e-fa ult]">
[G]
=
</catch >
</faul tHan dle rs>

Business Process Model and Notation, v2.0

A Compensation Event Sub-Process is mapped to a WS-BPEL compensation handler as follows:

[

]

Compensation
G

=

<co mpe nsati onHan dle r>
[G ]
</co mpe nsati onHan dle r>

Activity Loop Mapping
Standard loops with a testTime attribute “Before” or “After” execution of the Activity map to WS-BPEL while and
repeatUntil activities in a straight-forward manner. When the LoopMaximum attribute is used, additional activities
are used to maintain a loop counter.

Multi-instance Activities map to WS-BPEL forEach activities in a straight-forward manner.
Standard Loops
The mappings for standard loops to WS-BPEL are described in the following.
A standard loop with testTime= “Before” maps to WS-BPEL as follows, where p denotes the loop condition:

[ ]
Task

=

<whi le>
<con diti on>[p ]</condi tio n>
[Task]
</wh ile>

A standard loop with testTime= “After” maps as follows, where p denotes the loop condition:

[ ]
Task

=

<repe atUn til>
[Task]
<con diti on>[n ot p ]</cond iti on>
</re peatUnti l>

Dealing with LoopMaximum
When the LoopMaximum attribute is specified for an Activity, the loop requires additional set up for maintaining a
counter.

Business Process Model and Notation, v2.0

465

A standard loop with testTime=“Before” and a LoopMaximum attribute maps to WS-BPEL as follows (again, p denotes
the loopCondition):

[ ]
Task

<varia ble name="[cou nte r]" typ e="xsd:i nte ger"/>
...
<sequ ence>
<a ssig n>
<co py>
<from><li tera l>0</l itera l></from >
<to va riab le="[co unter]"/>
</cop y>
</a ssig n>
<wh ile>
<co ndition>[p] a nd $ [co unter] &l t; [Loo pMa xi mu m]</condi tio n>
=
<se quen ce>
[G]
<a ssig n>
<copy>
<fro m expre ssio n="$[cou nter]+1"/>
<to varia ble="[co unte r]" />
</co py>
</assi gn>
</seque nce>
</wh ile>
</sequ ence>

(The notation [counter] denotes the unique name of a variable used to hold the counter value; the actual name is
immaterial.)
A standard loop with testTime=“After” and a LoopMaximum attribute maps as follows:

[ ]
Task

466

<va riabl e n ame="[counter]" type="xsd:intege r"/>
...
<se quen ce >
<assign>
<co py>
<from><li tera l>0</literal></from>
<to vari able="[coun ter]"/>
</copy>
</a ssig n>
<repe atUn til>
<se quen ce >
=
[G]
<assi gn>
<cop y>
<fro m expressi on="$[co unter]+1"/>
<to vari abl e="[coun ter]" />
</cop y>
</assign>
</seq uen ce>
<co ndition>[n ot p ] or $[cou nter] &gt; [L oopMaximum]</con dition >
</rep eatUnti l>
</se quen ce>
Business Process Model and Notation, v2.0

(The notation [counter] denotes the unique name of a variable used to hold the counter value; the actual name is
immaterial.)
Multi-Instance Activities
A BPMN Multi-Instance Task with a multiInstanceFlowCondition of “All” is mapped to WS-BPEL as
follows:

[ ]
Task

<varia ble na me ="[co unter]" type ="xsd:integer"/>
...
<fo rEach co unte rName="[co unte r]" p aral lel="[isS eque nti al? 'n o':'yes' ]">
<startCo unterVal ue>1</startCoun terV alue >
= <fin alCo unterVal ue>[con dition]</fi nal CounterVa lue>
<scop e>
[Task]
</scop e>
</forEa ch >

(The notation [counter] denotes the unique name of a variable used to hold the counter value; the actual name is
immaterial.)

14.1.3 Events
Start Event Mappings
The following sections detail the mapping of Start Events to WS-BPEL.
Message Start Events
A Message Start Event is mapped to WS-BPEL as shown in the following figure:

[ ]
e

<recei ve name="[e-n ame ]"
createInsta nce ="yes"
pa rtnerL ink="[e-o peration -i nte rfac e]"
=
po rtTyp e="[e-o peration -in terface]"
op erati on="[e -opera tio n]">
</recei ve>

The partner link associated with the WS-BPEL receive is derived from the interface referenced by the operation of the
Message Start Event.
Error Start Events
An Error Start Event can only occur in Event Sub-Processes. This mapping is described on page 464.
Compensation Start Events
A Compensation Start Event can only occur in Event Sub-Processes. This mapping is described page 464.

Business Process Model and Notation, v2.0

467

Intermediate Event Mappings (Non-boundary)
The following sections detail the mapping of intermediate non-boundary Events to WS-BPEL.
Message Intermediate Events (Non-boundary)
A Message Intermediate Event can either be used in normal control flow, similar to a Send or Receive Task (for
throw or catch Message Intermediate Events, respectively), or it can be used in an Event Gateway. The latter is
described in more detail in 14.1.4, ’Gateways and Sequence Flows’.
The following figure describes the mapping of Message Intermediate Events to WS-BPEL:

[ ]
e

<recei ve name="[e-n ame ]"
createInsta nce ="n o"
pa rtnerL ink="[e-o peration -i nte rface ]"
=
po rtTyp e="[e-o peration -in terface]"
op erati on="[e -opera tio n]">
</recei ve>

The partner link associated with the WS-BPEL receive is derived from the interface referenced by the operation of the
Message Intermediate Event.
Timer Intermediate Events (Non-boundary)
A Timer Intermediate Event can either be used in normal control flow, or it can be used in an Event Gateway. The
latter is described in more detail in 14.1.4, ’Gateways and Sequence Flows’.
The following figure describes the mapping of a Timer Intermediate Event to WS-BPEL – note that one o the
mappings shown is chosen depending on whether the Timer Event’s TimeCycle or TimeDate attribute is used:

[ ]
e

=

<wait name="[e-name]" for="[e -Ti me Cycle]"/>
or
<wait name="[e-name]" un til="[e-TimeDate]"/>

Compensation Intermediate Events (Non-boundary)
A Compensation Intermediate Event with its waitForCompletion property set to true, that is used within an
Event Sub-Process triggered through an error or through compensation, is mapped to WS-BPEL as follows:

468

Business Process Model and Notation, v2.0

[ ]

<comp ensate/>
=

e

or
<comp ensateScope targe t="[referen ce dActi vi ty]"/>

The first mapping is used if the Compensation Event does not reference an Activity, the second mapping is used
otherwise.
End Event Mappings
The following sections detail the mapping of End Events to WS-BPEL.
None End Events
A “none” End Event marking the end of a Process is mapped to WS-BPEL as shown in the following figure:

[ ]
e

=

<e mp ty n ame="[e- name]">
</empty>

Message End Events
A Message Start Event is mapped to WS-BPEL as shown in the following figure:

Q

[ ]

<i nvoke na me ="[e- name]"
p artne rLink="[Q , e-o peration -interface]"
= p ortType="[e -op eration-i nte rface]"
o peration="[e-ope rati on]">
</i nvoke>

e

The partner link associated with the WS-BPEL invoke is derived from both the participant Q that the Message
Intermediate Event is connected to by a Message Flow, and from the interface referenced by the operation
of the Message Intermediate Event.
Error End Events
An Error End Event is mapped to WS-BPEL as shown in the following figure:

Business Process Model and Notation, v2.0

469

[ ]

=

e

<throw faul tName="[e -n ame ]">
</throw>

Compensation End Events
A Compensation End Event with its waitForCompletion property set to true, that is used within an Event SubProcess triggered through an error or through compensation, is mapped to WS-BPEL as follows:

[ ]

<comp ensate/>
=

e

or
<comp ensateScope targe t="[referen ce dActi vi ty]"/>

The first mapping is used if the Compensation Event does not reference an Activity, the second mapping is used
otherwise.
Terminate End Events
A Terminate End Event is mapped to WS-BPEL as shown in the following figure:

[ ]
e

=

<e xi t>
</exit>

Boundary Intermediate Events
Message Boundary Events
A BPMN Activity with a non-interrupting Message boundary Event is mapped to a WS-BPEL scope with an event
handler as follows:

470

Business Process Model and Notation, v2.0

]

Q

[

A ctivity
e
G

<scop e>
<eventHand lers>
<onE ve nt partn erLin k="[Q, e -opera tio n-interfa ce ]"
op eration="[e-ope ra tio n]">
<scop e>[G]</scop e>
=
</onE ven t>
</e ve ntHan dle rs>
[Activity]
</sco pe>

The partner link associated with the WS-BPEL onEvent is derived from the interface referenced by the operation of the
boundary Message Event.
The same mapping applies to a non-interrupting boundary Timer Event, using a WS-BPEL onAlarm handler instead.
Error Boundary Events
A BPMN Activity with a boundary Error Event according to the following pattern is mapped as shown:

[

A ctivity

l3

G1

l1

l2

G2
l4

Business Process Model and Notation, v2.0

]

<fl ow>
<li nks>
<lin k na me ="[l 1]"/>
...
<lin k na me ="[l 4]"/>
</l inks>
<sco pe>
<so urces><so urce li nkName="[l1]"/></sou rce s>
<fau ltHa ndle rs>
<catch faul tName="[e -erro r]">
<emp ty>
<sources><source lin kNa me="[l3 ]"/></sources>
</empty >
</catch >
</fa ultHandl ers>
[Acti vi ty]
=
</scope >
<fl ow>
<targ ets><targe t li nkName="[l 1]"/></targe ts>
<so urces><so urce li nkName="[l2]"/></sou rce s>
[G1]
</flow>
<fl ow>
<targ ets><targe t li nkName="[l 3]"/></targe ts>
<so urces><so urce li nkName="[l4]"/></sou rce s>
[G2]
</flow>
<empty>
<so urces><so urce li nkName="[l2]"/>
<so urce lin kNa me="[l4]"/></sou rce s>
</e mp ty>
</flow>

471

Note that the case where the error handling path doesn’t join the main control flow again, is still mapped using this
pattern, by applying the following model equivalence:

Activity

G1

G1

Activity

G2

G2

Compensation Boundary Events
A BPMN Activity with a boundary Compensation Event is similarly mapped as shown:

[

A ctivity

G

]

<scop e n ame ="[A ctivity-na me ]">
<compensation Handl er>
[G]
=
</compen sa tio nHand ler>
[Activity]
</sco pe>

Multiple Boundary Events, and Boundary Events with Loops
If there are multiple boundary Events for an Activity, their WS-BPEL mappings are super-imposed on the single WSBPEL scope wrapping the mapping of the Activity.
When the Activity is a standard loop or a multi-instance and has one or more boundary Events, the WS-BPEL loop
resulting from mapping the BPMN loop is nested inside the WS-BPEL scope resulting from mapping the BPMN
boundary Events.
The following example shows that mapping for a Sub-Process with a nested Event Sub-Process that has a standard
loop with TestTime=“Before,” a boundary Error Intermediate Event, and a boundary Compensation
Intermediate Event.

472

Business Process Model and Notation, v2.0

S ubp rocess
G

[

l1

Handler

G1

l2

G’

G2

l3

l4

G3

]

<fl ow>
<l inks>
<li nk na me ="[l1]"/>
...
<li nk na me ="[l4]"/>
</lin ks>
<scope>
<sources><so urce l inkName="[l1]"/></sources>
<fau ltHa ndl ers>
<catch fau ltNa me="[e-e rro r]">
<empty>
<sources><source lin kNa me="[l3 ]"/></sou rce s>
</empty >
</catch >
</faultHand lers>
<comp ensationHa ndl er>
[G3]
</compen sa tion Hand ler>
<whil e>
<con dition>[p]</condi ti on>
=
<scope >
[Hand ler]
[G]
</scope>
</whi le>
</scope >
<flow>
<targ ets ><targe t li nkName="[l 1]"/></targ ets>
<sources><so urce l inkName="[l2]"/></sources>
[G1]
</flo w>
<flow>
<targ ets ><targe t li nkName="[l 3]"/></targ ets>
<sources><so urce l inkName="[l4]"/></sources>
[G2]
</flo w>
<empty>
<sources><so urce l inkName="[l2]"/>
<source l inkName="[l4]"/></so urce s>
</emp ty>
</flow>

14.1.4 Gateways and Sequence Flows
The mapping of BPMN Gateways and Sequence Flows is described using BPMN blocks following particular
patterns.
Exclusive (Data-based) Decision Pattern
An exclusive data-based decision is mapped as follows:

Business Process Model and Notation, v2.0

473

[

p1

G1

p2

]

G2

=

G3

<i f><cond iti on>[p1]</co ndi tio n>
[G1]
<el se if><cond iti on>[p2]</co ndi tio n>
[G2]
</el se if>
<el se >
[G3]
</el se>
</if>

While this figure shows three branches, the pattern is generalized to n branches in an obvious manner.
Exclusive (Event-based) Decision Pattern
An Event Gateway is mapped as follows:

[

G1
e1
e2

G2

G3
timer

]

<pi ck crea teIn stance ="[in stantiate? ' ye s':'n o']">
<o nMe ssag e p artne rLink="[e1-o peration- inte rface]"
o peration ="[e1- ope ra tio n]">
[G 1]
</onMessa ge>
<o nMe ssag e p artne rLink="[e2-o peration- inte rface]"
o peration ="[e2- ope ra tio n]">
=
[G 2]
</onMessa ge>
<o nAl arm>
[ti me r-spec]
[G 3]
</onA larm>
</p ick>

While this figure shows three branches with one Message Intermediate Event, one Receive Task and one Timer
Intermediate Event, the pattern is generalized to n branches with any combination of the former in an obvious manner.
The handling of Participants (BPEL partnerLinks), Event (operation) and timer details is as specified for Message
Intermediate Events, Receive Tasks, and Timer Intermediate Events, respectively. The data flow and associated
variables (not shown) are handled as for Receive Tasks/Message Intermediate Events.
Inclusive Decision Pattern
An inclusive decision pattern without an otherwise gate is mapped as follows:

474

Business Process Model and Notation, v2.0

<flo w>
<li nks>
<l ink n ame="[li nk1]"/>
...
<l ink n ame="[li nk6]"/>
</l inks>

[

p1

link1

p2

link2

p3

link3

G1

G2

G3

link4

link5

link6

]

<empty>
<sou rce s>
<source l inkName="[lin k1]">
<transitionCo ndi tio n>[p1])</tran si tio nCon dition>
</source>
<source l inkName="[lin k2]">
<transitionCo ndi tio n>[p2])</tran si tio nCon dition>
</source>
<source l inkName="[lin k3]">
<transitionCo ndi tio n>[p3])</tran si tio nCon dition>
</source>
</sou rce s>
</empty>

=

<fl ow>
<targe ts><target lin kNa me="[li nk1]"/></targ ets>
<sou rce s><sou rce li nkName="[l ink4 ]"/></sources>
[G1]
</flow>
<fl ow>
<targe ts><target lin kNa me="[li nk2]"/></targ ets>
<sou rce s><sou rce li nkName="[l ink5 ]"/></sources>
[G2]
</flow>
<fl ow>
<targe ts><target lin kNa me="[li nk3]"/></targ ets>
<sou rce s><sou rce li nkName="[l ink6 ]"/></sources>
[G3]
</flow>
<empty>
<targe ts>
<ta rget li nkName="[l ink4]"/>
<ta rget li nkName="[l ink5]"/>
<ta rget li nkName="[l ink6]"/>
</targe ts>
</empty>
</fl ow>

While this figure shows three branches, the pattern is generalized to n branches in an obvious manner.
Note that link names in WS-BPEL MUST follow the rules of an XML NCName. Thus, the mapping of the BPMN
Sequence Flow name attribute MUST appropriately canonicalize that name, possibly ensuring uniqueness, e.g., by
appending a unique suffix. This is capture by the [linkName] notation.

Business Process Model and Notation, v2.0

475

Parallel Pattern
A parallel fork-join pattern is mapped as follows:

G1

[

]

G2

<flo w>
[G 1]
[G 2]
[G 3]
</fl ow>

=

G3

Sequence Pattern
A BPMN block consisting of a series of Activities connected via (unconditional) Sequence Flows is mapped to a
WS-BPEL sequence:

[

G1

G2

G3

]

=

<seq uen ce>
[G1 ]
[G2 ]
[G3 ]
</seq uence>

Structured Loop Patterns
A BPMN block consisting of a structured loop of the following pattern is mapped to a WS-BPEL while:

[

p

G

]

=

<wh ile>
<co ndi tion>[p ]</cond iti on>
[G]
</wh ile>

A BPMN block consisting of a structured loop of the following pattern is mapped to a WS-BPEL repeatUntil:

476

Business Process Model and Notation, v2.0

[

]

p

G

=

<rep eatUnti l>
[G]
<con dition>[not p ]</cond iti on>
</re pea tUntil>

Handling Loops in Sequence Flows
Loops are created when the flow of the Process moves from a downstream object to an upstream object. There are two
types of loops that are WS-BPEL mappable: while loops and repeat loops.
A while loop has the following structure in BPMN and is mapped as shown:

[

p

G

]

=

<wh ile>
<co ndi tion>[p ]</cond iti on>
[G]
</wh ile>

A repeat loop has the following structure in BPMN and is mapped as shown:

[

p

G

]

<rep eatUnti l>
[G]
=
<con dition>[no t p ]</condi tio n>
</rep eatU ntil>

14.1.5 Handling Data
Data Objects
BPMN Data Objects are mapped to WS-BPEL variables. The itemDefinition of the Data Object determines the
XSD type of that variable.
Data Objects occur in the context of a Process or Sub-Process. For the associated WS-BPEL process or WSBPEL scope, a variable is added for each Data Object in the corresponding WS-BPEL variables section, as
follows:

Business Process Model and Notation, v2.0

477

[ ]

=

<vari abl e name=" [D1- na me]" type="[D1 -structu reDefini tion ]"/>

D1

Properties
BPMN properties can be contained in a Process, Activity, or an Event, here named the “container” of the property. A
BPMN property is mapped to a WS-BPEL variable. Its name is derived from the name of its container and the name of
the property. Note that in the case of different containers with the same name and a contained property of the same name,
the mapping to WS-BPEL ensures the names of the associated WS-BPEL variables are unique. The itemDefinition
of the property determines the XSD type of that variable.
A BPMN Process property is mapped to a WS-BPEL global variable. A BPMN Event property is mapped to a WSBPEL variable contained in the WS-BPEL scope representing the immediately enclosing Sub-Process of the Event (or
a global variable in case the Event is an immediate child of the Process). For a BPMN Activity property, two cases
are distinguished: In case of a Sub-Process, the WS-BPEL variable is contained in the WS-BPEL scope representing
the Sub-Process. For all other BPMN Activity properties, the WS-BPEL variable is contained in the WS-BPEL scope
representing the immediately enclosing Sub-Process of the Activity (or a global variable in case the Activity is an
immediate child of the Process).

[

<prope rty i d="P1 -name"
structureRe f="P 1-structu re Defi nition "/>

]

=

<va riab le n ame="[{containe r-name }.P1 -name]"
typ e="[P1-stru ctureDefini tio n]"/>

Input and Output Sets
For a Send Task and a Service Task, the single input set is mapped to a WSDL message defining the input of the
associated WS-BPEL activity. The inputs map to the message parts of the WSDL message. For a Receive Task and a
Service Task, the single output set is mapped to a WSDL message defining the output of the associated WS-BPEL
activity. The outputs map to the message parts of the WSDL message.
The structure of the WSDL message is defined by the itemDefinitions of the data inputs of the input set:

478

Business Process Model and Notation, v2.0

[

<in putS et name="iset">
<data Inp ut name="in put1">
<structu reDefinition structure ="type1 "/>
</data Inp ut>
...
</i nputSet>

]

=

<wsd l:me ssag e name="[i se t- name]">
<pa rt name="[i npu t1-na me]" typ e="[type1]"/>
...
</wsdl:me ssag e>

For the data outputs of the output set, the WSDL message looks as follows:

[

<outputSet na me ="oset">
<data Outp ut name="ou tput1">
<structu reDefinition structure ="type3 "/>
</data Outp ut>
...
</o utpu tSe t>

]

=

<wsd l:me ssag e name="[o se t-name]">
<pa rt name="[o utp ut1-name]" type =" [type 3]"/>
...
</wsdl:me ssag e>

Data Associations
In this section, we assume that the input set of the Service Task has the same structure as its referenced input
Message, and the output set of the Service Task has the same structure as its reference output Message. If this is not
the case, assignments are needed, and the mapping is as described in the next section.
Data associations to and from a Service Task are mapped as follows:

[

]

A

D1

D3
D2

D4

<i nvoke ... >
<toP arts>
<toPa rt part="[d ataInpu t1-name]"
fromVa riab le="[D1 -name]"/>
<toPa rt part="[d ataInpu t2-name]"
fromVa riab le="[D2 -name]"/>
</to Parts>
=
<fromParts>
<fro mP art part="[d ata Outpu t1-name]"
fromVa riab le="[D3 -name]"/>
<formP art part="[d ata Outpu t2-name]"
fromVa riab le="[D4 -name]"/>
</fromP arts>
</invoke>

Data associations from a Receive Task are mapped as follows:

Business Process Model and Notation, v2.0

479

[

]

A

D3

<receive>
<fro mP arts >
<fromPa rt p art="[dataOutput1 -na me]"
fro mV ariab le="[D3- name]"/>
=
<formPa rt p art="[dataOutput2 -na me]"
fro mV ariab le="[D4- name]"/>
</fromParts>
</receive>

D4

Data associations to a Send Task are mapped as follows:

[

A

D1

]

D2

<invoke>
<to Parts>
<toP art p art="[dataIn put1-n ame ]"
fro mV ariab le="[D1- name]"/>
=
<toP art p art="[dataIn put2-n ame ]"
fro mV ariab le="[D2- name]"/>
</toP arts>
</invoke>

Expressions
BPMN Expressions specified using XPath (e.g., a condition Expression of a Sequence Flow, or a timer cycle
Expression of a Timer Intermediate Event) are used as specified in BPMN, rewriting access to BPMN context to
refer to the mapped BPEL context.
The BPMN XPath functions for accessing context from the perspective of the current Process are mapped to BPEL
XPath functions for context access as shown in the following table. This is possible because the arguments MUST be
literal strings.
Table 14.2 - Expressions mapping to WS-BPEL

BPMN context access

BPEL context access

getDataobject(dataObjectName)

$[dataObjectName]

getProcessProperty(propertyName)

$[{processName}.propertyName] where the right processName is statistically derived.

getActivityProperty(activityName, propertyName)

$[activityName.propertyName]

getEventProperty(eventName, propertyName)

$[eventName.propertyName]

480

Business Process Model and Notation, v2.0

Assignments
For a Service Task with assignments, the WS-BPEL mapping results in a sequence of an assign activity, an invoke
activity and another assign activity. The first assign deals with creating the service request Message from the data inputs
of the Task, the second assign deals with creating the data outputs of the Task from the service response Message.

14.2 Extended BPMN-BPEL Mapping
Additional sound BPMN Process models whose block hierarchy contains blocks that have not been addressed in the
previous section can be mapped to WS-BPEL. For such BPMN Process models, in many cases there is no preferred
single mapping of a particular block, but rather, multiple WS-BPEL patterns are possible to map that block to. Also,
additional BPMN constructs can be mapped by using capabilities not available at the time of producing this specification,
such as the upcoming OASIS BPEL4People standard to map BPMN User Tasks, or other WS-BPEL extensions.
Rather than describing or even mandating the mapping of such BPMN blocks, this specification allows for a semantic
mapping of a BPMN Process model to an executable WS-BPEL process: The observable behavior of the target WSBPEL process MUST match the operational semantics of the mapped BPMN Process. Also, the mappings described in
Section 15.1 SHOULD be used where applicable.

14.2.1 End Events
End Events can be combined with other BPMN objects to complete the merging or joining of the paths of a WSBPEL
structured element (see Figure 7.3).

Figure 14.2 - An example of distributed token recombination

Business Process Model and Notation, v2.0

481

14.2.2 Loop/Switch Combinations From a Gateway
This type of loop is created by a Gateway that has three or more outgoing Sequence Flows. One Sequence Flow
loops back upstream while the others continue downstream (see Figure 14.3). Note that there might be intervening
Activities prior to when the Sequence Flow loops back upstream.
• This maps to both a WSBPEL while and a switch. Both activities will be placed within a sequence, with the

while preceding the switch.
• For the while:

• The Condition for the Sequence Flow that loops back upstream will map to the condition of the while.
• All the Activities that span the distance between where the loop starts and where it ends, will be mapped and
placed within the Activity for the while, usually within a sequence.
• For the switch:

• For each additional outgoing Sequence Flows there will be a case for the switch.

Figure 14.3 - An example of a loop from a decision with more than two alternative paths

14.2.3 Interleaved Loops
This is a situation where there at least two loops involved and they are not nested (see Figure 14.4). Multiple looping
situations can map, as described above, if they are in a sequence or are fully nested (e.g., one while inside another
while). However, if the loops overlap in a non-nested fashion, as shown in the figure, then the structured element
while cannot be used to handle the situation. Also, since a flow is acyclic, it cannot handle the behavior either.

482

Business Process Model and Notation, v2.0

Figure 14.4 - An example of interleaved loops

To handle this type of behavior, parts of the WSBPEL process will have to be separated into one or more derived
processes that are spawned from the main process and will also spawn or call each other (note that the examples
below are using a spawning technique). Through this mechanism, the linear and structured elements of WSBPEL can
provide the same behavior that is shown through a set of cycles in a single BPMN diagram. To do this:
• The looping section of the Process, where the loops first merge back (upstream) into the flow until all the paths have

merged back to Normal Flow, SHALL be separated from the main WSBPEL process into a set of derived
processes that will spawn each other until all the looping conditions are satisfied.
• The section of the process that is removed will be replaced by a (one-way) invoke to spawn the derived

process, followed by a receive to accept the message that the looping sections have completed and the main
process can continue (see Figure 14.5).
• The name of the invoke will be in the form of:

• “Spawn_[(loop target)activity.Name]_Derived_Process”
• The name of the receive will be in the form of:
• [(loop target)activity.Name]_Derived_Process_Completed”
Business Process Model and Notation, v2.0

483

Figure 14.5 - An example of the WSBPEL pattern for substituting for the derived Process

For each location in the Process where a Sequence Flow connects upstream, there will be a separate derived
WSBPEL process.
• The name of the derived process will be in the form of:

• “[(loop target)activity.Name]_Derived_Process”
• All Gateways in this section will be mapped to switch elements, instead of while elements (see Figure below).
• Each time there is a Sequence Flow that loops back upstream, the Activity for the switch case will be a (one-

way) invoke that will spawn the appropriate derived process, even if the invoke spawns the same process
again.
• The name of the invoke will the same as the one describe above.
• At the end of the derived process a (one-way) invoke will be used to signal the main process that all the derived

activities have completed and the main process can continue.
• The name of the invoke will be in the form of:

• “[(loop target)activity.Name]_Derived_Process_Completed”

Figure 14.6 - An example of a WSBPEL pattern for the derived Process

484

Business Process Model and Notation, v2.0

14.2.4 Infinite Loops
This type of loop is created by a Sequence Flow that loops back without an intervening Gateway to create alternative
paths (see Figure 14.7). While this can be a modeling error most of the time, there can be situations where this type of
loop is desired, especially if it is placed within a larger Activity that will eventually be interrupted.
• This will map to a while activity.
• The condition of the while will be set to an Expression that will never evaluate to true, such as condition ”1 =

0.”
• All the activities that span the distance between where the loop starts and where it ends, will be mapped and placed

within the activity for the while, usually within a sequence.

Figure 14.7 - An example – An infinite loop

14.2.5 BPMN Elements that Span Multiple WSBPEL Sub-Elements
Figure 14.8 below illustrates how BPMN objects can exist in two separate sub-elements of a WSBPEL structured element
at the same time. Since BPMN allows free form connections of Activities and Sequence Flows, it is possible that two
(or more) Sequence Flows will merge before all the Sequence Flows that map to a WSBPEL structure element have
merged. The sub-elements of a WSBPEL structured elements are also self-contained and there is no cross sub-element
flow. For example, the cases of a switch cannot interact; that is, they cannot share activities. Thus, one BPMN
Activity will need to appear in two (or more) WSBPEL structured elements. There are two possible mechanisms to deal
with the situation:
• First, the activities are simply duplicated in all appropriate WSBPEL elements.
• Second, the activities that need to be duplicated can be removed from the main Process and placed in a derived

process that is called (invoked) from all locations in the WSBPEL elements as needed.
• The name of the derived process will be in the form of:
• “[(target)object.Name]_Derived_Process”

Business Process Model and Notation, v2.0

485

Figure 14.8 below displays this issue with an example. In that example, two Sequence Flows merge into the “Include
History of Transactions” Task. However, the Decision that precedes the Task has three (3) alternatives. Thus, the
Decision maps to a WSBPEL switch with three (3) cases. The three cases are not closed until the “Include Standard
Text” Task, downstream. This means that the “Include History of Transactions” Task will actually appear in two (2) of
the three (3) cases of the switch.
Note – the use of a WSBPEL flow will be able to handle the behavior without duplicating activities, but a flow will not
always be available for use in these situations, particularly if a WSBPEL pick is requested.

Figure 14.8 - An example - Activity that spans two paths of a WSBPEL structured element

486

Business Process Model and Notation, v2.0

