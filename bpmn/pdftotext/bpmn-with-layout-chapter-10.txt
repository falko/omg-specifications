10       Process

Note – The content of this chapter is REQUIRED for BPMN Process Modeling Conformance or for BPMN Complete
Conformance. However, this chapter is NOT REQUIRED for BPMN Process Choreography Conformance, BPMN
Process Execution Conformance, or BPMN BPEL Process Execution Conformance. For more information about BPMN
conformance types, see page 2.

A Process describes a sequence or flow of Activities in an organization with the objective of carrying out work. In
BPMN a Process is depicted as a graph of Flow Elements, which are a set of Activities, Events, Gateways, and
Sequence Flows that define finite execution semantics (see Figure 10.1). Processes can be defined at any level from
enterprise-wide Processes to Processes performed by a single person. Low-level Processes can be grouped
together to achieve a common business goal.




Figure 10.1 - An Example of a Process

Note that BPMN uses the term Process specifically to mean a set of flow elements. It uses the terms Collaboration and
Choreography when modeling the interaction between Processes.

The Process package contains classes which are used for modeling the flow of Activities, Events, and Gateways,
and how they are sequenced within a Process (see Figure 10.2). When a Process is defined it is contained within
Definitions.




Business Process Model and Notation, v2.0                                                                        147
Figure 10.2 - Process class diagram

A Process is a CallableElement, allowing it to be referenced and reused by other Processes via the Call Activity
construct. In this capacity, a Process MAY reference a set of Interfaces that define its external behavior.

A Process is a reusable element and can be imported and used within other Definitions.

Figure 10.3 shows the details of the attributes and model associations of a Process.




148                                                                           Business Process Model and Notation, v2.0
Figure 10.3 - Process Details class diagram

The Process element inherits the attributes and model associations of CallableElement (see Table 10.24) and of
FlowElementContainer (see Table 8.45). Table 10.1 presents the additional attributes and model associations of the
Process element:

Table 10.1 – Process Attributes & Model Associations

 Attribute Name                             Description/Usage

 processType: ProcessType = none            The processType attribute Provides additional information about the
 { None | Private | Public }                level of abstraction modeled by this Process.
                                            A public Process shows only those flow elements that are relevant to
                                            external consumers. Internal details are not modeled. These
                                            Processes are publicly visible and can be used within a
                                            Collaboration. Note that the public processType was named
                                            abstract in BPMN 1.2.
                                            A private Process is one that is internal to a specific organization.
                                            By default, the processType is “none,” meaning undefined.




Business Process Model and Notation, v2.0                                                                           149
Table 10.1 – Process Attributes & Model Associations

 isExecutable: boolean [0..1]           An optional Boolean value specifying whether the Process is execut-
                                        able.
                                        An executable Process is a private Process that has been modeled for
                                        the purpose of being executed according to the semantics of Chapter
                                        14 (see page 436). Of course, during the development cycle of the Pro-
                                        cess, there will be stages where the Process does not have enough
                                        detail to be “executable.”
                                        A non-executable Process is a private Process that has been modeled
                                        for the purpose of documenting Process behavior at a modeler-defined
                                        level of detail. Thus, information needed for execution, such as formal
                                        condition expressions are typically not included in a non-executable
                                        Process.
                                        For public Processes, no value has the same semantics as if the value
                                        were false. The value MAY not be true for public Processes.

 auditing: Auditing [0..1]              This attribute provides a hook for specifying audit related properties.

 monitoring: Monitoring [0..1]          This attribute provides a hook for specifying monitoring related proper-
                                        ties.

 artifacts: Artifact [0..*]             This attribute provides the list of Artifacts that are contained within the
                                        Process.

 IsClosed: boolean = false              A boolean value specifying whether interactions, such as sending and
                                        receiving Messages and Events, not modeled in the Process can
                                        occur when the Process is executed or performed. If the value is true,
                                        they MAY NOT occur. If the value is false, they MAY occur.

 supports: Process [0..*]               Modelers can declare that they intend all executions or performances
                                        of one Process to also be valid for another Process. This means they
                                        expect all the executions or performances of the first Processes to also
                                        follow the steps laid out in the second Process.

 properties: Property [0..*]            Modeler-defined properties MAY be added to a Process. These
                                        properties are contained within the Process. All Tasks and Sub-
                                        Processes SHALL have access to these properties.

 resources: ResourceRole [0..*]         Defines the resource that will perform or will be responsible for the
                                        Process. The resource, e.g., a performer, can be specified in the form
                                        of a specific individual, a group, an organization role or position, or an
                                        organization.
                                        Note that the assigned resources of the Process does not determine
                                        the assigned resources of the Activities that are contained by the
                                        Process. See more details about resource assignment on page 156.




150                                                                        Business Process Model and Notation, v2.0
Table 10.1 – Process Attributes & Model Associations

 correlationSubscriptions:                  correlationSubscriptions are a feature of context-based corre-
 CorrelationSubscription [0..*]             lation (cf. section 8.3.3). CorrelationSubscriptions are used to
                                            correlate incoming Messages against data in the Process context. A
                                            Process MAY contain several correlationSubscriptions.

 definitionalCollaborationRef:              For Processes that interact with other Participants, a definitional
 Collaboration [0..1]                       Collaboration can be referenced by the Process. The definitional
                                            Collaboration specifies the Participants the Process interacts with,
                                            and more specifically, which individual service, Send or Receive Task,
                                            or Message Event, is connected to which Participant through
                                            Message Flows. The definitional Collaboration need not be dis-
                                            played.
                                            Additionally, the definitional Collaboration can be used to include Con-
                                            versation information within a Process.


In addition, a Process instance has attributes whose values MAY be referenced by Expressions (see Table 10.2).
These values are only available when the Process is being executed.


 Table 10.2 – Process instance attributes

 Attribute Name                                                   Description/Usage

 state: string = None                                             See Figure 13.2 ("The Lifecycle of a BPMN
                                                                  Activity") in Section 13.2.2 for permissible
                                                                  values.


10.1 Basic Process Concepts

10.1.1 Types of BPMN Processes

Business Process modeling is used to communicate a wide variety of information to a wide variety of audiences.
BPMN is designed to cover many types of modeling and allows the creation of end-to-end Business Processes. There
are three basic types of BPMN Processes:

    • Private Non-executable (internal) Business Processes

    • Private Executable (internal) Business Processes

    • Public Processes

Private (Internal) Business Processes

Private Business Processes are those internal to a specific organization. These Processes have been generally
called workflow or BPM Processes (see Figure 10.4). Another synonym typically used in the Web services area is the
Orchestration of services. There are two (2) types of private Processes: executable and non-executable. An executable
Process is a Process that has been modeled for the purpose of being executed according to the semantics defined in

Business Process Model and Notation, v2.0                                                                         151
Chapter 14 (see page 436). Of course, during the development cycle of the Process, there will be stages where the
Process does not have enough detail to be “executable.” A non-executable Process is a private Process that has been
modeled for the purpose of documenting Process behavior at a modeler-defined level of detail. Thus, information
needed for execution, such as formal condition Expressions are typically not included in a non-executable Process.

If a swimlanes-like notation is used (e.g., a Collaboration, see below) then a private Business Process will be
contained within a single Pool. The Process flow is therefore contained within the Pool and cannot cross the
boundaries of the Pool. The flow of Messages can cross the Pool boundary to show the interactions that exist between
separate private Business Processes.


                                                                                                     Notify
                 Determine             Check             Determine             Approve
                                                                                                   Applicant of
                  Order is            Record of         Premium of            or Reject
                                                                                                   Approval or
                 Complete             Applicant           Policy               Policy
                                                                                                    Rejection

Figure 10.4 - Example of a private Business Process

Public Processes

A public Process represents the interactions between a private Business Process and another Process or
Participant (see Figure 10.5). Only those Activities that are used to communicate to the other Participant(s), plus the
order of these Activities, are included in the public Process. All other “internal” Activities of the private Business
Process are not shown in the public Process. Thus, the public Process shows to the outside world the Messages,
and the order of these Messages, that are needed to interact with that Business Process. Public Processes can be
modeled separately or within a Collaboration to show the flow of Messages between the public Process Activities
and other Participants. Note that the public type of Process was named “abstract” in BPMN 1.2.
  Patient




                                                                 Pickup your medicine
                                                   I feel sick                                       Here is your medicine
                                                                  and you can leave
            I want to see doctor
                                   Go see doctor                                    need my medicine




                 Receive                                                Send            Receive
                                                    Receive                                                 Send
                  Doctor            Send Appt.                       Prescription       Medicine
                                                   Symptoms                                                Medicine
                 Request                                               Pickup           Request

Figure 10.5 - Example of a public Process


10.1.2 Use of BPMN Common Elements

Some BPMN elements are common to both Process and Choreography, as well as Collaboration; they are used in
these diagrams. The next few sections will describe the use of Messages, Message Flows, Participants, Sequence
Flows, Artifacts, Correlations, Expressions, and Services in Choreography.


152                                                                                     Business Process Model and Notation, v2.0
The key graphical elements of Gateways and Events are also common to both Choreography and Process. Since
their usage has a large impact, they are described in major sections of this chapter (see page 237 for Events and page 292
for Gateways).


10.2 Activities
An Activity is work that is performed within a Business Process. An Activity can be atomic or non-atomic
(compound). The types of Activities that are a part of a Process are: Task, Sub-Process, and Call Activity, which
allows the inclusion of re-usable Tasks and Processes in the diagram. However, a Process is not a specific graphical
object. Instead, it is a set of graphical objects. The following sections will focus on the graphical objects Sub-Process
and Task.

Activities represent points in a Process flow where work is performed. They are the executable elements of a BPMN
Process.

The Activity class is an abstract element, sub-classing from FlowElement (as shown in Figure 10.6).

Concrete sub-classes of Activity specify additional semantics above and beyond that defined for the generic Activity.




Figure 10.6 - Activity class diagram

The Activity class is the abstract super class for all concrete Activity types.



Business Process Model and Notation, v2.0                                                                             153
The Activity element inherits the attributes and model associations of FlowElement (see Table 8.44). Table 10.3
presents the additional attributes and model associations of the Activity element:

Table 10.3 Activity attributes and model associations

 Attribute Name                          Description/Usage

 isForCompensation: boolean =            A flag that identifies whether this Activity is intended for the purposes of
 false                                   compensation.
                                         If false, then this Activity executes as a result of normal execution flow.
                                         If true, this Activity is only activated when a Compensation Event is
                                         detected and initiated under Compensation Event visibility scope (see
                                         page 285 for more information on scopes).

 loopCharacteristics: LoopCharac-        An Activity MAY be performed once or MAY be repeated. If repeated,
 teristics [0..1]                        the Activity MUST have loopCharacteristics that define the repe-
                                         tition criteria (if the isExecutable attribute of the Process is set to
                                         true).

 resources: ResourceRole [0..*]          Defines the resource that will perform or will be responsible for the
                                         Activity. The resource, e.g., a performer, can be specified in the form of
                                         a specific individual, a group, an organization role or position, or an orga-
                                         nization.

 default: SequenceFlow [0..1]            The Sequence Flow that will receive a token when none of the
                                         conditionExpressions on other outgoing Sequence Flows evalu-
                                         ate to true. The default Sequence Flow should not have a
                                         conditionExpression. Any such Expression SHALL be ignored.

 ioSpecification: Input                  The InputOutputSpecification defines the inputs and outputs and
 OutputSpecification [0..1]              the InputSets and OutputSets for the Activity. See page 215 for
                                         more information on the InputOutputSpecification.

 properties: Property [0..*]             Modeler-defined properties MAY be added to an Activity. These
                                         properties are contained within the Activity.

 boundaryEventRefs:                      This references the Intermediate Events that are attached to the
 BoundaryEvent [0..*]                    boundary of the Activity.

 dataInputAssociations: DataIn-          An optional reference to the DataInputAssociations. A
 putAssociation [0..*]                   DataInputAssociation defines how the DataInput of the Activity’s
                                         InputOutputSpecification will be populated.

 dataOutputAssociations:                 An optional reference to the DataOutputAssociations.
 DataOutputAssociation [0..*]




154                                                                          Business Process Model and Notation, v2.0
Table 10.3 Activity attributes and model associations

 startQuantity: integer = 1                  The default value is 1. The value MUST NOT be less than 1. This
                                             attribute defines the number of tokens that MUST arrive before the
                                             Activity can begin. Note that any value for the attribute that is greater
                                             than 1 is an advanced type of modeling and should be used with caution.

 completionQuantity: integer = 1             The default value is 1. The value MUST NOT be less than 1. This
                                             attribute defines the number of tokens that MUST be generated from the
                                             Activity. This number of tokens will be sent done any outgoing
                                             Sequence Flow (assuming any Sequence Flow conditions are satis-
                                             fied). Note that any value for the attribute that is greater than 1 is an
                                             advanced type of modeling and should be used with caution.

In addition, an Activity instance has attributes whose values MAY be referenced by Expressions. These values are
only available when the Activity is being executed.

Table 10.4 presents the instance attributes of the Activity element:


 Table 10.4 – Activity instance attributes

 Attribute Name                                                                 Description/Usage

 state: string = None                                                           See Figure 13.2 ("The Lifecycle of a
                                                                                BPMN Activity") in Section 13.2.2 for
                                                                                permissible values.

Sequence Flow Connections

See Section “Sequence Flow Connections Rules” on page 42 for the entire set of objects and how they MAY be sources
or targets of Sequence Flows.
         An Activity MAY be a target for Sequence Flows; it can have multiple incoming Sequence Flows. Incoming
         Sequence Flows MAY be from an alternative path and/or parallel paths.
             If the Activity does not have an incoming Sequence Flow, then the Activity MUST be instantiated when the
             Process is instantiated.
                   There are two (2) exceptions to this: Compensation Activities and Event Sub-Processes.

Note – If the Activity has multiple incoming Sequence Flows, then this is considered uncontrolled flow. This means that
when a token arrives from one of the Paths, the Activity will be instantiated. It will not wait for the arrival of tokens from the
other paths. If another token arrives from the same path or another path, then a separate instance of the Activity will be
created. If the flow needs to be controlled, then the flow should converge on a Gateway that precedes the Activities (see 295
for more information on Gateways).

         An Activity MAY be a source for Sequence Flows; it can have multiple outgoing Sequence Flows. If there
         are multiple outgoing Sequence Flows, then this means that a separate parallel path is being created for each
         Sequence Flow (i.e., tokens will be generated for each outgoing Sequence Flow from the Activity).
             If the Activity does not have an outgoing Sequence Flow, then the Activity marks the end of one or more
             paths in the Process. When the Activity ends and there are no other parallel paths active, then the Process


Business Process Model and Notation, v2.0                                                                                     155
            MUST be completed.
                 There are two (2) exceptions to this: Compensation Activities and Event Sub-Processes.

Message Flow Connections

See Section “Message Flow Connection Rules” on page 43 for the entire set of objects and how they MAY be sources or
targets of Message Flows.

Note – All Message Flows MUST connect two separate Pools. They MAY connect to the Pool boundary or to Flow
Objects within the Pool boundary. They MUST NOT connect two objects within the same Pool.

        An Activity MAY be the target of a Message Flow; it can have zero (0) or more incoming Message Flows.
        An Activity MAY be a source of a Message Flow; it can have zero (0) or more outgoing Message Flows.


10.2.1 Resource Assignment

The following sections define how Resources can be defined for an Activity. Figure 10.7 displays the class diagram
for the BPMN elements used for Resource assignment.




Figure 10.7 - The class diagram for assigning Resources

Resource Role

The ResourceRole element inherits the attributes and model associations of BaseElement (see Table 8.5). Table
10.5 presents the additional model associations of the ResourceRole element:

156                                                                        Business Process Model and Notation, v2.0
 Table 10.5 – Resource Role model associations

 Attribute Name                                    Description/Usage

 resourceRef: Resource [0..1]                      The Resource that is associated with Activity. Should not
                                                   be specified when resourceAsisgnmentExpression is
                                                   provided

 resourceAssignmentExpression: Resource-           This defines the Expression used for the Resource
 AssignmentExpression [0..1]                       assignment (see below). Should not be specified when a
                                                   resourceRef is provided.

 resourceParameterBindings: Resource-              This defines the Parameter bindings used for the
 ParameterBinding [0..*]                           Resource assignment (see below). Is only applicable if a
                                                   resourceRef is specified.


Expression Assignment

Resources can be assigned to an Activity using Expressions. These Expressions MUST return Resource
entity related data types, like Users or Groups. Different Expressions can return multiple Resources. All of them
are assigned to the respective subclass of the ResourceRole element, for example as potential owners. The semantics
is defined by the subclass.

The ResourceAssignmentExpression element inherits the attributes and model associations of BaseElement
(see Table 8.5). Table 10.6 presents the additional model associations of the ResourceAssignmentExpression
element:


 Table 10.6 – ResourceAssignmentExpression model associations

 Attribute Name                  Description/Usage

 expression: Expression          The element ResourceAssignmentExpression MUST contain an
                                 Expression which is used at runtime to assign resource(s) to a
                                 ResourceRole element.


Parameterized Resource Assignment

Resources support query parameters which are passed to the Resource query at runtime. Parameters MAY refer
to Task instance data using Expressions. During Resource query execution, an infrastructure can decide which of
the Parameters defined by the Resource are used. It MAY use zero (0) or more of the Parameters specified. It
MAY also override certain Parameters with values defined during Resource deployment. The deployment
mechanism for Tasks and Resources is out of scope for this specification. Resource queries are evaluated to
determine the set of Resources, e.g. people, assigned to the Activity. Failed Resource queries are treated like
Resource queries that return an empty result set. Resource queries return one Resource or a set of Resources.

The ResourceParameterBinding element inherits the attributes and model associations of BaseElement (see
Table 8.5). Table 10.7 presents the additional model associations of the ResourceParameterBinding element:



Business Process Model and Notation, v2.0                                                                      157
 Table 10.7 – ResourceParameterBinding model associations

 Attribute Name                                   Description/Usage

 parameterRef: ResourceParameter                  Reference to the parameter defined by the Resource.

 expression: Expression                           The Expression that evaluates the value used to bind the
                                                  ResourceParameter.


10.2.2 Performer

The Performer class defines the resource that will perform or will be responsible for an Activity. The performer can
be specified in the form of a specific individual, a group, an organization role or position, or an organization.

The Performer element inherits the attributes and model associations of BaseElement (see Table 8.5) through its
relationship to ResourceRole, but does not have any additional attributes or model associations.

10.2.3 Tasks

A Task is an atomic Activity within a Process flow. A Task is used when the work in the Process cannot be broken
down to a finer level of detail. Generally, an end-user and/or applications are used to perform the Task when it is
executed.

A Task object shares the same shape as the Sub-Process, which is a rectangle that has rounded corners (see Figure
10.8).
        A Task is a rounded corner rectangle that MUST be drawn with a single thin line.
            The use of text, color, size, and lines for a Task MUST follow the rules defined in Section “Use of Text, Color,
            Size, and Lines in a Diagram” on page 41.
                A boundary drawn with a thick line SHALL be reserved for Call Activity (Global Tasks) (see page
                191).
                 A boundary drawn with a dotted line SHALL be reserved for Event Sub-Processes (see page 178) and
                thus are not allowed for Tasks.
                A boundary drawn with a double line SHALL be reserved for Transaction Sub-Processes (see page
                180) and thus are not allowed for Tasks.




Figure 10.8 - A Task object

BPMN specifies three types of markers for Task: a Loop marker or a Multi-Instance marker and a Compensation
marker. A Task MAY have one or two of these markers (see Figure 10.9).



158                                                                              Business Process Model and Notation, v2.0
        The marker for a Task that is a standard loop MUST be a small line with an arrowhead that curls back upon itself.
        See page 193 for more information on loop Activities.
             The loop Marker MAY be used in combination with the compensation marker.
         The marker for a Task that is a multi-instance MUST be a set of three vertical lines. See page 195 for more
        information on multi-instance Activities.
              If the multi-instance instances are set to be performed in sequence rather than parallel, then the marker will be
             rotated 90 degrees (see Figure 10.49, below).
             The multi-instance marker MAY be used in combination with the compensation marker.
        The marker for a Task that is used for compensation MUST be a pair of left facing triangles (like a tape player
        “rewind” button). See page 308 for more information on compensation.
             The Compensation Marker MAY be used in combination with the loop marker or the multi-instance marker.

All the markers that are present MUST be grouped and the whole group centered at the bottom of the shape.



      Loop                  Multi-Instance               Compensation




Figure 10.9 - Task markers

Figure 10.10 displays the class diagram for the Task element.




Figure 10.10 - The Task class diagram

The Task inherits the attributes and model associations of Activity (see Table 10.3). There are no further attributes or
model associations of the Task.

Business Process Model and Notation, v2.0                                                                                   159
Types of Tasks

There are different types of Tasks identified within BPMN to separate the types of inherent behavior that Tasks might
represent. The list of Task types MAY be extended along with any corresponding indicators. A Task which is not further
specified is called Abstract Task (this was referred to as the None Task in BPMN 1.2). The notation of the Abstract
Task is shown in Figure 10.8.

Service Task

A Service Task is a Task that uses some sort of service, which could be a Web service or an automated application.

A Service Task object shares the same shape as the Task, which is a rectangle that has rounded corners. However, there
is a graphical marker in the upper left corner of the shape that indicates that the Task is a Service Task (see Figure
10.11).

A Service Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a marker that
distinguishes the shape from other Task types (as shown in Figure 10.11).




Figure 10.11 - A Service Task Object

The Service Task inherits the attributes and model associations of Activity (see Table 10.3). In addition the following
constraints are introduced when the Service Task references an Operation: The Service Task has exactly one
inputSet and at most one outputSet. It has a single Data Input with an ItemDefinition equivalent to the one
defined by the Message referenced by the inMessageRef attribute of the associated Operation. If the
Operation defines output Messages, the Service Task has a single Data Output that has an ItemDefinition
equivalent to the one defined by the Message referenced by the outMessageRef attribute of the associated
Operation.

The actual Participant whose service is used can be identified by connecting the Service Task to a Participant using a
Message Flows within the definitional Collaboration of the Process – see Table 10.1.




160                                                                           Business Process Model and Notation, v2.0
Figure 10.12 - The Service Task class diagram

The Service Task inherits the attributes and model associations of Activity (see Table 10.3). Table 10.8 presents
additional the model associations of the Service Task:


 Table 10.8 – Service Task model associations

 Attribute Name                                           Description/Usage

 implementation: string = ##webService                    This attribute specifies the technology that will be used to
                                                          send and receive the Messages. Valid values are
                                                          "##unspecified" for leaving the implementation technol-
                                                          ogy open, "##WebService" for the Web service technol-
                                                          ogy or a URI identifying any other technology or
                                                          coordination protocol. A Web service is the default tech-
                                                          nology.

 operationRef: Operation [0..1]                           This attribute specifies the operation that is invoked by
                                                          the Service Task.

Send Task

A Send Task is a simple Task that is designed to send a Message to an external Participant (relative to the
Process). Once the Message has been sent, the Task is completed.

The actual Participant which the Message is sent can be identified by connecting the Send Task to a Participant using
a Message Flows within the definitional Collaboration of the Process – see Table 10.1.

A Send Task object shares the same shape as the Task, which is a rectangle that has rounded corners. However, there is
a filled envelope marker (the same marker as a throw Message Event) in the upper left corner of the shape that
indicates that the Task is a Send Task.


Business Process Model and Notation, v2.0                                                                             161
A Send Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a filled envelope
marker that distinguishes the shape from other Task types (as shown in Figure 10.13).




Figure 10.13 - A Send Task Object




Figure 10.14 - The Send Task and Receive Task class diagram

The Send Task inherits the attributes and model associations of Activity (see Table 10.3). In addition the following
constraints apply when the Send Task references a Message: The Send Task has at most one inputSet and one
Data Input. If the Data Input is present, it MUST have an ItemDefinition equivalent to the one defined by the
associated Message. At execution time, when the Send Task is executed, the data automatically moves from the Data
Input on the Send Task into the Message to be sent. If the Data Input is not present, the Message will not be
populated with data from the Process.

Table 10.9 presents the additional model associations of the Send Task:



162                                                                         Business Process Model and Notation, v2.0
 Table 10.9 – Send Task model associations

 Attribute Name                   Description/Usage

 messageRef: Message [0..1]       A Message for the messageRef attribute MAY be entered. This indicates that
                                  the Message will be sent by the Task. The Message in this context is equiva-
                                  lent to an out-only message pattern (Web service). One or more corresponding
                                  outgoing Message Flows MAY be shown on the diagram. However, the display
                                  of the Message Flows is NOT REQUIRED. The Message is applied to all out-
                                  going Message Flows and the Message will be sent down all outgoing Mes-
                                  sage Flows at the completion of a single instance of the Task.

 operationRef: Operation          This attribute specifies the operation that is invoked by the Send Task.

 implementation: string =         This attribute specifies the technology that will be used to send and receive the
 ##webService                     Messages. Valid values are "##unspecified" for leaving the implementation
                                  technology open, "##WebService" for the Web service technology or a URI
                                  identifying any other technology or coordination protocol A Web service is the
                                  default technology.

Receive Task

A Receive Task is a simple Task that is designed to wait for a Message to arrive from an external Participant
(relative to the Process). Once the Message has been received, the Task is completed.

The actual Participant from which the Message is received can be identified by connecting the Receive Task to a
Participant using a Message Flows within the definitional Collaboration of the Process – see Table 10.1.

A Receive Task is often used to start a Process. In a sense, the Process is bootstrapped by the receipt of the
Message. In order for the Receive Task to instantiate the Process its instantiate attribute MUST be set to true
and it MUST NOT have any incoming Sequence Flow.

A Receive Task object shares the same shape as the Task, which is a rectangle that has rounded corners. However, there
is an unfilled envelope marker (the same marker as a catch Message Event) in the upper left corner of the shape that
indicates that the Task is a Receive Task.

A Receive Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes an unfilled
envelope marker that distinguishes the shape from other Task types (as shown in Figure 10.15). If the instantiate
attribute is set to true, the envelope marker looks like a Message Start Event (as shown in Figure 10.16).




Figure 10.15 - A Receive Task Object



Business Process Model and Notation, v2.0                                                                         163
Figure 10.16 - A Receive Task Object that instantiates a Process

The Receive Task inherits the attributes and model associations of Activity (see Table 10.3). In addition the following
constraints apply when the Receive Task references a Message: The Receive Task has at most one outputSet and
at most one Data output. If the Data output is present, it MUST have an ItemDefinition equivalent to the one
defined by the associated Message. At execution time, when the Receive Task is executed, the data automatically
moves from the Message to the Data Output on the Receive Task. If the Data Output is not present, the payload
within the Message will not flow out of the Receive Task and into the Process.

Table 10.10 presents the additional attributes and model associations of the Receive Task:


 Table 10.10 – Receive Task attributes and model associations

 Attribute Name                           Description/Usage

 messageRef: Message [0..1]               A Message for the messageRef attribute MAY be entered. This indi-
                                          cates that the Message will be received by the Task. The Message in
                                          this context is equivalent to an in-only message pattern (Web service).
                                          One (1) or more corresponding incoming Message Flows MAY be
                                          shown on the diagram. However, the display of the Message Flows is
                                          NOT REQUIRED. The Message is applied to all incoming Message
                                          Flows, but can arrive for only one (1) of the incoming Message Flows
                                          for a single instance of the Task.

 instantiate: boolean = false             Receive Tasks can be defined as the instantiation mechanism for the
                                          Process with the instantiate attribute. This attribute MAY be set to
                                          true if the Task is the first Activity (i.e., there are no incoming Sequence
                                          Flows). Multiple Tasks MAY have this attribute set to true.

 operationRef: Operation                  This attribute specifies the operation through which the Receive Task
                                          receives the Message.

 implementation: string =                 This attribute specifies the technology that will be used to send and
 ##webService                             receive the Messages. Valid values are "##unspecified" for leaving the
                                          implementation technology open, "##WebService" for the Web service
                                          technology or a URI identifying any other technology or coordination pro-
                                          tocol A Web service is the default technology.

User Task

A User Task is a typical “workflow” Task where a human performer performs the Task with the assistance of a
software application and is scheduled through a task list manager of some sort.

164                                                                           Business Process Model and Notation, v2.0
A User Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a human figure
marker that distinguishes the shape from other Task types (as shown in Figure 10.17).




Figure 10.17 - A User Task Object

See “User Task” on page 164 within the larger section of “Human Interactions” for the details of User Tasks.

Manual Task

A Manual Task is a Task that is expected to be performed without the aid of any business process execution engine or
any application. An example of this could be a telephone technician installing a telephone at a customer location.

A Manual Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a hand figure
marker that distinguishes the shape from other Task types (as shown in Figure 10.17).




Figure 10.18 - A Manual Task Object

See “Manual Task” on page 167 within the larger section of “Human Interactions” for the details of Manual Tasks.

Business Rule

A Business Rule Task provides a mechanism for the Process to provide input to a Business Rules Engine and to get
the output of calculations that the Business Rules Engine might provide. The InputOutputSpecification of the
Task (see page 215) will allow the Process to send data to and receive data from the Business Rules Engine.

A Business Rule Task object shares the same shape as the Task, which is a rectangle that has rounded corners.
However, there is a graphical marker in the upper left corner of the shape that indicates that the Task is a Business
Rule Task (see Figure 10.11).

A Business Rule Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a marker
that distinguishes the shape from other Task types (as shown in Figure 10.19).




Business Process Model and Notation, v2.0                                                                           165
Figure 10.19 - A Business Rule Task Object

The Business Rule Task inherits the attributes and model associations of Activity (see Table 10.3). Table 10.11
presents the additional attributes of the Business Rule Task:


 Table 10.11 – Business Rule Task attributes and model associations

 Attribute Name                         Description/Usage

 implementation: string =               This attribute specifies the technology that will be used to implement the
 ##unspecified                          Business Rule Task. Valid values are "##unspecified" for leaving the
                                        implementation technology open, "##WebService" for the Web service
                                        technology or a URI identifying any other technology or coordination
                                        protocol. The default technology for this task is unspecified.

Script Task

A Script Task is executed by a business process engine. The modeler or implementer defines a script in a language that
the engine can interpret. When the Task is ready to start, the engine will execute the script. When the script is completed,
the Task will also be completed.

A Script Task object shares the same shape as the Task, which is a rectangle that has rounded corners. However, there
is a graphical marker in the upper left corner of the shape that indicates that the Task is a Script Task (see Figure
10.11).

A Script Task is a rounded corner rectangle that MUST be drawn with a single thin line and includes a marker that
distinguishes the shape from other Task types (as shown in Figure 10.20).




Figure 10.20 - A Script Task Object

The Script Task inherits the attributes and model associations of Activity (see Table 10.3). Table 10.12 presents the
additional attributes of the Script Task:


166                                                                              Business Process Model and Notation, v2.0
 Table 10.12 – Script Task attributes

 Attribute Name                      Description/Usage

 scriptFormat: string [0..1]         Defines the format of the script. This attribute value MUST be specified with a
                                     mime-type format. And it MUST be specified if a script is provided.

 script: string [0..1]               The modeler MAY include a script that can be run when the Task is per-
                                     formed. If a script is not included, then the Task will act as the equivalent of
                                     an Abstract Task.


10.2.4 Human Interactions

Tasks with Human involvement

In many business workflows, human involvement is needed to complete certain Tasks specified in the workflow model.
BPMN specifies two different types of Tasks with human involvement, the Manual Task and the User Task.

A User Task is executed by and managed by a business process runtime. Attributes concerning the human involvement,
like people assignments and UI rendering can be specified in great detail. A Manual Task is neither executed by nor
managed by a business process runtime.

Notation

Both, the Manual Task and User Task share the same shape, which is a rectangle that has rounded corners. Manual
Tasks and User Tasks have a Icons to indicate the human involvement is REQUIRED to complete the Task (see Figure
10.15 and Figure 10.17, above).

Manual Task

A Manual Task is a Task that is not managed by any business process engine. It can be considered as an unmanaged
Task, unmanaged in the sense of that the business process engine doesn’t track the start and completion of such a Task.
An example of this could be a paper based instruction for a telephone technician to install a telephone at a customer
location.




Figure 10.21 - Manual Task class diagram



Business Process Model and Notation, v2.0                                                                           167
The User Task inherits the attributes and model associations of Activity (see Table 10.3), but does not have any
additional attributes or model associations.

User Task

A User Task is a typical “workflow” Task where a human performer performs the Task with the assistance of a
software application.. The lifecycle of the Task is managed by a software component (called task manager) and is
typically executed in the context of a Process.




Figure 10.22 - User Task class diagram

The User Task can be implemented using different technologies, specified by the implementation attribute. Besides
the Web service technology, any technology can be used. A User Task for instance can be implemented using WS-
HumanTask by setting the implementation attribute to "http://docs.oasis-open.org/ns/bpel4people/ws-humantask/protocol/
200803."

The User Task inherits the attributes and model associations of Activity (see Table 10.3). Table 10.13 presents the
additional attributes and model associations of the User Task. If implementations extend these attributes (e.g., to
introduce subjects or descriptions with presentation parameters), they SHOULD use attributes defined by the OASIS WS-
HumanTask specification.




168                                                                           Business Process Model and Notation, v2.0
 Table 10.13 – User Task attributes and model associations

 Attribute Name                        Description/Usage

 implementation: string =              This attribute specifies the technology that will be used to implement the
 ##unspecified                         User Task. Valid values are "##unspecified" for leaving the implementa-
                                       tion technology open, "##WebService" for the Web service technology
                                       or a URI identifying any other technology or coordination protocol. The
                                       default technology for this task is unspecified.

 renderings: Rendering [0..*]          This attributes acts as a hook which allows BPMN adopters to specify
                                       task rendering attributes by using the BPMN Extension mechanism.
 The User Task inherits the instance attributes of Activity (see Table 8.49). Table 10.14 presents the instance
 attributes of the User Task element:


 Table 10.14 – User Task instance attributes

 Attribute Name                             Description/Usage

 actualOwner: string                        Returns the “user” who picked/claimed the User task and became
                                            the actual owner of it. The value is a literal representing the user’s
                                            id, email address etc.

 taskPriority: integer                      Returns the priority of the User Task.



Rendering of User Tasks

BPMN User Tasks need to be rendered on user interfaces like forms clients, portlets, etc. The Rendering element
provides an extensible mechanism for specifying UI renderings for User Tasks (Task UI). The element is optional. One
or more rendering methods can be provided in a Task definition. A User Task can be deployed on any compliant
implementation, irrespective of the fact whether the implementation supports specified rendering methods or not. The
Rendering element is the extension point for renderings. Things like language considerations are opaque for the
Rendering element because the rendering applications typically provide Multilanguage support. Where this is not the
case, providers of certain rendering types can decide to extend the rendering type in order to provide language
information for a given rendering. The content of the rendering element is not defined by this specification.

Human Performers

People can be assigned to Activities in various roles (called “generic human roles” in WS-HumanTask). BPMN 1.2
traditionally only has the Performer role. In addition to supporting the Performer role, BPMN 2.0 defines a specific
HumanPerformer element allowing specifying more specific human roles as specialization of HumanPerformer, such as
PotentialOwner.




Business Process Model and Notation, v2.0                                                                            169
Figure 10.23 - HumanPerformer class diagram

The HumanPerformer element inherits the attributes and model associations of ResourceRole (see Table 10.5),
through its relationship to Performer, but does not have any additional attributes or model associations.

Potential Owners

Potential owners of a User Task are persons who can claim and work on it. A potential owner becomes the actual owner
of a Task, usually by explicitly claiming it.

XML Schema for Human Interactions


 Table 10.15 – ManualTask XML schema

 <xsd:element name="manualTask" type="tManualTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tManualTask">
     <xsd:complexContent>
     <xsd:extension base="tTask"/>
     </xsd:complexContent>
 </xsd:complexType>




170                                                                         Business Process Model and Notation, v2.0
 Table 10.16 – UserTask XML schema

 <xsd:element name="userTask" type="tUserTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tUserTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:sequence>
                 <xsd:element ref="rendering" minOccurs="0" maxOccurs="unbounded"/>
             </xsd:sequence>
             <xsd:attribute name="implementation" type="tImplementation"
              default="##unspecified"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 <xsd:element name="rendering" type="tRendering"/>
 <xsd:complexType name="tRendering">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement"/>
     </xsd:complexContent>
 </xsd:complexType>


 <xsd:simpleType name="tImplementation">
     <xsd:union memberTypes="xsd:anyURI">
         <xsd:simpleType>
             <xsd:restriction base="xsd:token">
                 <xsd:enumeration value="##unspecified" />
                 <xsd:enumeration value="##WebService" />
             </xsd:restriction>
         </xsd:simpleType>
     </xsd:union>
 </xsd:simpleType>




 Table 10.17 – HumanPerformer XML schema

 <xsd:element name="humanPerformer" type="tHumanPerformer" substitutionGroup="performer"/>
 <xsd:complexType name="tHumanPerformer">
    <xsd:complexContent>
         <xsd:extension base="tPerformer">
             <xsd:sequence>
                 <xsd:element ref="peopleAssignment" minOccurs="1" maxOccurs="1"/>
             </xsd:sequence>
         </xsd:extension>
    </xsd:complexContent>
 </xsd:complexType>



Business Process Model and Notation, v2.0                                                    171
 Table 10.18 – PotentialOwner XML schema

 <xsd:element name="potentialOwner" type="tPotentialOwner" substitutionGroup="performer"/>
 <xsd:complexType name="tPotentialOwner">
     <xsd:complexContent>
         <xsd:extension base="tHumanPerformer"/>
     </xsd:complexContent>
 </xsd:complexType>

Examples

Consider the following sample procurement Process from the Buyer perspective (see Figure 10.24).




                                                                              Handle
                                                                              Order
                                                     Not
                                                   Approved
 Buyer




                    Handle         Approve                    Approved                             Review
                   Quotations       Order                                                           Order



                                                                              Handle
                                                                             Shipment



Figure 10.24 - Procurement Process Example

The Process comprises of two User Tasks

         • Approve Order: After the quotation handling, the order needs to be approved by some regional manager to continue
           with the order and shipment handling.

         • Review Order: Once the order has been shipped to the Buyer, the order and shipment documents will be reviewed
           again by someone.

The details of the Resource and resource assignments are not shown in the BPMN above. See below XML sample of
the “Buyer” Process for the Resource usage and resource assignments for potential owners.


Table 10.19 – XML serialization of Buyer process

<?xml version="1.0" encoding="UTF-8"?>
<definitions id="Definition"
         targetNamespace="http://www.example.org/UserTaskExample"
         typeLanguage="http://www.w3.org/2001/XMLSchema"
         expressionLanguage="http://www.w3.org/1999/XPath"
         xmlns="http://http://schema.omg.org/spec/BPMN/2.0"
         xmlns:tns="http://www.example.org/UserTaskExample">

172                                                                                Business Process Model and Notation, v2.0
 <resource id="regionalManager" name="Regional Manager">
  <resourceParameter id="buyerName" isRequired="true" name="Buyer Name" type="xsd:string"/>
  <resourceParameter id="region" isRequired="false" name="Region" type="xsd:string"/>
 </resource>

 <resource id="departmentalReviewer" name="Departmental Reviewer">
  <resourceParameter id="buyerName" isRequired="true" name="Buyer Name" type="xsd:string"/>
 </resource>

 <collaboration id="BuyerCollaboration" name="Buyer Collaboration">
  <participant id="BuyerParticipant" name="Buyer" processRef="BuyerProcess"/>
 </resource>

 <!-- Process definition -->
 <process id="BuyerProcess" name="Buyer Process">

  <laneSet id="BuyerLaneSet">
   <lane id="BuyerLane">
     <flowElementRef>StartProcess</flowElementRef>
     <flowElementRef>QuotationHandling</flowElementRef>
     <flowElementRef>ApproveOrder</flowElementRef>
     <flowElementRef>OrderApprovedDecision</flowElementRef>
     <flowElementRef>TerminateProcess</flowElementRef>
     <flowElementRef>OrderAndShipment</flowElementRef>
     <flowElementRef>OrderHandling</flowElementRef>
     <flowElementRef>ShipmentHandling</flowElementRef>
     <flowElementRef>OrderAndShipmentMerge</flowElementRef>
     <flowElementRef>ReviewOrder</flowElementRef>
     <flowElementRef>EndProcess</flowElementRef>
   </lane>
  </laneSet>

  <startEvent id="StartProcess"/>

  <sequenceFlow sourceRef="StartProcess" targetRef="QuotationHandling"/>

  <task id="QuotationHandling" name="Quotation Handling"/>

  <sequenceFlow sourceRef="QuotationHandling" targetRef="ApproveOrder"/>

  <userTask id="ApproveOrder" name="ApproveOrder">
   <potentialOwner>
    <resourceRef>tns:regionalManager</resourceRef>
    <resourceParameterBinding parameterRef="tns:buyerName">
     <formalExpression>getDataInput('order')/address/name</formalExpression>

Business Process Model and Notation, v2.0                                                     173
    </resourceParameterBinding>
    <resourceParameterBinding parameterRef="tns:region">
     <formalExpression>getDataInput('order')/address/country</formalExpression>
    </resourceParameterBinding>
   </potentialOwner>
  </userTask>

  <sequenceFlow sourceRef="ApproveOrder" targetRef="OrderApprovedDecision"/>

  <exclusiveGateway id="OrderApprovedDecision" gatewayDirection="diverging"/>

  <sequenceFlow sourceRef="OrderApprovedDecision" targetRef="OrderAndShipment">
   <conditionExpression>Was the Order Approved?</conditionExpression>
  </sequenceFlow>

  <sequenceFlow sourceRef="OrderApprovedDecision" targetRef="TerminateProcess">
   <conditionExpression>Was the Order NOT Approved?</conditionExpression>
  </sequenceFlow>

  <endEvent id="TerminateProcess">
   <terminateEventDefinition id="TerminateEvent"/>
  </endEvent>

  <parallelGateway id="OrderAndShipment" gatewayDirection="diverging"/>

  <sequenceFlow sourceRef="OrderAndShipment" targetRef="OrderHandling"/>
  <sequenceFlow sourceRef="OrderAndShipment" targetRef="ShipmentHandling"/>

  <task id="OrderHandling" name="Order Handling"/>

  <task id="ShipmentHandling" name="Shipment Handling"/>

  <sequenceFlow sourceRef="OrderHandling" targetRef="OrderAndShipmentMerge"/>
  <sequenceFlow sourceRef="ShipmentHandling" targetRef="OrderAndShipmentMerge"/>

  <parallelGateway id="OrderAndShipmentMerge" gatewayDirection="converging"/>

  <sequenceFlow sourceRef="OrderAndShipmentMerge" targetRef="ReviewOrder"/>

  <userTask id="ReviewOrder" name="Review Order">
   <potentialOwner>
    <resourceRef>tns:departmentalReviewer</resourceRef>
   <resourceParameterBinding parameterRef="tns:buyerName">
     <formalExpression>getDataInput('order')/address/name</formalExpression>
    </resourceParameterBinding>
   </potentialOwner>


174                                                                  Business Process Model and Notation, v2.0
  </userTask>

  <sequenceFlow sourceRef="ReviewOrder" targetRef="EndProcess"/>

  <endEvent id="EndProcess"/>

 </process>
</definitions>



10.2.5 Sub-Processes

A Sub-Process is an Activity whose internal details have been modeled using Activities, Gateways, Events, and
Sequence Flows. A Sub-Process is a graphical object within a Process, but it also can be “opened up” to show a
lower-level Process. Sub-Processes define a contextual scope that can be used for attribute visibility, transactional
scope, for the handling of exceptions (see page 280 for more details), of Events, or for compensation (see page 308 for
more details).

There are different types of Sub-Processes, which will be described in the next five (5) sections.

Embedded Sub-Process (Sub-Process)

A Sub-Process object shares the same shape as the Task object, which is a rounded rectangle.
         A Sub-Process is a rounded corner rectangle that MUST be drawn with a single thin line.
            The use of text, color, size, and lines for a Sub-Process MUST follow the rules defined in Section “Use of
            Text, Color, Size, and Lines in a Diagram” on page 41 with the exception that:
                 A boundary drawn with a thick line SHALL be reserved for Call Activity (Sub-Processes) (see page
                 187).
                 A boundary drawn with a dotted line SHALL be reserved for Event Sub-Processes (see page 178).
                 A boundary drawn with a double line SHALL be reserved for Transaction Sub-Processes (see page
                 180).

The Sub-Process can be in a collapsed view that hides its details (see Figure 10.25) or a Sub-Process can be in an
expanded view that shows its details within the view of the Process in which it is contained (see Figure 10.26). In the
collapsed form, the Sub-Process object uses a marker to distinguish it as a Sub-Process, rather than a Task.
            The Sub-Process marker MUST be a small square with a plus sign (+) inside. The square MUST be
            positioned at the bottom center of the shape.



   Collapsed
     Sub-
    Process

Figure 10.25 - A Sub-Process object (collapsed)


Business Process Model and Notation, v2.0                                                                           175
        Sub-Process
        (Expanded)




Figure 10.26 - A Sub-Process object (expanded)

They are used to create a context for exception handling that applies to a group of Activities (see page 280 for more
details). Compensations can be handled similarly (see page 308 for more details).

Expanded Sub-Processes can be used as a mechanism for showing a group of parallel Activities in a less-cluttered,
more compact way. In Figure 10.27, Activities “C” and “D” are enclosed in an unlabeled expanded Sub-Process.
These two Activities will be performed in parallel. Notice that the expanded Sub-Process does not include a Start
Event or an End Event and the Sequence Flows to/from these Events. This usage of expanded Sub-Processes for
“parallel boxes” is the motivation for having Start and End Events being optional objects.




                                   C


        A                                                      E


                                   D



Figure 10.27 - Expanded Sub-Process used as a “Parallel Box”

BPMN specifies five (5) types of standard markers for Sub-Processes. The (Collapsed) Sub-Process marker, seen in
Figure 10.24, can be combined with four (4) other markers: a loop marker or a multi-instance marker, a Compensation
marker, and an Ad-Hoc marker. A collapsed Sub-Process MAY have one to three of these other markers, in all
combinations except that loop and multi-instance cannot be shown at the same time (see Figure 10.28).
         The marker for a Sub-Process that loops MUST be a small line with an arrowhead that curls back upon itself.
             The loop marker MAY be used in combination with any of the other markers except the multi-instance marker.

176                                                                           Business Process Model and Notation, v2.0
         The marker for a Sub-Process that has multiple instances MUST be a set of three vertical lines in parallel.
             The multi-instance marker MAY be used in combination with any of the other markers except the loop marker.
         The marker for an ad-hoc Sub-Process MUST be a “tilde” symbol.
             The ad-hoc marker MAY be used in combination with any of the other markers.
        The marker for a Sub-Process that is used for compensation MUST be a pair of left facing triangles (like a tape
        player “rewind” button).
             The Compensation marker MAY be used in combination with any of the other markers.
        All the markers that are present MUST be grouped and the whole group centered at the bottom of the Sub-
        Process.


                                                                                   Compensation
      Loop           Multi-Instance Compensation                   Ad-Hoc
                                                                                    and Ad-Hoc




                                                                        ~                     ~
Figure 10.28 - Collapsed Sub-Process Markers

The Sub-Process now corresponds to the Embedded Sub-Process of BPMN 1.2. The Reusable Sub-Process of BPMN 1.2
corresponds to the Call Activity (calling a Process - see page 187).

Figure 10.28 shows the class diagram related to Sub-Processes.




Figure 10.29- The Sub-Process class diagram




Business Process Model and Notation, v2.0                                                                              177
The Sub-Process element inherits the attributes and model associations of Activity (see Table 10.3) and of
FlowElementContainer (see Table 8.45). Table 10.3 presents the additional attributes of the Sub-Process element:


 Table 10.20 – Sub-Process attributes

 Attribute Name                             Description/Usage

 triggeredByEvent: boolean = false          A flag that identifies whether this Sub-Process is an
                                            Event Sub-Process.
                                                • If false, then this Sub-Process is a normal Sub-Process.
                                                • If true, then this Sub-Process is an Event Sub-Process and is
                                                  subject to additional constraints (see page 178).

 artifacts: Artifact [0..*]                 This attribute provides the list of Artifacts that are contained within the
                                            Sub-Process.

Reusable Sub-Process (Call Activity)

The reusable Sub-Process of BPMN 1.2 corresponds to the Call Activity that calls a pre-defined Process. See details
of a Call Activity on page 187.

Event Sub-Process

An Event Sub-Process is a specialized Sub-Process that is used within a Process (or Sub-Process). A Sub-
Process is defined as an Event Sub-Process when its triggeredByEvent attribute is set to true.

An Event Sub-Process is not part of the normal flow of its parent Process—there are no incoming or outgoing
Sequence Flows.
         An Event Sub-Process MUST NOT have any incoming or outgoing Sequence Flows.

An Event Sub-Process MAY or MAY NOT occur while the parent Process is active, but it is possible that it will
occur many times. Unlike a standard Sub-Process, which uses the flow of the parent Process as a trigger, an Event
Sub-Process has a Start Event with a trigger. Each time the Start Event is triggered while the parent Process is
active, then the Event Sub-Process will start.
         The Start Event of an Event Sub-Process MUST have a defined trigger.
             The Start Event trigger (EventDefinition) MUST be from the following types: Message, Error,
             Escalation, Compensation, Conditional, Signal, and Multiple (see page 265 for more details).
         An Event Sub-Process MUST have one and only one Start Event.

An Event Sub-Process object shares the same basic shape as the Sub-Process object, which is a rounded rectangle.
        An Event Sub-Process is a rounded corner rectangle that MUST be drawn with a single thin dotted line (see
        Figure 10.30 and Figure 10.31).
             The use of text, color, size, and lines for an Event Sub-Process MUST follow the rules defined in Section
             “Use of Text, Color, Size, and Lines in a Diagram” on page 41 with the exception that:
         If the Event Sub-Process is collapsed, then its Start Event will be used as a marker in the upper left corner of
        the shape (see Figure 10.30).



178                                                                             Business Process Model and Notation, v2.0
    Event Sub-
     Process

Figure 10.30 - An Event Sub-Process object (Collapsed)




            Expanded Event Sub-Process




Figure 10.31 - An Event Sub-Process object (expanded)

There are two (2) possible consequences to the parent Process when an Event Sub-Process is triggered: 1) the parent
Process can be interrupted, and 2) the parent Process can continue its work (not interrupted). This is determined by the
type of Start Event that is used. See page 246 for the list of interrupting and non-interrupting Event Sub-Process
Start Events.

Figure 10.32 provides an example of a Sub-Process that includes three (3) Event Sub-Processes. The first Event
Sub-Process is triggered by a Message, does not interrupt the Sub-Process, and can occur multiple times. The
second Event Sub-Process is used for compensation and will only occur after the Sub-Process has completed. The
third Event Sub-Process handles errors that occur while the Sub-Process is active and will stop (interrupt) the Sub-
Process if triggered.




Business Process Model and Notation, v2.0                                                                           179
                                                                                                                              Notify
                                                                                                                             Customer
                                                                                                             Retry Limit    Invalid CC
                                                                                                             Exceeded


                                                                  Booking
                                                                                                             Booking

                                                    Book Flight


               Get Credit
                                                                      Cancel                              Charge
                  Card
                                                                      Flight                            Credit Card
              Information



                                                    Book Hotel



                                                                      Cancel
                                                                       Hotel




                                          Update Credit Card Information

                                                      Update
                                                    Credit Card
                                                       Info




                                                       Handle Compensation

                                                                             Update
                                                                            Customer
                                                                             Record
                                         Booking   Flight    Hotel



                                                                                                                             Notify
                                                     Handle Booking Error
                                                                                                                            Customer
                                                                                                              Retry Limit    Failed
                                                                                              Booking                       Booking
                                                                                              Error 2         Exceeded
                                                             Flight


                                         Booking                                 Booking
                                         Error 1                                 Error 2

                                                             Hotel




Figure 10.32 - An example that includes Event Sub-Processes

Transaction

A Transaction is a specialized type of Sub-Process which will have a special behavior that is controlled through a
transaction protocol (such as WS-Transaction). The boundary of the Sub-Process will be double-lined to indicate that it
is a Transaction (see Figure 10.33).
              A Transaction Sub-Process is a rounded corner rectangle that MUST be drawn with a double thin line.
                  The use of text, color, size, and lines for a transaction Sub-Process MUST follow the rules defined in
                  Section “Use of Text, Color, Size, and Lines in a Diagram” on page 41.




180                                                                                        Business Process Model and Notation, v2.0
                                    Bookings


                       Book Flight



                                            Cancel
                                            Flight
                                                                  Successful       Charge
                                                                   Bookings        Buyer

                        Book Hotel



                                        Send Hotel
                                        Cancellation




                                                                          Send
    Transaction                                         Failed
                                                                       Unavailability
                                                       Bookings
                                                                         Notice
                                                      Handle
                                                      through
                             Exceptions              Customer
                             (Hazards)                Service
Figure 10.33 - A Transaction Sub-Process




Business Process Model and Notation, v2.0                                                   181
                                      Successful            Charge
                 Bookings
                                       Bookings             Buyer



                                                                   Send
                                      Failed
                                                                Unavailability
                                     Bookings
                                                                  Notice
                                        Handle
                                        through
           Exceptions                  Customer
           (Hazards)                    Service

Figure 10.34 - A Collapsed Transaction Sub-Process

The Transaction Sub-Process element inherits the attributes and model associations of Activities (see Table 10.3)
through its relationship to Sub-Process. Table 10.21 presents the additional attributes and model associations of the
Transaction Sub-Process:


 Table 10.21 – Transaction Sub-Process attributes and model associations

 Attribute Name                                       Description/Usage

 method: TransactionMethod                            The method is an attribute that defines the Transaction method
                                                      used to commit or cancel a Transaction. For executable
                                                      Processes, it SHOULD be set to a technology specific URI,
                                                      e.g., http://schemas.xmlsoap.org/ws/2004/10/wsat
                                                      for WS-AtomicTransaction, or http://docs.oasis-
                                                      open.org/ws-tx/wsba/2006/06/AtomicOutcome for
                                                      WS-BusinessActivity. For compatibility with BPMN 1.1, it can
                                                      also be set to "##compensate", "##store", or "##image".


There are three basic outcomes of a Transaction:

      1.   Successful completion: this will be shown as a normal Sequence Flow that leaves the Transaction Sub-
           Process.

      2.   Failed completion (Cancel): When a Transaction is cancelled, the Activities inside the Transaction will be
           subjected to the cancellation actions, which could include rolling back the Process and compensation (see page 308
           for more information on compensation) for specific Activities. Note that other mechanisms for interrupting a
           Transaction Sub-Process will not cause compensation (e.g., Error, Timer, and anything for a non-Transaction
           Activity). A Cancel Intermediate Event, attached to the boundary of the Activity, will direct the flow after the


182                                                                                Business Process Model and Notation, v2.0
         Transaction has been rolled back and all compensation has been completed. The Cancel Intermediate Event
         can only be used when attached to the boundary of a Transaction Sub-Process. It cannot be used in any normal
         flow and cannot be attached to a non-Transaction Sub-Process. There are two mechanisms that can signal the
         cancellation of a Transaction:
             •   A Cancel End Event is reached within the transaction Sub-Process. A Cancel End Event can only
                 be used within a transaction Sub-Process.
             •   A cancel Message can be received via the transaction protocol that is supporting the execution of the
                 Transaction Sub-Process.

    3.   Hazard: This means that something went terribly wrong and that a normal success or cancel is not possible. Error
         Intermediate Events are used to show Hazards. When a Hazard happens, the Activity is interrupted (without
         compensation) and the flow will continue from the Error Intermediate Event.

The behavior at the end of a successful Transaction Sub-Process is slightly different than that of a normal Sub-
Process. When each path of the Transaction Sub-Process reaches a non-Cancel End Event(s), the flow does not
immediately move back up to the higher-level parent Process, as does a normal Sub-Process. First, the transaction
protocol needs to verify that all the Participants have successfully completed their end of the Transaction. Most of the
time this will be true and the flow will then move up to the higher-level Process. But it is possible that one of the
Participants can end up with a problem that causes a Cancel or a Hazard. In this case, the flow will then move to the
appropriate Intermediate Event, even though it had apparently finished successfully.

Ad-Hoc Sub-Process

An Ad-Hoc Sub-Process is a specialized type of Sub-Process that is a group of Activities that have no REQUIRED
sequence relationships. A set of Activities can be defined for the Process, but the sequence and number of
performances for the Activities is determined by the performers of the Activities.

A Sub-Process is marked as being ad-hoc with a “tilde” symbol placed at the bottom center of the Sub-Process shape
(see Figure 10.35 and Figure 10.36).
         The marker for an Ad-Hoc Sub-Process MUST be a “tilde” symbol.
             The Ad-Hoc Marker MAY be used in combination with any of the other markers.




            ~
Figure 10.35 - A collapsed Ad-Hoc Sub-Process




Business Process Model and Notation, v2.0                                                                                183
             ~
Figure 10.36 - An expanded Ad-Hoc Sub-Process

The Ad-Hoc Sub-Process element inherits the attributes and model associations of Activities (see Table 10.3) through
its relationship to Sub-Process. Table 10.22 presents the additional model associations of the Ad-Hoc Sub-Process:


 Table 10.22 – Ad-hoc Sub-Process model associations

 Attribute Name                     Description/Usage

 completionCondition:               This Expression defines the conditions when the Process will end. When
 Expression                         the Expression is evaluated to true, the Process will be terminated.

 ordering: AdHocOrdering =          This attribute defines if the Activities within the Process can be performed in
 Parallel                           parallel or MUST be performed sequentially. The default setting is parallel
 { Parallel | Sequential }          and the setting of sequential is a restriction on the performance that can be
                                    needed due to shared resources. When the setting is sequential, then only
                                    one Activity can be performed at a time. When the setting is parallel, then
                                    zero (0) to all the Activities of the Sub-Process can be performed in parallel.

 cancelRemaining-                   This attribute is used only if ordering is parallel. It determines whether running
 Instances: boolean = true          instances are cancelled when the completionCondition becomes true.


Activities within the Process are generally disconnected from each other. During execution of the Process, any one or
more of the Activities MAY be active and they MAY be performed multiple times. The performers determine when
Activities will start, what the next Activity will be, and so on.

Examples of the types of Processes that are Ad-Hoc include computer code development (at a low level), sales
support, and writing a book chapter. If we look at the details of writing a book chapter, we could see that the Activities
within this Process include: researching the topic, writing text, editing text, generating graphics, including graphics in
the text, organizing references, etc. (see Figure 10.37). There MAY be some dependencies between Tasks in this
Process, such as writing text before editing text, but there is not necessarily any correlation between an instance of
writing text to an instance of editing text. Editing can occur infrequently and based on the text of many instances of the
writing text Task.




184                                                                             Business Process Model and Notation, v2.0
                                        Write a Book Chapter
                                                                                Write/Edit
                                                                                  Text
                Research
                                                      Write Text
                the Topic




                                             Include
                Generate
                                            Graphics in
                Graphics
                                               Text
                                                                                       Finalize
                                                                                       Chapter

                  Organize
                 References




Figure 10.37 - An Ad-Hoc Sub-Process for writing a book chapter

Although there is no explicit Process structure, some sequence and data dependencies can be added to the details of the
Process. For example, we can extend the book chapter Ad-Hoc Sub-Process shown above and add Data Objects,
Data Associations, and even Sequence Flows (Figure 10.38).

Ad-Hoc Sub-Processes restrict the use of BPMN elements that would normally be used in Sub-Processes.
         The list of BPMN elements that MUST be used in an Ad-Hoc Sub-Process: Activity.
        The list of BPMN elements that MAY be used in an Ad-Hoc Sub-Process: Data Object, Sequence Flow,
        Association, Data Association, Group, Message Flow (as a source or target), Gateway, and Intermediate
        Event.
        The list of BPMN elements that MUST NOT be used in an Ad-Hoc Sub-Process: Start Event, End Event,
        Conversations (graphically), Conversation Links (graphically), and Choreography Activities.




Business Process Model and Notation, v2.0                                                                          185
                                        Write a Book Chapter
                                                                                Write/Edit
                                                                                  Text
                                   Research
                Research            Notes             Write Text
                the Topic



      Topic
                               Graphics                         Chapter Text
                             [completed]                           [draft]
                                            Include
                Generate
                                           Graphics in
                Graphics
                                              Text
                                                                                       Finalize
                                                                                       Chapter

                  Organize
                 References                                  References

                                                                                       Chapter
                                                                                     [completed]

Figure 10.38 - An Ad-Hoc Sub-Process with data and sequence dependencies

The Data Objects as inputs into the Tasks act as an additional constraint for the performance of those Tasks. The
performers still determine when the Tasks will be performed, but they are now constrained in that they cannot start the
Task without the appropriate input. The addition of Sequence Flows between the Tasks (e.g., between “Generate
Graphics” and “Include Graphics in Text”) creates a dependency where the performance of the first Task MUST be
followed by a performance of the second Task. This does not mean that the second Task is to be performed immediately,
but there MUST be a performance of the second Task after the performance of the first Task.

It is a challenge for a BPM engine to monitor the status of Ad-Hoc Sub-Processes, usually these kind of Processes
are handled through groupware applications (such as e-mail), but BPMN allows modeling of Processes that are not
necessarily executable, although there are some process engines that can follow an Ad-Hoc Sub-Process. Given this, at
some point the Ad-Hoc Sub-Process will have complete and this can be determined by evaluating a
completionCondition that evaluates Process attributes that will have been updated by an Activity in the
Process.




186                                                                           Business Process Model and Notation, v2.0
10.2.6 Call Activity

A Call Activity identifies a point in the Process where a global Process or a Global Task is used. The Call
Activity acts as a ‘wrapper’ for the invocation of a global Process or Global Task within the execution. The
activation of a call Activity results in the transfer of control to the called global Process or Global Task.

The BPMN 2.0 Call Activity corresponds to the Reusable Sub-Process of BPMN 1.2. A BPMN 2.0 Sub-Process
corresponds to the Embedded Sub-Process of BPMN 1.2 (see the previous section).

A Call Activity object shares the same shape as the Task and Sub-Process, which is a rectangle that has rounded
corners. However, the target of what the Activity calls will determine the details of its shape.
        If the Call Activity calls a Global Task, then the shape will be the same as a Task, but the boundary of the shape
        will MUST have a thick line (see Figure 10.39).
            The Call Activity MUST display the marker of the type of Global Task (e.g., the Call Activity would
            display the User Task marker if calling a Global User Task).
         If the Call Activity calls a Process, then there are two (2) options:
            The details of the called Process can be hidden and the shape of the Call Activity will be the same as a
            collapsed Sub-Process, but the boundary of the shape MUST have a thick line (see Figure 10.40).

If the details of the called Process are available, then the shape of the Call Activity will be the same as a expanded
Sub-Process, but the boundary of the shape MUST have a thick line (see Figure 10.41).




Figure 10.39- A Call Activity object calling a Global Task




Figure 10.40 - A Call Activity object calling a Process (Collapsed)




Business Process Model and Notation, v2.0                                                                              187
Figure 10.41 - A Call Activity object calling a Process (Expanded)

When a Process with a definitional Collaboration, calls a Process that also has a definitional Collaboration, the
Participants of the two (2) Collaborations can be matched to each other using ParticipantAssociations of the
Collaboration of the calling Process.

A Call Activity MUST fullfil the data requirements, as well as return the data produced by the CallableElement
being invoked (see Figure 10.41). This means that the elements contained in the Call Activity’s
InputOutputSpecification MUST exactly match the elements containes in the referenced CallableElement.
This includes DataInputs, DataOutputs, InputSets, and OutputSets.




188                                                                       Business Process Model and Notation, v2.0
Figure 10.42 -The Call Activity class diagram

A Call Activity can override properties and attributes of the element being called, potentially changing the behavior of
the called element based on the calling context. For example, When the Call Activity defines one or more
ResourceRole elements, the elements defined by the CallableElement are ignored and the elements defined in the
Call Activity are used instead. Also, Events that are propagated along the hierarchy (errors and escalations) are
propagated from the called element to the Call Activity (and can be handled on its boundary).

The Call Activity inherits the attributes and model associations of Activity (see Table 10.3). Table 10.23 presents the
additional model associations of the Call Activity:


 Table 10.23 – CallActivity model associations

 Attribute Name                         Description/Usage

 calledElement: CallableElement         The element to be called, which will be either a Process or a
 [0..1]                                 GlobalTask. Other CallableElements, such as Choreography,
                                        GlobalChoreographyTask, Conversation, and
                                        GlobalCommunication MUST NOT be called by the Call Conversation
                                        element.




Business Process Model and Notation, v2.0                                                                            189
Callable Element

CallableElement is the abstract super class of all Activities that have been defined outside of a Process or
Choreography but which can be called (or reused), by a Call Activity, from within a Process or Choreography. It
MAY reference Interfaces that define the service operations that it provides. The BPMN elements that can be called
by Call Activities (i.e., are CallableElements) are: Process and GlobalTask (see Figure 10.43).

CallableElements are RootElements, which can be imported and used in other Definitions. When
CallableElements (e.g., Process) are defined, they are contained within Definitions.




Figure 10.43 - CallableElement class diagram

The CallableElement inherits the attributes and model associations of BaseElement (see Table 8.5) through its
relationship to RootElement. Table 10.24 presents the additional attributes and model associations of the
CallableElement:




190                                                                        Business Process Model and Notation, v2.0
 Table 10.24 – CallableElement attributes and model associations

 Attribute Name                    Description/Usage

 name: string [0..1]               The descriptive name of the element.

 supportedInterfaceRefs:           The Interfaces describing the external behavior provided by this
 Interface [0..*]                  element.

 ioSpecification: Input            The InputOutputSpecification defines the inputs and outputs and
 OutputSpecification [0..1]        the InputSets and OutputSets for the Activity.

 ioBinding: InputOutput            The InputOutputBinding defines a combination of one InputSet
 Binding [0..*]                    and one OutputSet in order to bind this to an operation defined in an
                                   interface.

When a CallableElement is exposed as a Service, it has to define one or more InputOutputBinding
elements. An InputOutputBinding element binds one Input and one Output of the
InputOutputSpecification to an Operation of a Service Interface. Table 10.25 presents the additional
model associations of the InputOutputBinding:


 Table 10.25 – InputOutputBinding model associations

 Attribute Name                    Description/Usage

 inputDataRef: DataInput           A reference to one specific DataInput defined as part of the
                                   InputOutputSpecification of the Activity.

 outputDataRef: DataOutput         A reference to one specific DataOutput defined as part of the
                                   InputOutputSpecification of the Activity.

 operationRef: Operation           A reference to one specific Operation defined as part of the Interface of
                                   the Activity.


10.2.7 Global Task

A Global Task is a reusable, atomic Task definition that can be called from within any Process by a Call Activity.




Business Process Model and Notation, v2.0                                                                     191
Figure 10.44 - Global Tasks class diagram

The GlobalTask inherits the attributes and model associations of Callable Element (see Table 10.24). Table 10.26
presents the additional model associations of the GlobalTask:


 Table 10.26 – Global Task model associations

 Attribute Name                      Description/Usage

 resources: ResourceRole             Defines the resource that will perform or will be responsible for the
 [0..*]                              GlobalTask. In the case where the Call Activity that references this Glo-
                                     balTask defines its own resources, they will override the ones defined here.

Types of Global Task

There are different types of Tasks identified within BPMN to separate the types of inherent behavior that Tasks might
represent. The types of Global Tasks are only a subset of standard Tasks types. Only GlobalUserTask,
GlobalManualTask, GlobalScriptTask and GlobalBusinessRuleTask are defined in BPMN. For the sake of efficiency
in this specification, the list of Task types is presented once on page 158. The behavior, attributes, and model associations
defined in that section also apply to the corresponding types of Global Tasks.



192                                                                               Business Process Model and Notation, v2.0
10.2.8 Loop Characteristics

Activities MAY be repeated sequentially, essentially behaving like a loop. The presence of LoopCharacteristics
signifies that the Activity has looping behavior. LoopCharacteristics is an abstract class. Concrete subclasses
define specific kinds of looping behavior.

The LoopCharacteristics inherits the attributes and model associations of BaseElement (see Table 8.5). There
are no further attributes or model associations of the LoopCharacteristics.

However, each Loop Activity instance has attributes whose values MAY be referenced by Expressions. These values
are only available when the Loop Activity is being executed.

Figure 10.45 displays the class diagram for an Activity’s loop characteristics, including the details of both the standard
loop and a multi-instance.




Figure 10.45 - LoopCharacteristics class diagram

The LoopCharacteristics element inherits the attributes and model associations of BaseElement (see Table 8.5),
but does not have any further attributes or model associations. However, a Loop Activity does have additional instance
attributes as shown in Table 10.27.




Business Process Model and Notation, v2.0                                                                              193
 Table 10.27 – Loop Activity instance attributes

 Attribute Name                   Description/Usage

 loopCounter: integer             The LoopCounter attribute is used at runtime to count the number of loops
                                  and is automatically updated by the process engine.



Standard Loop Characteristics

The StandardLoopCharacteristics class defines looping behavior based on a boolean condition. The Activity
will loop as long as the boolean condition is true. The condition is evaluated for every loop iteration, and MAY be
evaluated at the beginning or at the end of the iteration. In addition, a numeric cap can be optionally specified. The
number of iterations MAY NOT exceed this cap.
        The marker for a Task or a Sub-Process that is a standard loop MUST be a small line with an arrowhead that curls
        back upon itself (see Figure 10.46 and Figure 10.47).
             The loop Marker MAY be used in combination with the Compensation Marker.




Figure 10.46 - A Task object with a Standard Loop Marker




Figure 10.47 - A Sub-Process object with a Standard Loop Marker

The StandardLoopCharacteristics element inherits the attributes and model associations of BaseElement (see
Figure 8.5), through its relationship to LoopCharacteristics. Table 10.28 presents the additional attributes and
model associations for the StandardLoopCharacteristics element:




194                                                                           Business Process Model and Notation, v2.0
 Table 10.28 – StandardLoopCharacteristics attributes and model associations

 Attribute Name                             Description/Usage

 testBefore: boolean = false                Flag that controls whether the loop condition is evaluated at the begin-
                                            ning (testBefore = true) or at the end (testBefore = false) of the
                                            loop iteration.

 loopMaximum: integer [0..1]                Serves as a cap on the number of iterations.

 loopCondition: Expression [0..1]           A boolean Expression that controls the loop. The Activity will only
                                            loop as long as this condition is true. The looping behavior MAY be
                                            underspecified, meaning that the modeler can simply document the con-
                                            dition, in which case the loop cannot be formally executed.

Multi-Instance Characteristics

The MultiInstanceLoopCharacteristics class allows for creation of a desired number of Activity instances.
The instances MAY execute in parallel or MAY be sequential. Either an Expression is used to specify or calculate the
desired number of instances or a data driven setup can be used. In that case a data input can be specified, which is able to
handle a collection of data. The number of items in the collection determines the number of Activity instances. This data
input can be produced by an input Data Association. The modeler can also configure this loop to control the tokens
produced.
         The marker for a Task or Sub-Process that is a multi-instance MUST be a set of three vertical lines.
             If the multi-instance instances are set to be performed in parallel rather than sequential (the isSequential
             attribute set to false), then the lines of the marker will vertical (see Figure 10.48).
             If the multi-instance instances are set to be performed in sequence rather than parallel (the isSequential
             attribute set to true), then the marker will be horizontal (see Figure 10.49).
             The Multi-Instance marker MAY be used in combination with the Compensation marker.




Figure 10.48 - Activity Multi-Instance marker for parallel instances




Figure 10.49 - Activity Multi-Instance marker for sequential instances


Business Process Model and Notation, v2.0                                                                               195
The MultiInstanceLoopCharacteristics element inherits the attributes and model associations of
BaseElement (see Table 8.5), through its relationship to LoopCharacteristics. Table 10.29 presents the
additional attributes and model associations for the MultiInstanceLoopCharacteristics element.


Table 10.29 - MultiInstanceLoopCharacteristics attributes and model associations

 Attribute Name                         Description/Usage

 isSequential: boolean = false          This attribute is a flag that controls whether the Activity instances will
                                        execute sequentially or in parallel.

 loopCardinality: Expression [0..1]     A numeric Expression that controls the number of Activity instances
                                        that will be created. This Expression MUST evaluate to an integer.
                                        This MAY be underspecified, meaning that the modeler MAY simply
                                        document the condition. In such a case the loop cannot be formally
                                        executed.
                                        In order to initialize a valid multi-instance, either the loopCardinality
                                        Expression or the loopDataInput MUST be specified.

 loopDataInputRef:                      This ItemAwareElement is used to determine the number of Activity
 ItemAwareElement [0..1]                instances, one Activity instance per item in the collection of data stored
                                        in that ItemAwareElement element.
                                        For Tasks it is a reference to a Data Input which is part of the Activity’s
                                        InputOutputSpecification.
                                        For Sub-Processes it is a reference to a collection-valued Data Object
                                        in the context that is visible to the Sub-Processes.
                                        In order to initialize a valid multi-instance, either the loopCardinality
                                        Expression or the loopDataInput MUST be specified.

 loopDataOutputRef:                     This ItemAwareElement specifies the collection of data, which will be
 ItemAwareElement [0..1]                produced by the multi-instance.
                                        For Tasks it is a reference to a Data Output which is part of the
                                        Activity’s InputOutputSpecification.
                                        For Sub-Processes it is a reference to a collection-valued Data Object
                                        in the context that is visible to the Sub-Processes.

 inputDataItem: DataInput [0..1]        A Data Input, representing for every Activity instance the single item of
                                        the collection stored in the loopDataInput. This Data Input can be
                                        the source of DataInputAssociation to a data input of the Activity’s
                                        InputOutputSpecification. The type of this Data Input MUST the
                                        scalar of the type defined for the loopDataInput.




196                                                                         Business Process Model and Notation, v2.0
Table 10.29 - MultiInstanceLoopCharacteristics attributes and model associations

 outputDataItem: DataOutput [0..1]          A Data Output, representing for every Activity instance the single item
                                            of the collection stored in the loopDataOutput. This Data Output can
                                            be the target of DataOutputAssociation to a data output of the
                                            Activity’s InputOutputSpecification. The type of this Data
                                            Output MUST the scalar of the type defined for the loopDataOutput.

 behavior: MultiInstanceBehavior =          The attribute behavior acts as a shortcut for specifying when events
 all { None | One | All | Complex }         SHALL be thrown from an Activity instance that is about to complete. It
                                            can assume values of None, One, All, and Complex, resulting in the
                                            following behavior:
                                                • None: the EventDefinition which is associated through the
                                                  noneEvent association will be thrown for each instance
                                                  completing;
                                                • One: the EventDefinition referenced through the oneEvent
                                                  association will be thrown upon the first instance completing;
                                                • All: no Event is ever thrown; a token is produced after completion
                                                  of all instances
                                                • Complex: the complexBehaviorDefinitions are consulted to
                                                  determine if and which Events to throw.

                                            For the behaviors of none and one, a default
                                            SignalEventDefinition will be thrown which automatically carries
                                            the current runtime attributes of the MI Activity.
                                            Any thrown Events can be caught by boundary Events on the Multi-
                                            Instance Activity.

 complexBehaviorDefinition: Com-            Controls when and which Events are thrown in case behavior is set to
 plexBehaviorDefinition [0..*]              complex.

 completionCondition: Expression            This attribute defines a boolean Expression that when evaluated to
 [0..1]                                     true, cancels the remaining Activity instances and produces a token.

 oneBehaviorEventRef: EventDefi-            The EventDefinition which is thrown when behavior is set to one
 nition [0..1]                              and the first internal Activity instance has completed.

 noneBehaviorEventRef: EventDef-            The EventDefinition which is thrown when the behavior is set to
 inition [0..1]                             none and an internal Activity instance has completed.

Table 10.30 lists all instance attributes available at runtime. For each instance of the Multi-Instance Activity (outer
instance), there exist a number of generated (inner) instances of the Activity at runtime.




Business Process Model and Notation, v2.0                                                                             197
 Table 10.30 – Multi-instance Activity instance attributes

 Attribute Name                           Description/Usage
 loopCounter: integer                     This attribute is provided for each generated (inner) instance of the
                                          Activity. It contains the sequence number of the generated
                                          instance, i.e., if this value of some instance in n, the instance is the
                                          n-th instance that was generated.

 numberOfInstances: integer               This attribute is provided for the outer instance of the Multi-Instance
                                          Activity only. This attribute contains the total number of inner
                                          instances created for the Multi-Instance Activity.

 numberOfActiveInstances: integer         This attribute is provided for the outer instance of the Multi-Instance
                                          Activity only. This attribute contains the number of currently active
                                          inner instances for the Multi-Instance Activity. In case of a sequen-
                                          tial Multi-Instance Activity, this value can’t be greater than 1. For
                                          parallel Multi-Instance Activities, this value can’t be greater than
                                          the value contained in numberOfInstances

 numberOfCompletedInstances:              This attribute is provided for the outer instance of the Multi-Instance
 integer                                  Activity only. This attribute contains the number of already com-
                                          pleted inner instances for the Multi-Instance Activity.

 numberOfTerminatedInstances:             This attribute is provided for the outer instance of the
 integer                                  Multi-Instance Activity only. This attribute contains the number of
                                          terminated inner instances for the Multi-Instance Activity. The sum
                                          of numberOfTerminatedInstances,
                                          numberOfCompletedInstances, and
                                          numberOfActiveInstances always sums up to
                                          numberOfInstances.

Complex Behavior Definition

This element controls when and which Events are thrown in case behavior of the Multi-Instance Activity is set to
complex.

The ComplexBehaviorDefinition element inherits the attributes and model associations of BaseElement (see
Table 8.5). Table 10.31 presents the additional attributes and model associations for the
ComplexBehaviorDefinition element:




198                                                                           Business Process Model and Notation, v2.0
 Table 10.31 – ComplexBehaviorDefinition attributes and model associations

 Attribute Name                        Description/Usage

 condition: Formal Expression          This attribute defines a boolean Expression that when evaluated to true,
                                       cancels the remaining Activity instances and produces a token.

 event: ImplicitThrowEvent             If the condition is true, this identifies the Event that will be thrown (to be
                                       caught by a boundary Event on the Multi-Instance Activity).


10.2.9 XML Schema for Activities


 Table 10.32 – Activity XML schema

 <xsd:element name="activity" type="tActivity"/>
 <xsd:complexType name="tActivity" abstract="true">
     <xsd:complexContent>
         <xsd:extension base="tFlowNode">
             <xsd:sequence>
                 <xsd:element ref="ioSpecification" minOccurs="0" maxOccurs="1"/>
                 <xsd:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="dataInputAssociation" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="dataOutputAssociation" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="resourceRole" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="loopCharacteristics" minOccurs="0"/>
             </xsd:sequence>
             <xsd:attribute name="isForCompensation" type="xsd:boolean" default="false"/>
             <xsd:attribute name="startQuantity" type="xsd:integer" default="1"/>
             <xsd:attribute name="completetionQuantity" type="xsd:integer" default="1"/>
             <xsd:attribute name="default" type="xsd:IDREF" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




Business Process Model and Notation, v2.0                                                                               199
 Table 10.33 – AdHocSubProcess XML schema

 <xsd:element name="adHocSubProcess" type="tAdHocSubProcess" substitutionGroup="flowElement"/>
 <xsd:complexType name="tAdHocSubProcess">
     <xsd:complexContent>
         <xsd:extension base="tSubProcess">
             <xsd:sequence>
                 <xsd:element name="completionCondition" type="tExpression" minOccurs="0"
                          maxOccurs="1"/>
             </xsd:sequence>
             <xsd:attribute name="cancelRemainingInstances" type="xsd:boolean" default="true"/>
             <xsd:attribute name="ordering" type="tAdHocOrdering" default="Parallel"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>

 <xsd:simpleType name="tAdHocOrdering">
     <xsd:restriction base="xsd:string">
         <xsd:enumeration value="Parallel"/>
         <xsd:enumeration value="Sequential"/>
     </xsd:restriction>
 </xsd:simpleType>


 Table 10.34 – BusinessRuleTask XML schema

 <xsd:element name="businessRuleTask" type="tBusinessRuleTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tBusinessRuleTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:attribute name="implementation" type="tImplementation" default="##unspecified"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




200                                                                  Business Process Model and Notation, v2.0
 Table 10.35 – CallableElement XML schema

 <xsd:element name="callableElement" type="tCallableElement"/>
 <xsd:complexType name="tCallableElement">
     <xsd:complexContent>
         <xsd:extension base="tRootElement">
             <xsd:sequence>
                 <xsd:element name="supportedInterfaceRef" type="xsd:QName" minOccurs="0"
                          maxOccurs="unbounded"/>
                 <xsd:element ref="ioSpecification" minOccurs="0" maxOccurs="1"/>
                 <xsd:element ref="ioBinding" minOccurs="0" maxOccurs="unbounded"/>
             </xsd:sequence>
             <xsd:attribute name="name" type="xsd:string"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.36 – CallActivity XML schema

 <xsd:element name="callActivity" type="tCallActivity" substitutionGroup="flowElement"/>
 <xsd:complexType name="tCallActivity">
     <xsd:complexContent>
         <xsd:extension base="tActivity">
             <xsd:attribute name="calledElement" type="xsd:QName" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.37 – GlobalBusinessRuleTask XML schema

 <xsd:element name="globalBusinessRuleTask" type="tGlobalBusinessRuleTask" substitution-
         Group="rootElement"/>
 <xsd:complexType name="tGlobalBusinessRuleTask">
 <xsd:complexContent>
         <xsd:extension base="tGlobalTask">
             <xsd:attribute name="implementation" type="tImplementation" default="##unspecified"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




Business Process Model and Notation, v2.0                                                            201
 Table 10.38 – GlobalScriptTask XML schema

 <xsd:element name="globalScriptTask" type="tGlobalScriptTask" substitutionGroup="rootElement"/>
 <xsd:complexType name="tGlobalScriptTask">
     <xsd:complexContent>
         <xsd:extension base="tGlobalTask">
             <xsd:sequence>
                 <xsd:element ref="script" minOccurs="0" maxOccurs="1"/>
             </xsd:sequence>
             <xsd:attribute name="scriptLanguage" type="xsd:anyURI"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.39 – GlobalTask XML schema

 <xsd:element name="globalTask" type="tGlobalTask" substitutionGroup="rootElement"/>
 <xsd:complexType name="tGlobalScriptTask">
     <xsd:complexContent>
         <xsd:extension base="tCallableElement">
             <xsd:sequence>
                 <xsd:element ref="resourceRole" minOccurs="0" maxOccurs="unbounded"/>
             </xsd:sequence>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.40 – LoopCharacteristics XML schema

 <xsd:element name="loopCharacteristics" type="tLoopCharacteristics"/>
 <xsd:complexType name="tLoopCharacteristics" abstract="true">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement"/>
     </xsd:complexContent>
 </xsd:complexType>




202                                                                      Business Process Model and Notation, v2.0
 Table 10.41 – MultiInstanceLoopCharacteristics XML schema

 <xsd:element name="multiInstanceLoopCharacteristics" type="tMultiInstanceLoopCharacteristics"
         substitutionGroup="loopCharacteristics"/>
 <xsd:complexType name="tMultiInstanceLoopCharacteristics">
     <xsd:complexContent>
     <xsd:extension base="tLoopCharacteristics">
         <xsd:sequence>
                  <xsd:element name="loopCardinality" type="tExpression" minOccurs="0"
                          maxOccurs="1"/>
                  <xsd:element name="loopDataInputRef" type="xsd:QName" minOccurs="0"
                          maxOccurs="1"/>
                  <xsd:element name="loopDataOutputRef" type="xsd:QName" minOccurs="0"
                          maxOccurs="1"/>
                  <xsd:element name="inputDataItem" type="tDataInput" minOccurs="0" maxOccurs="1"/
                          >
                  <xsd:element name="outputDataItem" type="tDataOutput" minOccurs="0"
                          maxOccurs="1"/>
                  <xsd:element ref="complexBehaviorDefinition" minOccurs="0" maxOc-
                          curs="unbounded"/>
                  <xsd:element name="completionCondition" type="tExpression" minOccurs="0"
                          maxOccurs="1"/>
             </xsd:sequence>
             <xsd:attribute name="isSequential" type="xsd:boolean" default="false"/>
             <xsd:attribute name="behavior" type="tMultiInstanceFlowCondition" default="All"/>
             <xsd:attribute name="oneBehaviorEventRef" type="xsd:QName" use="optional"/>
             <xsd:attribute name="noneBehaviorEventRef" type="xsd:QName" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>

 <xsd:simpleType name="tMultiInstanceFlowCondition">
     <xsd:restriction base="xsd:string">
         <xsd:enumeration value="None"/>
         <xsd:enumeration value="One"/>
         <xsd:enumeration value="All"/>
         <xsd:enumeration value="Complex"/>
     </xsd:restriction>
 </xsd:simpleType>




Business Process Model and Notation, v2.0                                                            203
 Table 10.42 – ReceiveTask XML schema

 <xsd:element name="receiveTask" type="tReceiveTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tReceiveTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:attribute name="implementation" type="tImplementation" default="##WebService"/>
             <xsd:attribute name="instantiate" type="xsd:boolean" default="false"/>
             <xsd:attribute name="messageRef" type="xsd:QName" use="optional"/>
             <xsd:attribute name="operationRef" type="xsd:QName" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.43 – ResourceRole XML schema

 <xsd:element name="resourceRole" type="tResourceRole"/>
 <xsd:complexType name="tResourceRole">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:choice>
                 <xsd:sequence>
                     <xsd:element name="resourceRef" type="xsd:QName" minOccurs="0"
                         maxOccurs="1"/>
                     <xsd:element ref="resourceParameterBinding" minOccurs="0"
                         maxOccurs="unbounded"/>
                 </xsd:sequence>
                 <xsd:element ref="resourceAssignmentExpression" minOccurs="0" maxOccurs="1"/>
             </xsd:choice>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




204                                                                   Business Process Model and Notation, v2.0
 Table 10.44 – ScriptTask XML schema

 <xsd:element name="scriptTask" type="tScriptTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tScriptTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:sequence>
                 <xsd:element ref="script" minOccurs="0" maxOccurs="1"/>
             </xsd:sequence>
             <xsd:attribute name="scriptFormat" type="xsd:anyURI"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="script" type="tScript"/>
 <xsd:complexType name="tScript" mixed="true">
     <xsd:sequence>
         <xsd:any namespace="##any" processContents="lax" minOccurs="0"/>
     </xsd:sequence>
 </xsd:complexType>


 Table 10.45 – SendTask XML schema

 <xsd:element name="sendTask" type="tSendTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tSendTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:attribute name="implementation" type="tImplementation" default="##WebService"/>
             <xsd:attribute name="messageRef" type="xsd:QName" use="optional"/>
             <xsd:attribute name="operationRef" type="xsd:QName" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.46 – ServiceTask XML schema

 <xsd:element name="serviceTask" type="tServiceTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tServiceTask">
     <xsd:complexContent>
         <xsd:extension base="tTask">
             <xsd:attribute name="implementation" type="tImplementation" default="##WebService"/>
             <xsd:attribute name="operationRef" type="xsd:QName" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




Business Process Model and Notation, v2.0                                                           205
 Table 10.47 – StandardLoopCharacteristics XML schema

 <xsd:element name="standardLoopCharacteristics" type="tStandardLoopCharacteristics"/>
 <xsd:complexType name="tStandardLoopCharacteristics">
     <xsd:complexContent>
         <xsd:extension base="tLoopCharacteristics">
             <xsd:sequence>
                 <xsd:element name="loopCondition" type="tExpression" minOccurs="0"/>
             </xsd:sequence>
             <xsd:attribute name="testBefore" type="xsd:boolean" default="false"/>
             <xsd:attribute name="loopMaximum" type="xsd:integer" use="optional"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.48 – SubProcess XML schema

 <xsd:element name="subProcess" type="tSubProcess" substitutionGroup="flowElement"/>
 <xsd:complexType name="tSubProcess">
     <xsd:complexContent>
         <xsd:extension base="tActivity">
             <xsd:sequence>
                 <xsd:element ref="laneSet" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="flowElement" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="artifact" minOccurs="0" maxOccurs="unbounded"/>
             </xsd:sequence>
             <xsd:attribute name="triggeredByEvent" type="xsd:boolean" default="false"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.49 – Task XML schema

 <xsd:element name="task" type="tTask" substitutionGroup="flowElement"/>
 <xsd:complexType name="tTask">
     <xsd:complexContent>
         <xsd:extension base="tActivity"/>
     </xsd:complexContent>
 </xsd:complexType>




206                                                                   Business Process Model and Notation, v2.0
 Table 10.50 – Transaction XML schema

 <xsd:element name="transaction" type="tTransaction" substitutionGroup="flowElement"/>
 <xsd:complexType name="tTransaction">
     <xsd:complexContent>
         <xsd:extension base="tSubProcess">
             <xsd:attribute name="method" type="tTransactionMethod" default="Compensate"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>

 <xsd:simpleType name="tTransactionMethod">
     <xsd:restriction base="xsd:string">
         <xsd:enumeration value="Compensate"/>
         <xsd:enumeration value="Image"/>
         <xsd:enumeration value="Store"/>
     </xsd:restriction>
 </xsd:simpleType>




10.3 Items and Data
A traditional requirement of Process modeling is to be able to model the items (physical or information items) that are
created, manipulated, and used during the execution of a Process. An important aspect of this is the ability to capture
the structure of that data and to query or manipulate that structure.

BPMN does not itself provide a built-in model for describing structure of data or an Expression language for querying
that data. Instead it formalizes hooks that allow for externally defined data structures and Expression languages. In
addition, BPMN allows for the co-existence of multiple data structure and Expression languages within the same
model. The compatibility and verification of these languages is outside the scope of this specification and becomes the
responsibility of the tool vendor.

BPMN designates XML Schema and XPath as its default data structure and Expression languages respectively, but
vendors are free to substitute their own languages.

10.3.1 Data Modeling

A traditional requirement of Process modeling is to be able to model the items (physical or information items) that are
created, manipulated, and used during the execution of a Process.

This requirement is realized in BPMN through various constructs: Data Objects, ItemDefinition, Properties, Data
Inputs, Data Outputs, Messages, Input Sets, Output Sets, and Data Associations.

Item-Aware Elements

Several elements in BPMN are subject to store or convey items during process execution. These elements are referenced
generally as “item-aware elements.” This is similar to the variable construct common to many languages. As with
variables, these elements have an ItemDefinition.


Business Process Model and Notation, v2.0                                                                          207
The data structure these elements hold is specified using an associated ItemDefinition. An ItemAwareElement
MAY be underspecified, meaning that the structure attribute of its ItemDefinition is optional if the modeler does
not wish to define the structure of the associated data.

The elements in the specification defined as item-aware elements are: Data Objects, Data Object References, Data
Stores, Properties, DataInputs and DataOutputs.




Figure 10.50 - ItemAware class diagram

The ItemAwareElement element inherits the attributes and model associations of BaseElement (see Table 8.5).
Table 10.51 presents the additional model associations of the ItemAwareElement element:


  Table 10.51 – ItemAwareElement model associations

  Attribute Name                          Description/Usage

  itemSubjectRef: ItemDefinition [0..1]   Specification of the items that are stored or conveyed by the
                                          ItemAwareElement.

  dataState: DataState [0..1]             A reference to the DataState, which defines certain states for the data
                                          contained in the Item.




208                                                                          Business Process Model and Notation, v2.0
Data Objects

The primary construct for modeling data within the Process flow is the DataObject element. A DataObject has a
well-defined lifecycle, with resulting access constraints.

DataObject

The Data Object class is an item-aware element. Data Object elements MUST be contained within Process or Sub-
Process elements. Data Object elements are visually displayed on a Process diagram. Data Object References are
a way to reuse Data Objects in the same diagram. They can specify different states of the same Data Object at
different points in a Process. Data Object Reference cannot specify item definitions, and Data Objects cannot
specify states. The names of Data Object References are derived by concatenating the name of the referenced Data
Data Object the state of the Data Object Reference in square brackets as follows: <Data Object Name> [ <Data
Object Reference State> ]




Figure 10.51 - DataObject class diagram

The DataObject element inherits the attributes and model associations of FlowElement (see Table 8.44) and
ItemAwareElement (Table 10.52). Table 10.54 presents the additional attributes of the DataObject element:




Business Process Model and Notation, v2.0                                                                   209
  Table 10.52 – DataObject attributes

  Attribute Name                        Description/Usage

  isCollection: boolean = false         Defines if the Data Object represents a collection of elements. It is needed
                                        when no itemDefinition is referenced. If an itemDefinition is ref-
                                        erenced, then this attribute MUST have the same value as the isCollec-
                                        tion attribute of the referenced itemDefinition. The default value for
                                        this attribute is false.

The Data Object Reference element inherits the attributes and model associations of ItemAwareElement (Table
10.52) and FlowElement (see Table 8.44). Table 10.53 presents the additional attributes of the Data Object
Reference element:


  Table 10.53 – DataObjectReference attributes and model associations

  Attribute Name                        Description/Usage

  dataObjectRef: DataObject             The Data Object referenced by the Data Object Reference.

States

Data Object elements can optionally reference a DataState element, which is the state of the data contained in the
Data Object (see an example of DataStates used for Data Objects in Figure 7.8). The definition of these states, e.g.
possible values and any specific semantic are out of scope of this specification. Therefore, BPMN adopters can use the
State element and the BPMN extensibility capabilities to define their states.

The DataState element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.54
presents the additional attributes and model associations of the DataObject element:


  Table 10.54 – DataState attributes and model associations

  Attribute Name               Description/Usage

  name: string                 Defines the name of the DataState.



Data Objects representing a Collection of Data

A DataObject element that references an ItemDefinition marked as collection has to be visualized differently,
compared to single instance data structures. The notation looks as follows:

Single instance (see Figure 10.52)




210                                                                          Business Process Model and Notation, v2.0
Figure 10.52 – A DataObject

Collection (see Figure 10.53)




Figure 10.53 - A DataObject that is a collection

Visual representations of Data Objects

Data Object can appear multiple times in a Process diagram. Each of these appearances references the same Data
Object instance. Multiple occurrences of a Data Object in a diagram are allowed to simplify diagram connections.

Lifecycle and Accessibility

The lifecycle of a Data Object is tied to the lifecycle of its parent Process or Sub-Process. When a Process or
Sub-Process is instantiated, all Data Objects contained within it are also instantiated. When a Process or Sub-
Process instance is disposed, all Data Object instances contained within it are also disposed. At this point the data
within these instances are no longer available.

The accessibility of a Data Object is driven by its lifecycle. The data within a Data Object can only be accessed when
there is guaranteed to be a live Data Object instance present. As a result, a Data Object can only be accessed by its
immediate parent (Process or Sub-Process), or by its sibling Flow Elements and their children, including Data
Object References referencing the Data Object.

For example: Consider the follow structure.
        Process A
                Data object 1
                Task A
                Sub-process A
                        Data object 2
                        Task B
                Sub-process B
                        Data object 3
                        Sub-process C
                                 Data object 4
                                 Task C
                        Task D




Business Process Model and Notation, v2.0                                                                           211
“Data object 1” can be accessed by: “Process A,” “Task A,” “Sub-Process A,” “Task B,” “Sub-Process B,” “Sub-Process
C,” “Task C,” and “Task D.”

“Data object 2” can be accessed by: “Sub-Process A” and “Task B.”

“Data object 3” can be accessed by: “Sub-Process B,” “Sub-Process C,” “Task C,” and “Task D.”

“Data object 4” can be accessed by: “Sub-Process C” and “Task C.”

Data Stores

A DataStore provides a mechanism for Activities to retrieve or update stored information that will persist beyond the
scope of the Process. The same DataStore can be visualized, through a Data Store Reference, in one (1) or more
places in the Process.

The Data Store Reference is an ItemAwareElement and can thus be used as the source or target for a Data
Association. When data flows into or out of a Data Store Reference, it is effectively flowing into or out of the
DataStore that is being referenced.

The notation looks as follows (see Figure 10.54):




   Data
   Store

Figure 10.54 - A Data Store




212                                                                          Business Process Model and Notation, v2.0
Figure 10.55 - DataStore class diagram

The DataStore element inherits the attributes and model associations of FlowElement (see Table 8.44) through its
relationship to RootElement, and ItemAwareElement (see Table 10.51). Table 10.55 presents the additional
attributes of the DataStore element:


  Table 10.55 – Data Store attributes

  Attribute Name                         Description/Usage

  name: string                           A descriptive name for the element.

  capacity: integer [0..1]               Defines the capacity of the Data Store. This is not needed if the
                                         isUnlimited attribute is set to true.

  isUnlimited: boolean = false           If isUnlimited is set to true, then the capacity of a Data Store is set as
                                         unlimited and will override any value of the capacity attribute.


The Data Store Reference element inherits the attributes and model associations of FlowElement (see Table 8.44)
and ItemAwareElement (see Table 10.51). Table 10.56 presents the additional model associations of the Data Store
Reference element:




Business Process Model and Notation, v2.0                                                                        213
  Table 10.56 – Data Store attributes

  Attribute Name                    Description/Usage

  dataStoreRef: DataStore           Provides the reference to a global DataStore.


Properties

Properties, like Data Objects, are item-aware elements. But, unlike Data Objects, they are not visually displayed on a
Process diagram. Certain flow elements MAY contain properties, in particular only Processes, Activities and Events
MAY contain Properties.

The Property class is a DataElement element that acts as a container for data associated with flow elements.
Property elements MUST be contained within a FlowElement. Property elements are not visually displayed on a
Process diagram.




Figure 10.56 - Property class diagram

The Property element inherits the attributes and model associations of ItemAwareElement (Table 10.51). Table
10.54 presents the additional attributes of the Property element:




214                                                                          Business Process Model and Notation, v2.0
  Table 10.57 – Property attributes

  Attribute Name               Description/Usage

  name: string                 Defines the name of the Property.

Lifecycle and Accesibility

The lifecycle of a Property is tied to the lifecycle of its parent Flow Element. When a Flow Element is
instantiated, all Properties contained by it are also instantiated. When a Flow Element instance is disposed, all
Property instances contained by it are also disposed. At this point the data within these instances are no longer
available.

The accesibility of a Property is driven by its lifecycle. The data within a Property can only be accessed when there is
guaranteed to be a live Property instance present. As a result, a Property can only be accessed by its parent Process,
Sub-Process, or Flow Element. In case the parent is a Process or Sub-Process, then a property can be accesses by
the immediate children (including children elements) of that Process or Sub-Process. For example: Consider the
follow structure.
        Process A
                Task A
                Sub-Process A
                        Task B
                Sub-Process B
                        Sub-Process C
                                Task C
                        Task D
The Properties of “Process A” are accessible by: "Process A", "Task A", "Sub-Process A", "Task B", "Sub-Process
B", "Sub-Process C", "Task C" and "Task D"

The Properties of “Sub-Process A” are accessible by: “Sub-Process A” and “Task B.”

The Properties of “Task C” are accessible by: “Task C.”

Data Inputs and Outputs

Activities and Processes often need data in order to execute. In addition they can produce data during or as a result of
execution. Data requirements are captured as Data Inputs and InputSets. Data that is produced is captured using
Data Outputs and OutputSets. These elements are aggregated in a InputOutputSpecification class.

Certain Activities and CallableElements contain a InputOutputSpecification element to describe their
data requirements. Execution semantics are defined for the InputOutputSpecification and they apply the same
way to all elements that extend it. Not every Activity type defines inputs and outputs, only Tasks,
CallableElements (Global Tasks and Processes) MAY define their data requirements. Embedded Sub-
Processes MUST NOT define Data Inputs and Data Outputs directly, however they MAY define them indirectly via
MultiInstanceLoopCharacteristics.




Business Process Model and Notation, v2.0                                                                           215
Figure 10.57 - InputOutputSpecification class diagram

The InputOutputSpecification element inherits the attributes and model associations of BaseElement (see
Table 8.5). Figure 10.54 presents the additional attributes and model associations of the
InputOutputSpecification element:




216                                                                  Business Process Model and Notation, v2.0
  Table 10.58 – InputOutputSpecification Attributes and Model Associations

  Attribute Name                          Description/Usage

  inputSets: InputSet [1..*]              A reference to the InputSets defined by the
                                          InputOutputSpecification. Every
                                          InputOutputSpecification MUST define at least one InputSet.

  outputSets: OutputSet [1..*]            A reference to the OutputSets defined by the
                                          InputOutputSpecification. Every Data Interface MUST define
                                          at least one OutputSet.

  dataInputs: DataInput [0..*]            An optional reference to the Data Inputs of the
                                          InputOutputSpecification. If the InputOutputSpecification
                                          defines no Data Input, it means no data is REQUIRED to start the Activ-
                                          ity. This is an ordered set.

  dataOutputs: DataOutput [0..*]          An optional reference to the Data Outputs of the
                                          InputOutputSpecification. If the InputOutputSpecification
                                          defines no Data Output, it means no data is REQUIRED to finish the
                                          Activity. This is an ordered set.

Data Input

A Data Input is a declaration that a particular kind of data will be used as input of the
InputOutputSpecification. There may be multiple Data Inputs associated with an
InputOutputSpecification.

The Data Input is an item-aware element. Data Inputs are visually displayed on a Process diagram to show the inputs
to the top-level Process or to show the inputs of a called Process (i.e. one that is referenced by a Call Activity, where
the Call Activity has been expanded to show the called Process within the context of a calling Process).
        Visualized Data Inputs have the same notation as Data Objects, except that they MUST contain a small, unfilled
        block arrow (see Figure 10.58).
         Data Inputs MAY have incoming Data Associations.
              If the Data Input is directly contained by the top-level Process, it MUST not be the target of Data
             Associations within the underlying model. Only Data Inputs that are contained by Activities or Events
             MAY be the target of Data Associations in the model.
              If the Process is being called from a Call Activity, the Data Associations that target the Data Inputs of
             the Call Activity in the underlying model MAY be visualized such that they connect to the corresponding Data
             Inputs of the called Process, visually crossing the Call Activity boundary. But note that this is visualization
             only. In the underlying model, the Data Associations target the Data Inputs of the Call Activity and not
             the Data Inputs of the called Process.




Business Process Model and Notation, v2.0                                                                               217
Figure 10.58 - A DataInput

The “optional” attribute defines if a DataInput is valid even if the state is “unavailable”. The default value is false. If
the value of this attribute is true, then the execution of the Activity will not begin until a value is assigned to the
DataInput element, through the corresponding Data Associations.

States

DataInput elements can optionally reference a DataState element, which is the state of the data contained in the
DataInput. The definition of these states, e.g., possible values, and any specific semantics are out of scope of this
specification. Therefore, BPMN adopters can use the DataState element and the BPMN extensibility capabilities to
define their states.




Figure 10.59 - Data Input class diagram

The DataInput element inherits the attributes and model associations of BaseElement (see Table 8.5) and
ItemAwareElement (Table 10.52). Table 10.59 presents the additional attributes and model associations of the
DataInput element:




218                                                                              Business Process Model and Notation, v2.0
 Table 10.59 – DataInput attributes and model associations

 Attribute Name                          Description/Usage

 name: string [0..1]                     A descriptive name for the element.

 inputSetRefs: InputSet [1..*]           A DataInput is used in one (1) or more InputSets. This attribute is
                                         derived from the InputSets.

 inputSetwithOptional: InputSet          Each InputSet that uses this DataInput can determine if the Activity
 [0..*]                                  can start executing with this DataInput state in “unavailable.” This
                                         attribute lists those InputSets.

 inputSetWithWhileExecuting:             Each InputSet that uses this DataInput can determine if the Activity
 Inputset [0..*]                         can evaluate this DataInput while executing. This attribute lists those
                                         InputSets.

 isCollection: boolean = false           Defines if the DataInput represents a collection of elements. It is needed
                                         when no itemDefinition is referenced. If an itemDefinition is ref-
                                         erenced, then this attribute MUST have the same value as the isCol-
                                         lection attribute of the referenced itemDefinition. The default
                                         value for this attribute is false.

Data Output

A Data Output is a declaration that a particular kind of data can be produced as output of the
InputOutputSpecification. There MAY be multiple Data Outputs associated with a
InputOutputSpecification.

The Data Output is an item-aware element. Data Output are visually displayed on a top-level Process diagram to
show the outputs of the Process (i.e. one that is referenced by a Call Activity, where the Call Activity has been
expanded to show the called Process within the context of a calling Process).
        Visualized Data Outputs have the same notation as Data Objects, except that they MUST contain a small, filled
        block arrow (see Figure 10.60).
         Data Outputs MAY have outgoing DataAssociations.
            If the Data Output is directly contained by the top-level Process, it MUST not be the source of Data
            Associations within the underlying model. Only Data Outputs that are contained by Activities or Events
            MAY be the target of Data Associations in the model.
             If the Process is being called from a Call Activity, the Data Associations that target the Data Outputs of
            the Call Activity in the underlying model MAY be visualized such that they connect to the corresponding Data
            Outputs of the called Process, visually crossing the Call Activity boundary. But note that this is
            visualization only. In the underlying model, the Data Associations originate the Data Outputs of the Call
            Activity and not the Data Outputs of the called Process.




Business Process Model and Notation, v2.0                                                                           219
Figure 10.60 - A Data Output

States

DataOutput elements can optionally reference an DataState element, which is the state of the data contained in the
DataOutput. The definition of these states, e.g., possible values, and any specific semantics are out of scope of this
specification. Therefore, BPMN adopters can use the DataState element and the BPMN extensibility capabilities to
define their states.




Figure 10.61 - Data Output class diagram

The DataOutput element inherits the attributes and model associations of BaseElement (see Table 8.5) and
ItemAwareElement (Table 10.52). Table 10.60 presents the additional attributes and model associations of the
DataInput element:




220                                                                           Business Process Model and Notation, v2.0
  Table 10.60 – DataOutput attributes and associations

  Attribute Name                            Description/Usage

  name: string [0..1]                       A descriptive name for the element.

  outputSetRefs: OutputSet [1..*]           A DataOutput is used in one (1) or more OutputSets. This attribute
                                            is derived from the OutputSets.

  outputSetwithOptional: Output-            Each OutputSet that uses this DataOutput can determine if the
  Set [0..*]                                Activity can complete executing without producing this DataInput.
                                            This attribute lists those OutputSets.

  outputSetWithWhileExecuting:              Each OutputSet that uses this DataInput can determine if the
  OutputSet [0..*]                          Activity can produce this DataOutput while executing. This attribute
                                            lists those OutputSets.

  isCollection: boolean = false             Defines if the DataOutput represents a collection of elements. It is
                                            needed when no itemDefinition is referenced. If an
                                            itemDefinition is referenced, then this attribute MUST have the
                                            same value as the isCollection attribute of the referenced
                                            itemDefinition. The default value for this attribute is false.

The following describes the mapping of data inputs and outputs to the specific Activity and Event implementations:

Service Task Mapping

If the Service Task is associated with an Operation there MUST be a Message Data Input on the Service Task
and it MUST have an itemDefinition equivalent to the one defined by the Message referred to by the
inMessageRef attribute of the operation. If the operation defines output Messages, there MUST be a single Data
Output and it MUST have an itemDefinition equivalent to the one defined by Message referred to by the
outMessageRef attribute of the Operation.

Send Task Mapping

If the Send Task is associated with a Message, there MUST be at most inputSet set and at most one Data Input on
the Send Task. If the Data Input is present, it MUST have an itemDefinition equivalent to the one defined by the
associated Message. If the Data Input is not present, the Message will not be populated with data at execution time.

Recieve Task Mapping

If the Receive Task is associated with a Message, there MUST be at most outputSet set and at most one Data
Output on the Receive Task. If the Data Output is present, it MUST have an itemDefinition equivalent to the
one defined by the associated Message. If the Data Output is not present, the payloard within the Message will not
flow out of the Receive Task and into the Process.

User Task Mapping

User Tasks have access to the Data Input, Data Output and the data aware elements available in the scope of the
User Task.

Business Process Model and Notation, v2.0                                                                          221
Call Activity Mapping

The DataInputs and DataOutputs of the Call Activity are mapped to the corresponding elements in the
CallableElement without any explicit DataAssociation.

Script Task Mapping

Script Tasks have access to the Data Input, Data Output and the data aware elements available in the scope of the
Script Task.

Send Task Mapping

If any of the EventDefinitions for the Event is associated with an element that has an ItemDefinition (such as
a Message, Escalation, Error, or Signal), the following constraints apply:

      • If the Event is associated with multiple EventDefinitions, there MUST be one Data Input (in the case of throw
        Events) or one Data Output (in the case of catch Event) for each EventDefinition. The order of the
        EventDefinitions and the order of the Data Inputs/Outputs determine which Data Input/Output
        corresponds with which EventDefinition.

      • For each EventDefinition and Data Input/Output pair, if the Data Input/Output is present, it MUST have an
        ItemDefinition equivalent to the one defined by the Message, Escalation, Error, or Signal on the
        associated EventDefinition. In the case of a throw Event, if the Data Input is not present, the Message,
        Escalation, Error, or Signal will not be populated with data. In the case of a catch Event, if the Data Output
        is not present, the payload within the Message, Escalation, Error, or Signal will not flow out of the Event
        and into the Process.

InputSet

An InputSet is a collection of DataInput elements that together define a valid set of data inputs for a
InputOutputSpecification. An InputOutputSpecification MUST have at least one InputSet element.
An InputSet MAY reference zero or more DataInput elements. A single DataInput MAY be associated with
multiple InputSet elements, but it MUST always be referenced by at least one InputSet.

An “empty” InputSet, one that references no DataInput elements, signifies that the Activity requires no data to start
executing (this implies that either there are no data inputs or they are referenced by another input set).

InputSet elements are contained by InputOutputSpecification elements; the order in which these elements are
included defines the order in which they will be evaluated.




222                                                                           Business Process Model and Notation, v2.0
Figure 10.62 - InputSet class diagram

The InputSet element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.61
presents the additional attributes and model associations of the InputSet element:

 Table 10.61 – InputSet attributes and model associations

 Attribute Name                      Description/Usage

 name: string [0..1]                 A descriptive name for the input set.

 dataInputRefs: DataInput [0..*]     The DataInput elements that collectively make up this data requirement.

 optionalInputRefs: DataInput        The DataInput elements that are a part of the InputSet that can be in the
 [0..*]                              state of “unavailable” when the Activity starts executing. This association
                                     MUST NOT reference a DataInput that is not listed in the
                                     dataInputRefs.

 whileExecutingInputRefs:            The DataInput elements that are a part of the InputSet that can be evalu-
 DataInput [0..*]                    ated while the Activity is executing. This association MUST NOT reference a
                                     DataInput that is not listed in the dataInputRefs.

 outputSetRefs: OutputSet            Specifies an Input/Output rule that defines which OutputSet is expected to
 [0..*]                              be created by the Activity when this InputSet became valid.
                                     This attribute is paired with the inputSetRefs attribute of OutputSets.
                                     This combination replaces the IORules attribute for Activities in BPMN 1.2.




Business Process Model and Notation, v2.0                                                                      223
OutputSet

An OutputSet is a collection of DataOutputs elements that together can be produced as output from an Activity or
Event. An InputOutputSpecification element MUST define at least OutputSet element. An OutputSet
MAY reference zero or more DataOutput elements. A single DataOutput MAY be associated with multiple
OutputSet elements, but it MUST always be referenced by at least one OutputSet.

An “empty” OutputSet, one that is associated with no DataOutput elements, signifies that the ACTIVITY produces
no data.

The implementation of the element where the OutputSet is defined determines the OutputSet that will be produced.
So it is up to the Activity implementation or the Event, to define which OutputSet will be produced.




Figure 10.63 - OutputSet class diagram

The OutputSet element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.62
presents the additional attributes and model associations of the OutputSet element:




224                                                                       Business Process Model and Notation, v2.0
 Table 10.62 – OutputSet attributes and model associations

 Attribute Name                             Description/Usage

 name: string [0..1]                        A descriptive name for the input set.

 dataOutputRefs: DataOutput [0..*]          The DataOutput elements that MAY collectively be outputted.

 optionalOutputRefs: DataOutput             The DataOutput elements that are a part of the OutputSet that do not
 [0..*]                                     have to be produced when the Activity completes executing. This asso-
                                            ciation MUST NOT reference a DataOutput that is not listed in the
                                            dataOutputRefs.

 whileExecutingOutputRefs:                  The DataOutput elements that are a part of the OutputSet that can
 DataOutput [0..*]                          be produced while the Activity is executing. This association MUST
                                            NOT reference a DataOutput that is not listed in the
                                            dataOutputRefs.

 inputSetRefs: InputSet [0..*]              Specifies an Input/Output rule that defines which InputSet has to
                                            become valid to expect the creation of this OutputSet. This attribute is
                                            paired with the outputSetRefs attribute of InputSets. This combina-
                                            tion replaces the IORules attribute for Activities in BPMN 1.2.

Data Associations

Data Associations are used to move data between Data Objects, Properties, and inputs and outputs of
Activities, Processes, and GlobalTasks. Tokens do not flow along a Data Association, and as a result they have
no direct effect on the flow of the Process.

The purpose of retrieving data from Data Objects or Process Data Inputs is to fill the Activities inputs and later
push the output values from the execution of the Activity back into Data Objects or Process Data Outputs.

DataAssociation

The DataAssociation class is a BaseElement contained by an Activity or Event, used to model how data is
pushed into or pulled from item-aware elements. DataAssociation elements have one or more sources and a target;
the source of the association is copied into the target.

The ItemDefinition from the souceRef and targetRef MUST have the same ItemDefinition or the
DataAssociation MUST have a transformation Expression that transforms the source ItemDefinition into the
target ItemDefinition.




Business Process Model and Notation, v2.0                                                                        225
Figure 10.64 - DataAssociation class diagram

Optionally, Data Associations can be visually represented in the diagram by using the Association connector style (see
Figure 10.65 and Figure 10.66).




Figure 10.65 - A Data Association




                   Research
                    Notes
   Research
                                  Write Text
   the Topic


Figure 10.66 - A Data Association used for an Outputs and Inputs into an Activities

The core concepts of a DataAssociation are that they have sources, a target, and an optional transformation.

When a data association is “executed,” data is copied to the target. What is copied depends if there is a transformation
defined or not.

If there is no transformation defined or referenced, then only one source MUST be defined, and the contents of this source
will be copied into the target.



226                                                                             Business Process Model and Notation, v2.0
If there is a transformation defined or referenced, then this transformation Expression will be evaluated and the result
of the evaluation is copied into the target. There can be zero (0) to many sources defined in this case, but there is no
requirement that these sources are used inside the Expression.

In any case, sources are used to define if the data association can be “executed,” if any of the sources is in the state of
“unavailable,” then the data association cannot be executed, and the Activity or Event where the data association is
defined MUST wait until this condition is met.

Data Associations are always contained within another element that defines when these data associations are going to
be executed. Activities define two (2) sets of data associations, while Events define only 1 (one).

For Events, there is only one set, but they are used differently for catch or throw Events. For a catch Event, data
associations are used to push data from the Message received into Data Objects and properties. For a throw Event,
data associations are used to fill the Message that is being thrown.

As DataAssociation are used in different stages of the Process and Activity lifecycle, the possible sources and targets
vary according to that stage. This defines the scope of possible elements that can be referenced as source and target. For
example: when an Activity starts executing, the scope of valid targets include the Activity data inputs, while at the end
of the Activity execution, the scope of valid sources include Activity data outputs.

The DataAssociation element inherits the attributes and model associations of BaseElement (see Table 8.5). Table
10.63 presents the additional model associations of the DataAssociation element:


 Table 10.63 – DataAssociation model associations

 Attribute Name                        Description/Usage

 transformation: Expression            Specifies an optional transformation Expression. The actual scope of
 [0..1]                                accessible data for that Expression is defined by the source and target of
                                       the specific Data
                                       Association types.

 assignment: Assignment [0..*]         Specifies one or more data elements Assignments. By using an
                                       Assignment, single data structure elements can be assigned from the
                                       source structure to the target structure.

 sourceRef: ItemAwareEle-              Identifies the source of the Data Association. The source MUST be an
 ment [0..*]                           ItemAwareElement.

 targetRef: ItemAwareElement           Identifies the target of the Data Association. The target MUST be an
                                       ItemAwareElement

Assignment

The Assignment class is used to specify a simple mapping of data elements using a specified Expression language.

The default Expression language for all Expressions is specified in the Definitions element, using the
expressionLanguage attribute. It can also be overridden on each individual Assignment using the same attribute.

The Assignment element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.64
presents the additional attributes of the Assignment element:



Business Process Model and Notation, v2.0                                                                                227
 Table 10.64 – Assignment attributes

 Attribute Name               Description/Usage

 from: Expression             The Expression that evaluates the source of the Assignment.

 to: Expression               The Expression that defines the actual Assignment operation and the target
                              data element.

DataInputAssociation

The DataInputAssociation can be used to associate an ItemAwareElement element with a DataInput
contained in an Activity. The source of such a DataAssociation can be every ItemAwareElement accessible in the
current scope, e.g., a Data Object, a Property or an Expression.

The DataInputAssociation element inherits the attributes and model associations of DataAssociation (see
Table 10.64), but does not contain any additional attributes or model associations.

DataOutputAssociation

The DataOutputAssociation can be used to associate a DataOutput contained within an ACTIVITY with any
ItemAwareElement accessible in the scope the association will be executed in. The target of such a
DataAssociation can be every ItemAwareElement accessible in the current scope, e.g, a Data Object, a
Property or an Expression.

The DataOutputAssociation element inherits the attributes and model associations of DataAssociation (see
Table 10.64), but does not contain any additional attributes or model associations.

Data Objects associated with a Sequence Flow

Figure 10.67 repeats Figure 10.66, above, and shows how Data Associations are used to represent inputs and outputs
of Activities.




                   Research
                    Notes
   Research
                                 Write Text
   the Topic


Figure 10.67 - A Data Object shown as an output and an inputs

Alternatively, Data Objects MAY be directly associated with a Sequence Flow connector (see Figure 10.68) to
represent the same input/output relationships. This is a visual short cut that normalizes two Data Associations (e.g., as
seen in Figure 10.67, above): one from a item-aware element (e.g., an Activity) contained by the source of the
Sequence Flow, connecting to the Data Object; and the other from the Data Object connecting to a item-aware
element contained by the target of the Sequence Flow.

228                                                                            Business Process Model and Notation, v2.0
                   Research
                    Notes
  Research
                                  Write Text
  the Topic


Figure 10.68 - A Data Object associated with a Sequence Flow

10.3.2 Execution Semantics for Data

When an element that defines a InputOutputSpecification is ready to begin execution by means of Sequence
Flow or Event being caught, the inputs of the interface are filled with data coming from elements in the context, such as
Data Objects or Properties. The way to represent these assignments is the Data Association elements.

Each defined InputSet element will be evaluated in the order they are included in the InputOutputSpecification.

For each InputSet, the data inputs it references will be evaluated if it is valid.

All data associations that define as target the data input will be evaluated, and if any of the sources of the data association
is “unavailable,” then the InputSet is “unavailable” and the next InputSet is evaluated.

The first InputSet where all data inputs are “available” (by means of data associations) is used to start the execution of
the Activity. If no InputSet is “available,” then the execution will wait until this condition is met.

The time and frequency of when and how often this condition is evaluated is out of scope this specification.
Implementations will wait for the sources of data associations to become available and then re-evaluate the InputSets.

In the case of throw and catch Events, given their nature, the execution semantics for data is different.

When a throw Event is activated, all DataInputAssociations of the event are executed, filling the Data Inputs of
the Event. Finally, DataInputs are then copied to the elements thrown by the Event (Messages, Signals, etc).
Since there are no InputSets defined for Events, the execution will never wait.

When a catch Event is activated, Data Outputs of the event are filled with the element that triggered the Event. Then
all DataOutputAssociations of the Event are executed. There are no OutputSets defined for Events.

To allow invoking a Process from both a Call Activity and via Message Flow, the Start Event and End Event
support an additional case.

In the case of a Start Event, the Data Inputs of the enclosing process are available as targets to the
DataOutputAssociations of the Event. This way the Process Data Inputs can be filled using the elements that
triggered the Start Event.

In the case of a End Event, the Data Outputs of the enclosing process are available as sources to the
DataInputAssociations of the Event. This way the resulting elements of the End Event can use the Process
Data Outputs as sources.




Business Process Model and Notation, v2.0                                                                                  229
Once an InputSet becomes "available", all Data Associations whose target is any of the Data Inputs of the
InputSet are executed. These executions fill the Activity Data Inputs and the execution of the Activity can begin.
When an Activity finishes execution, all Data Associations whose sources are any of the Data Outputs of the
OutputSet are executed. These executions copy the values from the Data Outputs back to the container's context
(Data Object, Properties, etc).

Execution Semantics for DataAssociation

The execution of any Data Associations MUST follow these semantics:

      • If the Data Association specifies a "transformation" Expression, this expression is evaluated and the result is copied
        to the targetRef. This operation replaces completely the previous value of the targetRef element.

      • For each "assignment" element specified:
           • Evaluate the Assignment's "from" expression and obtain the *source value*
           • Evaluate the Assignment's "to" expression and obtain the *target element*. The *target element* can be any
             element in the context or a sub-element of it (e.g. a DataObject or a sub-element of it).
           • Copy the *source value* to the *target element*.

      • If no "transformation" Expression nor any "assignment" elements are defined in the Data Association:
           • Copy the Data Association "sourceRef" value into the "targetRef". Only one sourceRef element is allowed in
             this case.

10.3.3 Usage of Data in XPath Expressions

BPMN extensibility mechanism enables the usage of various languages for Expressions and queries. This section
describes how XPath is used in BPMN. It introduces a mechanism to access BPMN Data Objects, BPMN Properties,
and various instance attributes from XPath Expressions.

The accessiblity by the Expression language is defined based on the entities accessibility by the Activity that contains
the Expression. All elements accessible from the enclosing element of an XPath Expression MUST be made
available to the XPath processor.

BPMN Data Objects and BPMN Properties are defined using ItemDefinition. The XPath binding assumes that the
ItemDefinition is either an XSD complex type or an XSD element. If XSD element is used it MUST be manifested
as a node-set XPath variable with a single member node. If XSD complex type is used it MUST be manifested as a node-
set XPath variable with one member node containing the anonymous document element that contains the actual value of
the BPMN Data Object or Property.

Access to BPMN Data Objects

Table 10.65 introduces an XPath function used to access BPMN Data Objects. Argument processName names
Process and is of type string. Argument dataObjectName names Data Object and is of type string. It MUST be a
literal string.




230                                                                                Business Process Model and Notation, v2.0
 Table 10.65 – XPath Extension Function for Data Objects

 XPath Extension Function                Description/Usage

 Element getDataObject (‘pro-            This extension function returns value of submitted Data Object. Argument
 cessName’, ‘dataObjectName’)            processName is optional. If omitted, the process enclosing the Activity
                                         that contains the Expression is assumed. In order to access Data
                                         Objects defined in a parent process the processName MUST be used.
                                         Otherwise it MUST be omitted.

Because XPath 1.0 functions do not support returning faults, an empty node set is returned in the event of an error.

Access to BPMN Data Input and Data Output

Table 10.66 introduces XPath functions used to access BPMN Data Inputs and BPMN Data Outputs. Argument
dataInputName names a Data Input and is of type string. Argument dataOutput names a Data Output and is
of type string.


 Table 10.66 – XPath Extension Function for Data Inputs and Data Outputs

 XPath Extension Function                          Description/Usage

 Element getDataInput (‘dataInputName’)            This extension function returns the value of the submitted Data
                                                   Input.

 Element getDataOutput ('dataOutput-               This extension function returns the value of the submitted Data
 Name')                                            Output.

Access to BPMN Properties

Table 10.67 introduces XPath functions used to access BPMN Properties.

Argument processName names Process and is of type string. Argument propertyName names property and is of
type string. Argument activityName names Activity and is of type string. Argument eventName names Event and
is of type string. These strings MUST be literal strings. The XPath extension functions return value of the submitted
property.

Because XPath 1.0 functions do not support returning faults, an empty node set is returned in the event of an error.




Business Process Model and Notation, v2.0                                                                              231
 Table 10.67 – XPath Extension Functions for Properties

 XPath Extension Function                Description/Usage

 Element getProcessProperty              This extension function returns value of submitted Process property.
 (‘processName’, ‘propertyName’)         Argument processName is optional. If omitted, the Process enclosing the
                                         Activity that contains the Expression is assumed. In order to access
                                         Properties defined in a parent Process the processName MUST be
                                         used. Otherwise it MUST be omitted.

 Element getActivityProperty             This extension function returns value of submitted Activity property.
 (‘activityName’, ‘propertyName’)

 Element getEventProperty                This extension function returns value of submitted Event property.
 ‘eventName’, ‘propertyName’)

For BPMN Instance Attributes

Table 10.68 introduces XPath functions used to access BPMN instance Attributes.

Argument processName names Process and is of type string. Argument attributeName names instance
attribute and is of type string. Argument activityName names Activity and is of type string. These strings
MUST be literal strings.

These functions return value of the submitted instance Activity. Because XPath 1.0 functions do not support returning
faults, an empty node set is returned in the event of an error.


 Table 10.68 – XPath extension functions for instance attributes

 XPath Extension Function                    Description/Usage

 Element getProcessInstanceAt-               This extension function returns value of submitted Process instance
 tribute (‘processName’,‘attributeN-         attribute. Argument processName is optional. If omitted, the Pro-
 ame’)                                       cess enclosing the Activity that contains the Expression is
                                             assumed. In order to access instance Attributes of a parent Process
                                             the processName MUST be used. Otherwise it MUST be omitted.

 Element getChoreographyInstance-            This extension function returns value of submitted Choreography
 Attribute (‘attributeName’)                 instance attribute.

 Element getActivityInstanceAt-              This extension function returns value of submitted Activity instance
 tribute (‘activityName’, ‘attributeN-       attribute. User Task and loop are examples of Activities.
 ame’)




232                                                                           Business Process Model and Notation, v2.0
10.3.4 XML Schema for Data


 Table 10.69 – Assignment XML schema

 <xsd:element name="assignment" type="tAssignment" />
 <xsd:complexType name="tAssignment">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:sequence>
                 <xsd:element name="from" type="tExpression" minOccurs="1" maxOccurs="1"/>
                 <xsd:element name="to" type="tExpression" minOccurs="1" maxOccurs="1"/>
             </xsd:sequence>
     </xsd:extension>
 </xsd:complexContent>
 </xsd:complexType>


 Table 10.70 – DataAssociation XML schema

 <xsd:element name="dataAssociation" type="tDataAssociation" />
 <xsd:complexType name="tDataAssociation" abstract="true">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:sequence>
                 <xsd:element name="sourceRef" type="xsd:IDREF" minOccurs="0" maxOccurs="unbounded"/
                         >
                 <xsd:element name="targetRef" type="xsd:IDREF" minOccurs="1" maxOccurs="1"/>
                 <xsd:element name="transformation" type="tFormalExpression" minOccurs="0" maxOc-
                         curs="1"/>
                 <xsd:element ref="assignment" minOccurs="0" maxOccurs="unbounded"/>
             </xsd:sequence>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.71 – DataInput XML schema

 <xsd:element name="dataInput" type="tDataInput" />
 <xsd:complexType name="tDataInput">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:attribute name="name" type="xsd:string" use="optional" />
             <xsd:attribute name="itemSubjectRef" type="xsd:QName" />
             <xsd:attribute name="isCollection" type="xsd:boolean" default="false"/>
             <xsd:attribute name="dataState" type="xsd:IDREF"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>



Business Process Model and Notation, v2.0                                                         233
 Table 10.72 – DataInputAssociation XML schema

 <xsd:element name="dataInputAssociation" type="tDataInputAssociation" />
 <xsd:complexType name="tDataInputAssociation">
     <xsd:complexContent>
         <xsd:extension base="tDataAssociation"/>
     </xsd:complexContent>
 </xsd:complexType>



 Table 10.73 – DataObject XML schema

 <xsd:element name="dataObject" type="tDataObject" />
 <xsd:complexType name="tDataObject">
     <xsd:complexContent>
         <xsd:extension base="tFlowElement">
             <xsd:sequence>
                 <xsd:element ref="dataState" minOccurs="0" maxOccurs="1"/>
             </xsd:sequence>
             <xsd:attribute name="itemSubjectRef" type="xsd:QName"/>
             <xsd:attribute name="isCollection" type="xsd:boolean"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.74 – DataState XML schema

 <xsd:element name="dataState" type="tDataState" />
 <xsd:complexType name="tDataState">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:attribute name="name" type="xsd:string"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




234                                                                   Business Process Model and Notation, v2.0
 Table 10.75 – DataOutput XML schema

 <xsd:element name="dataOutput" type="tDataOutput" />
 <xsd:complexType name="tDataOutput">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:attribute name="name" type="xsd:string" use="optional"/>
             <xsd:attribute name="itemSubjectRef" type="xsd:QName"/>
             <xsd:attribute name="isCollection" type="xsd:boolean" default="false"/>
             <xsd:attribute name="dataState" type="xsd:IDREF"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>



 Table 10.76 – DataOutputAssociation XML schema

 <xsd:element name="dataOutputAssociation" type="tDataOutputAssociation" />
 <xsd:complexType name="tDataOutputAssociation">
     <xsd:complexContent>
         <xsd:extension base="tDataAssociation"/>
     </xsd:complexContent>
 </xsd:complexType>


 Table 10.77 – InputOutputSpecification XML schema

 <xsd:element name="ioSpecification" type="tInputOutputSpecification" />
 <xsd:complexType name="tInputOutputSpecification">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:sequence>
                 <xsd:element ref="dataInput" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="dataOutput" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="inputSet" minOccurs="1" maxOccurs="unbounded"/>
                 <xsd:element ref="outputSet" minOccurs="1" maxOccurs="unbounded"/>
             </xsd:sequence>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




Business Process Model and Notation, v2.0                                              235
 Table 10.78 – InputSet XML schema

 <xsd:element name="inputSet" type="tInputSet" />
 <xsd:complexType name="tInputSet">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:sequence>
                 <xsd:element name="dataInputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="optionalInputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="whileExecutingInputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="outputSetRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
             </xsd:sequence>
             <xsd:attribute name="name" type="xsd:string" />
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>



 Table 10.79 – OutputSet XML schema

 <xsd:element name="outputSet" type="tOutputSet" />
 <xsd:complexType name="tOutputSet">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:sequence>
                 <xsd:element name="dataOutputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="optionalOutputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="whileExecutingOutputRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
                 <xsd:element name="inputSetRefs" type="xsd:IDREF" minOccurs="0" maxOc-
                          curs="unbounded"/>
             </xsd:sequence>
             <xsd:attribute name="name" type="xsd:string"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>




236                                                                Business Process Model and Notation, v2.0
 Table 10.80 – Property XML schema

 <xsd:element name="property" type="tProperty" />
 <xsd:complexType name="tProperty">
     <xsd:complexContent>
         <xsd:extension base="tBaseElement">
             <xsd:attribute name="name" type="xsd:string"/>
             <xsd:attribute name="itemSubjectRef" type="xsd:QName"/>
         </xsd:extension>
     </xsd:complexContent>
 </xsd:complexType>



10.4 Events
An Event is something that “happens” during the course of a Process. These Events affect the flow of the Process
and usually have a cause or an impact and in general require or allow for a reaction. The term “event” is general enough
to cover many things in a Process. The start of an Activity, the end of an Activity, the change of state of a document,
a Message that arrives, etc., all could be considered Events.

Events allow for the description of “event-driven” Processes. In these Processes, There are three main types of
Events:

    • Start Events (see page 242), which indicate where a Process will start.

    • End Events (see page 250), which indicate where a path of a Process will end.

    • Intermediate Events (see page 254), which indicate where something happens somewhere between the start and end
      of a Process.


Within these three types, Events come in two flavors:

    • Events that catch a trigger. All Start Events and some Intermediate Events are catching Events.

    • Events that throw a Result. All End Events and some Intermediate Events are throwing Events that MAY
      eventually be caught by another Event. Typically the trigger carries information out of the scope where the throw
      Event occurred into the scope of the catching Events. The throwing of a trigger MAY be either implicit as defined by
      this standard or an extension to it or explicit by a throw Event.




Business Process Model and Notation, v2.0                                                                             237
Figure 10.69 - The Event Class Diagram

10.4.1 Concepts

Depending on the type of the Event there are different strategies to forward the trigger to catching Events: publication,
direct resolution, propagation, cancellations, and compensations.

With publication a trigger MAY be received by any catching Events in any scope of the system where the trigger is
published. Events for which publication is used are grouped to Conversations. Published Events MAY participate in
several Conversations. Messages are triggers, which are generated outside of the Pool they are published in. They
typically describe B2B communicationbetween different Processes in different Pools. When Messages need to reach
a specific Process instance, correlation is used to identify the particular instance. Signals are triggers generated in the
Pool they are published. They are typically used for broadcast communication within and across Processes, across
Pools, and between Process diagrams.

Timer and Conditional triggers are implicitly thrown. When they are activated they wait for a time based or status
based condition respectively to trigger the catch Event.


238                                                                              Business Process Model and Notation, v2.0
A trigger that is propagated is forwarded from the location where the Event has been thrown to the innermost enclosing
scope instance (e.g., Process level) which has an attached Event being able to catch the trigger. Error triggers are
critical and suspend execution at the location of throwing. Escalations are non critical and execution continues at the
location of throwing. If no catching Event is found for an error or escalation trigger, this trigger is unresolved.

Termination, compensation, and cancellation are directed towards a Process or a specific Activity instance.
Termination indicates that all Activities in the Process or Activity should be immediately ended. This includes all
instances of multi-instances. It is ended without compensation or Event handling.

Compensation of a successfully completed Activity triggers its compensation handler. The compensation handler is
either user defined or implicit. The implicit compensation handler of a Sub Process calls all compensation handlers of
its enclosed Activities in the reverse order of Sequence Flow dependencies. If compensation is invoked for an
Activity that has not yet completed, or has not completed successfully, nothing happens (in particular, no error is raised).

Cancellation will terminate all running Activities and compensate all successfully completed Activities in the Sub-
Process it is applied to. If the Sub-Process is a Transaction, the Transaction is rolled back.

Data Modeling and Events

Some Events (like the Message, Escalation, Error, Signal, and Multiple Event) have the capability to carry data.
Data Association is used to push data from a Catch Event to a data element. For such Events, the following
constraints apply:
         If the Event is associated with multiple EventDefinitions, there MUST be one Data Input (in the case of
        throw Events) or one Data Output (in the case of catch Events) for each EventDefinition. The order of the
        EventDefinitions and the order of the Data Inputs/Outputs determine which Data Input/Output
        corresponds with which EventDefinition.
         For each EventDefinition and Data Input/Output pair, if the Data Input/Output is present, it MUST have
        an ItemDefinition equivalent to the one defined by the Message, Escalation, Error, or Signal on the
        associated EventDefinition. In the case of a throw Event, if the Data Input is not present, the Message,
        Escalation, Error, or Signal will not be populated with data. In the case of a catch Event, if the Data Output is
        not present, the payload within the Message, Escalation, Error, or Signal will not flow out of the Event and
        into the Process.

The execution behavior is then as follows:
        For throw Events: When the Event is activated, the data in the Data Input is automatically assigned to the
        Message, Escalation, Error, or Signal referenced by the corresponding EventDefinition.
        For catch Events: When the trigger of the Event occurs (for example, the Message is received), the data is
        automatically assigned to the Data Output that corresponds to the EventDefinition that described that trigger.

Common Event attributes

The Event element inherits the attributes and model associations of FlowElement (see Table 8.44). Table 10.81
presents the additional model associations of the Event element:




Business Process Model and Notation, v2.0                                                                              239
 Table 10.81 – Event model associations

 Attribute Name                              Description/Usage

 properties: Property [0..*]                 Modeler-defined properties MAY be added to an Event. These
                                             properties are contained within the Event.

Common Catch Event attributes

The CatchEvent element inherits the attributes and model associations of Event element (see Table 10.81). Table
10.82 presents the additional attributes and model associations of the CatchEvent element:

Table 10.82 – CatchEvent attributes and model associations

 Attribute Name                              Description/Usage

 eventDefinitionRefs: EventDefinition        References the reusable EventDefinitions that are triggers
 [0..*]                                      expected for a catch Event. Reusable EventDefinitions are
                                             defined as top-level elements. These EventDefinitions can be
                                             shared by different catch and throw Events.
                                                 • If there is no EventDefinition defined, then this is
                                                   considered a catch None Event and the Event will not have
                                                   an internal marker (see Figure 10.91).
                                                 • If there is more than one EventDefinition defined, this is
                                                   considered a Catch Multiple Event and the Event will have
                                                   the pentagon internal marker (see Figure 10.90).
                                             This is an ordered set.

 eventDefinitions: EventDefinition [0..*]    Defines the event EventDefinitions that are triggers expected
                                             for a catch Event. These EventDefinitions are only valid inside
                                             the current Event.
                                                 • If there is no EventDefinition defined, then this is
                                                   considered a catch None Event and the Event will not have
                                                   an internal marker (see Figure 10.91).
                                                 • If there is more than one EventDefinition defined, this is
                                                   considered a catch Multiple Event and the Event will have
                                                   the pentagon internal marker (see Figure 10.90).
                                             This is an ordered set.

 dataOutputAssociations: Data                The Data Associations of the catch Event.
 OutputAssociation [0..*]                    The dataOutputAssociation of a catch Event is used to assign
                                             data from the Event to a data element that is in the scope of the
                                             Event.
                                             For a catch Multiple Event, multiple Data Associations might be
                                             REQUIRED, depending on the individual triggers of the Event.



240                                                                        Business Process Model and Notation, v2.0
Table 10.82 – CatchEvent attributes and model associations

 dataOutputs: DataOutput [0..*]              The Data Outputs for the catch Event. This is an ordered set.

 outputSet: OutputSet [0..1]                 The OutputSet for the catch Event

 parallelMultiple: boolean = false           This attribute is only relevant when the catch Event has more than
                                             EventDefinition (Multiple).
                                             If this value is true, then all of the types of triggers that are listed in
                                             the catch Event MUST be triggered before the Process is
                                             instantiated.

Common Throw Event Attributes

The ThrowEvent element inherits the attributes and model associations of Event element (see Table 10.81). Table
10.83 presents the additional attributes and model associations of the ThrowEvent element.

Table 10.83 – ThrowEvent attributes and model associations

 Attribute Name                             Description/Usage

 eventDefinitionRefs: EventDefinition       References the reusable EventDefinitions that are results
 [0..*]                                     expected for a throw Event. Reusable EventDefinitions are
                                            defined as top-level elements. These EventDefinitions can be
                                            shared by different catch and throw Events.
                                                • If there is no EventDefinition defined, then this is
                                                  considered a throw None Event and the Event will not have an
                                                  internal marker (see Figure 10.91).
                                                • If there is more than one EventDefinition defined, this is
                                                  considered a throw Multiple Event and the Event will have the
                                                  pentagon internal marker (see Figure 10.90).
                                            This is an ordered set.

 eventDefinitions: EventDefinition [0..*]   Defines the event EventDefinitions that are results expected for
                                            a throw Event. These EventDefinitions are only valid inside the
                                            current Event.
                                                • If there is no EventDefinition defined, this is considered a
                                                  throw None Event and the Event will not have an Internal
                                                  marker (see Figure 10.91).
                                                • If there is more than one EventDefinition defined, this is
                                                  considered a throw Multiple Event and the Event will have the
                                                  pentagon internal marker (see Figure 10.90).
                                            This is an ordered set.




Business Process Model and Notation, v2.0                                                                             241
Table 10.83 – ThrowEvent attributes and model associations

 dataInputAssociations: DataInput             The Data Associations of the throw Event.
 Association [0..*]                           The dataInputAssociation of a throw Event is responsible for
                                              the assignment of a data element that is in scope of the Event to the
                                              Event data.
                                              For a throw Multiple Event, multiple Data Associations might be
                                              REQUIRED, depending on the individual results of the Event.

 dataInputs: DataInput [0..*]                 The Data Inputs for the throw Event.This is an ordered set.

 inputSet: InputSet [0..1]                    The InputSet for the throw Event

Implicit Throw Event

A sub-type of throw Event is the ImplicitThrowEvent. This is a non-graphical Event that this used for Multi-
Instance Activities (see page 195). The ImplicitThrowEvent element inherits the attributes and model
associations of ThrowEvent (see Table 10.84), but does not have any additional attributes or model associations.

10.4.2 Start Event

As the name implies, the Start Event indicates where a particular Process will start. In terms of Sequence Flows, the
Start Event starts the flow of the Process, and thus, will not have any incoming Sequence Flows—no Sequence
Flow can connect to a Start Event.

The Start Event shares the same basic shape of the Intermediate Event and End Event, a circle with an open center
so that markers can be placed within the circle to indicate variations of the Event.
         A Start Event is a circle that MUST be drawn with a single thin line (see Figure 10.70).
            The use of text, color, size, and lines for a Start Event MUST follow the rules defined in Section “Use of Text,
            Color, Size, and Lines in a Diagram” on page 41 with the exception that:
                  The thickness of the line MUST remain thin so that the Start Event can be distinguished from the
                 Intermediate and End Events.




Figure 10.70 - Start Event

Throughout this document, we discuss how Sequence Flows are used within a Process. To facilitate this discussion,
we employ the concept of a token that will traverse the Sequence Flows and pass through the elements in the Process.
A token is a theoretical concept that is used as an aid to define the behavior of a Process that is being performed. The
behavior of Process elements can be defined by describing how they interact with a token as it “traverses” the structure
of the Process.

Note – A token does not traverse a Message Flow since it is a Message that is passed down a Message Flow (as the
name implies).


242                                                                              Business Process Model and Notation, v2.0
Semantics of the Start Event include:
        A Start Event is OPTIONAL: a Process level—a top-level Process, a Sub-Process (embedded), or a Global
        Process (called Process)—MAY (is NOT REQUIRED to) have a Start Event.

Note – A Process MAY have more than one Process level (i.e., it can include Expanded Sub-Processes or Call
Activities that call other Processes). The use of Start and End Events is independent for each level of the Diagram.

        If a Process is complex and/or the starting conditions are not obvious, then it is RECOMMENDED that a Start
        Event be used.
         If a Start Event is not used, then the implicit Start Event for the Process SHALL NOT have a trigger.
         If there is an End Event, then there MUST be at least one Start Event.
        All Flow Objects that do not have an incoming Sequence Flow (i.e., are not a target of a Sequence Flow)
        SHALL be instantiated when the Process is instantiated.
             Exceptions to this are Activities that are defined as being Compensation Activities (it has the
             Compensation marker). Compensation Activities are not considered a part of the normal flow and MUST
             NOT be instantiated when the Process is instantiated. See page 308 for more information on Compensation
             Activities.
             An exception to this is a catching Link Intermediate Event, which is not allowed to have incoming
             Sequence Flows. See page 272 for more information on Link Intermediate Events.
             An exception to this is an Event Sub-Process, which is not allowed to have incoming Sequence Flows
             and will only be instantiated when its Start Event is triggered. See page 178 for more information on Event
             Sub-Processes.
         There MAY be multiple Start Events for a given Process level.
             Each Start Event is an independent Event. That is, a Process instance SHALL be generated when the Start
             Event is triggered.

If the Process is used as a global Process (a callable Process that can be invoke from Call Activities of other
Processes) and there are multiple None Start Events, then when flow is transferred from the parent Process to the
global Process, only one of the global Process’s Start Events will be triggered. The targetRef attribute of a
Sequence Flow incoming to the Call Activity object can be extended to identify the appropriate Start Event.

Note – The behavior of Process can be harder to understand if there are multiple Start Events. It is RECOMMENDED
that this feature be used sparingly and that the modeler be aware that other readers of the Diagram could have difficulty
understanding the intent of the Diagram.

When the trigger for a Start Event occurs, a new Process will be instantiated and a token will be generated for each
outgoing Sequence Flow from that Event.

Start Event Triggers

Start Events can be used for three types of Processes:

    • Top-level Processes

    • Sub-Processes (embedded)

    • Global Process (called)


Business Process Model and Notation, v2.0                                                                              243
      • Event Sub-Processes

The next three (3) sections describe the types of Start Events that can be used for each of these three types of
Processes.

Start Events for Top-level Processes

There are many ways that top-level Processes can be started (instantiated). The trigger for a Start Event is designed
to show the general mechanisms that will instantiate that particular Process. There are seven (7) types of Start Events
for top-level Processes in BPMN (see Table 10.84): None, Message, Timer, Conditional, Signal, Multiple, and
Parallel.

A top-level Process that has at least one (1) None Start Event MAY be called by a Call Activity in another Process.
The None Start Event is used for invoking the Process from the Call Activity. All other types of Start Events are
only applicable when the Process is used as a top-level Process.

Table 10.84 – Top-Level Process Start Event Types

 Trigger                Description                                                                      Marker

 None                   The None Start Event does not have a defined trigger. There is no
                        specific EventDefinition subclass (see page 265) for None Start
                        Events. If the Start Event has no associated EventDefiniton, then the
                        Event MUST be displayed without a marker (see the figure on the right).

 Message                A Message arrives from a Participant and triggers the start of the
                        Process. See page 93 for more details on Messages.
                        If there is only one (1) EventDefinition associated with the Start
                        Event and that EventDefinition is of the subclass MessageEvent-
                        Definition, then the Event is a Message Start Event and MUST be
                        displayed with an envelope marker (see the figure to the right).
                        The actual Participant from which the Message is received can be identi-
                        fied by connecting the Event to a Participant using a Message Flow
                        within the definitional Collaboration of the Process – see Table 10.1.

 Timer                  A specific time-date or a specific cycle (e.g., every Monday at 9am) can
                        be set that will trigger the start of the Process.
                        If there is only one (1) EventDefinition associated with the Start
                        Event and that EventDefinition is of the subclass TimerEventDef-
                        inition, then the Event is a Timer Start Event and MUST be displayed
                        with a clock marker (see the figure to the right).




244                                                                            Business Process Model and Notation, v2.0
Table 10.84 – Top-Level Process Start Event Types

 Conditional           This type of event is triggered when a condition such as “S&P 500
                       changes by more than 10% since opening”, or “Temperature above 300C”
                       become true. The condition Expression for the Event MUST become
                       false and then true before the Event can be triggered again.
                       The Condition Expression of a Conditional Start Event MUST NOT
                       refer to the data context or instance attribute of the Process (as the Proc-
                       ess instance has not yet been created). Instead, it MAY refer to static
                       Process attributes and states of entities in the environment. The specifi-
                       cation of mechanisms to access such states is out of scope of the stan-
                       dard.
                       If there is only one (1) EventDefinition associated with the Start
                       Event and that EventDefinition is of the subclass ConditionalEv-
                       entDefinition, then the Event is a Conditional Start Event and
                       MUST be displayed with a lined paper marker (see the figure to the right).

 Signal                A Signal arrives that has been broadcast from another Process and
                       triggers the start of the Process. Note that the Signal is not a Message,
                       which has a specific target for the Message. Multiple Processes can
                       have Start Events that are triggered from the same broadcasted Signal.
                       If there is only one (1) EventDefinition associated with the Start
                       Event and that EventDefinition is of the subclass SignalEvent-
                       Definition, then the Event is a Signal Start Event and MUST be dis-
                       played with a triangle marker (see the figure to the right).

 Multiple              This means that there are multiple ways of triggering the Process. Only
                       one of them is REQUIRED. There is no specific EventDefinition sub-
                       class for Multiple Start Events. If the Start Event has more than one
                       associated EventDefiniton, then the Event MUST be displayed with
                       the Multiple Event marker (a pentagon—see the upper figure to the
                       right).

 Parallel              This means that there are multiple triggers REQUIRED before the Proc-
 Multiple              ess can be instantiated. All of the types of triggers that are listed in the
                       Start Event MUST be triggered before the Process is instantiated. There
                       is no specific EventDefinition subclass for Parallel
                       Multiple Start Events. If the Start Event has more than one associated
                       EventDefiniton and the parallelMultiple attribute of the Start
                       Event is true, then the Event MUST be displayed with the Parallel
                       Multiple Event marker (an open plus sign—see the figure to the right).

Start Events for Sub-Processes

There is only one (1) type of Start Event for Sub-Processes in BPMN (see Figure 10.82): None.




Business Process Model and Notation, v2.0                                                             245
 Table 10.85 – Sub-Process Start Event Types

 Trigger            Description                                                                    Marker

 None               The None Start Event is used for all Sub-Processes, either embedded
                    or called (reusable). Other types of triggers are not used for a
                    Sub-Process, since the flow of the Process (a token) from the parent
                    Process is the trigger of the Sub-Process. If the Sub-Process is called
                    (reusable) and has multiple Start Events, some of the other Start Events
                    MAY have triggers, but these Start Events would not be used in the con-
                    text of a Sub-Process. When the other Start Events are triggered, they
                    would instantiate top-level Processes.




Start Events for Event Sub-Processes

A Start Event can also initiate an inline Event Sub-Process (see page 178). In that case, the same Event types as for
boundary Events are allowed (see Table 10.86), namely: Message, Timer, Escalation, Error, Compensation,
Conditional, Signal, Multiple, and Parallel.
        An Event Sub-Process MUST have a single Start Event.

Table 10.86 – Event Sub-Process Start Event Types

 Trigger         Description                                                                           Marker

 Message         If there is only one (1) EventDefinition associated with the Start Event and          Interrupting
                 that EventDefinition is of the subclass MessageEventDefinition, then
                 the Event is a Message Start Event and uses an envelope marker (see the fig-
                 ures to the right).
                 For a Message Event Sub-Process that interrupts its containing Process, the
                 boundary of the Event is solid (see the upper figure to the right).                   Non- Inter-
                 For a Message Event Sub-Process that does not interrupt its containing                 rupting
                 Process, the boundary of the Event is dashed (see the lower figure on the right).
                 The actual Participant from which the Message is received can be identified by
                 connecting the Event to a Participant using a Message Flow within the
                 definitional Collaboration of the Process – see Table 10.1.




246                                                                          Business Process Model and Notation, v2.0
Table 10.86 – Event Sub-Process Start Event Types

 Timer           If there is only one (1) EventDefinition associated with the Start Event and            Interrupting
                 that EventDefinition is of the subclass TimerEventDefinition, then the
                 Event is a Timer Start Event and uses a clock marker (see the figures to the
                 right).
                 For a Timer Event Sub-Process that interrupts its containing Process, the
                 boundary of the Event is solid (see the upper figure to the right).
                 For a Timer Event Sub-Process that does not interrupt its containing Process,           Non- Inter-
                 the boundary of the Event is dashed (see the lower figure on the right).                 rupting




 Escalation      Escalation Event Sub-Processes implement measures to expedite the comple-               Interrupting
                 tion of a business Activity, should it not satisfy a constraint specified on its exe-
                 cution (such as a time-based deadline).
                 The Escalation Start Event is only allowed for triggering an in-line Event Sub-
                 Process.
                 If there is only one (1) EventDefinition associated with the Start Event and            Non- Inter-
                 that EventDefinition is of the subclass EscalationEventDefinition,                       rupting
                 then the Event is an Escalation Start Event and uses an arrowhead marker
                 (see the figures to the right).
                 For an Escalation Event Sub-Process that interrupts its containing Process,
                 the boundary of the Event is solid (see the upper figure to the right).
                 For an Escalation Event Sub-Process that does not interrupt its containing
                 Process, the boundary of the Event is dashed (see the lower figure on the right).

 Error           The Error Start Event is only allowed for triggering an in-line Event Sub-              Interrupting
                 Process.
                 If there is only one (1) EventDefinition associated with the Start Event and
                 that EventDefinition is of the subclass ErrorEventDefinition, then the
                 Event is an Error Start Event and uses a lightning marker (see the figures to the
                 right).
                 Given the nature of Errors, an Event Sub-Process with an Error trigger will
                 always interrupt its containing Process.




Business Process Model and Notation, v2.0                                                                         247
Table 10.86 – Event Sub-Process Start Event Types

 Compensa-      The Compensation Start Event is only allowed for triggering an in-line
 tion           Compensation Event Sub-Process (see “Compensation Handler” on page
                308). This type of Event is triggered when compensation occurs.
                If there is only one (1) EventDefinition associated with the Start Event and
                that EventDefinition is of the subclass CompensationEventDefinition,
                then the Event is a Compensation Start Event and uses a double triangle
                marker (see the figure to the right). This Event does not interrupt the Process
                since the Process has to be completed before this Event can be triggered.

 Conditional    If there is only one (1) EventDefinition associated with the Start Event and        Interrupting
                that EventDefinition is of the subclass ConditionalEventDefinition,
                then the Event is a Conditional Start Event and uses an lined page marker
                (see the figures to the right).
                For a Conditional Event Sub-Process that interrupts its containing Process,
                then the boundary of the Event is solid (see the upper figure to the right).        Non- Inter-
                For a Conditional Event Sub-Process that does not interrupt its containing           rupting
                Process, the boundary of the Event is dashed (see the lower figure on the right).




 Signal         If there is only one (1) EventDefinition associated with the Start Event and        Interrupting
                that EventDefinition is of the subclass SignalEventDefinition, then
                the Event is a Signal Start Event and uses an triangle marker (see the figures
                to the right).
                For a Signal Event Sub-Process that interrupts its containing Process, then the
                boundary of the Event is solid (see the upper figure to the right).                 Non- Inter-
                For a Signal Event Sub-Process that does not interrupt its containing Process,       rupting
                the boundary of the Event is dashed (see the lower figure on the right).




248                                                                       Business Process Model and Notation, v2.0
Table 10.86 – Event Sub-Process Start Event Types

 Multiple        A Multiple Event indicates that that there are multiple ways of triggering the        Interrupting
                 Event Sub-Process. Only one of them is REQUIRED to actually start the Event
                 Sub-Process. There is no specific EventDefinition subclass (see page 265)
                 for Multiple Start Events. If the Start Event has more than one associated
                 EventDefiniton, then the Event MUST be displayed with the Multiple Event
                 marker (a pentagon—see the figures on the right).                                     Non- Inter-
                 For a Multiple Event Sub-Process that interrupts its containing Process, the           rupting
                 boundary of the Event is solid (see the upper figure to the right).
                 For a Multiple Event Sub-Process that does not interrupt its containing Proc-
                 ess, the boundary of the Event is dashed (see the lower figure on the right).


 Parallel        A Parallel Multiple Event indicates that that there are multiple ways of triggering   Interrupting
 Multiple        the Event Sub-Process. All of them are REQUIRED to actually start the Event
                 Sub-Process. There is no specific EventDefinition subclass (see page 265)
                 for Parallel Multiple Start Events. If the Start Event has more than one associ-
                 ated EventDefiniton and the parallelMultiple attribute of the Start
                 Event is true, then the Event MUST be displayed with the Parallel Multiple            Non- Inter-
                 Event marker (an open plus sign—see the figures to the right).                         rupting
                 For a Parallel Multiple Event Sub-Process that interrupts its containing Proc-
                 ess, the boundary of the Event is solid (see the upper figure to the right).
                 For a Parallel Multiple Event Sub-Process that does not interrupt its containing
                 Process, the boundary of the Event is dashed (see the lower figure on the right).

Attributes for Start Events

For Start Events, the following additional attribute exists:

The Start Event element inherits the attributes and model associations of CatchEvent (see Table 10.82). Table 10.87
presents the additional attributes of the Start Event element:


 Table 10.87 – Start Event attributes

 Attribute Name               Description/Usage

 isInterrupting: boolean      This attribute only applies to Start Events of Event Sub-Processes; it is ignored for
 = true                       other Start Events. This attribute denotes whether the Sub-Process encompassing
                              the Event Sub-Process should be cancelled or not, If the encompassing Sub-
                              Process is not cancelled, multiple instances of the Event Sub-Process can run
                              concurrently. This attribute cannot be applied to Error Events (where it’s always
                              true), or Compensation Events (where it doesn’t apply).




Business Process Model and Notation, v2.0                                                                        249
Sequence Flow Connections

See Section “Sequence Flow Connections Rules” on page 41 for the entire set of objects and how they MAY be a source
or target of a Sequence Flow.
        A Start Event MUST NOT be a target for Sequence Flows; it MUST NOT have incoming Sequence Flows.
             An exception to this is when a Start Event is used in an Expanded Sub-Process and is attached to the
            boundary of that Sub-Process. In this case, a Sequence Flow from the higher-level Process MAY connect
            to that Start Event in lieu of connecting to the actual boundary of the Sub-Process.
        A Start Event MUST be a source for a Sequence Flow.
        Multiple Sequence Flows MAY originate from a Start Event. For each Sequence Flow that has the Start
        Event as a source, a new parallel path SHALL be generated.
             The conditionExpression attribute for all outgoing Sequence Flows MUST be set to None.
            When a Start Event is not used, then all Flow Objects that do not have an incoming Sequence Flow SHALL
            be the start of a separate parallel path.
             Each path will have a separate unique token that will traverse the Sequence Flow.

Message Flow Connections

Note – All Message Flows MUST connect two separate Pools. They MAY connect to the Pool boundary or to Flow
Objects within the Pool boundary. They MUST NOT connect two objects within the same Pool.

See Section “Message Flow Connection Rules” on page 43 for the entire set of objects and how they MAY be a source or
targets of a Message Flow.
        A Start Event MAY be the target for a Message Flow; it can have zero (0) or more incoming Message Flows.
        Each Message Flow targeting a Start Event represents an instantiation mechanism (a trigger) for the Process.
        Only one of the triggers is REQUIRED to start a new Process.
        A Start Event MUST NOT be a source for a Message Flow; it MUST NOT have outgoing Message Flows.


10.4.3 End Event

As the name implies, the End Event indicates where a Process will end. In terms of Sequence Flows, the End
Event ends the flow of the Process, and thus, will not have any outgoing Sequence Flows—no Sequence Flow can
connect from an End Event.

The End Event shares the same basic shape of the Start Event and Intermediate Event, a circle with an open center
so that markers can be placed within the circle to indicate variations of the Event.
        An End Event is a circle that MUST be drawn with a single thick line (see Figure 10.71).
        The use of text, color, size, and lines for an End Event MUST follow the rules defined in Section “Use of Text,
        Color, Size, and Lines in a Diagram” on page 41 with the exception that:

The thickness of the line MUST remain thick so that the End Event can be distinguished from the Intermediate and
Start Events.




250                                                                             Business Process Model and Notation, v2.0
Figure 10.71 - End Event

To continue discussing how flow proceeds throughout the Process, an End Event consumes a token that had been
generated from a Start Event within the same level of Process. If parallel Sequence Flows targets the End Event,
then the tokens will be consumed as they arrive. All the tokens that were generated within the Process MUST be
consumed by an End Event before the Process has been completed. In other circumstances, if the Process is a Sub-
Process, it can be stopped prior to normal completion through interrupting Intermediate Events (See Section 10.2.2,
“exception flow,” on page 280 for more details). In this situation the tokens will be consumed by an Intermediate Event
attached to the boundary of the Sub-Process.

Semantics of the End Event include:
         There MAY be multiple End Events within a single level of a Process.
        An End Event is OPTIONAL: a given Process level—a Process or an expanded Sub-Process—MAY (is
        NOT REQUIRED to) have this shape:
              If an End Event is not used, then the implicit End Event for the Process SHALL NOT have a Result.
             If there is a Start Event, then there MUST be at least one End Event.
            If the End Event is not used, then all Flow Objects that do not have any outgoing Sequence Flow (i.e., are
            not a source of a Sequence Flow) mark the end of a path in the Process. However, the Process MUST
            NOT end until all parallel paths have completed.

Note – A Process MAY have more than one Process level (i.e., it can include Expanded Sub-Processes or a Call
Activity that call other Processes). The use of Start and End Events is independent for each level of the Diagram.

For Processes without an End Event, a token entering a path-ending Flow Object will be consumed when the
processing performed by the object is completed (i.e., when the path has completed), as if the token had then gone on to
reach an End Event. When all tokens for a given instance of the Process are consumed, then the Process will reach
a state of being completed.

End Event Results

There are nine (9) types of End Events in BPMN: None, Message, Escalation, Error, Cancel, Compensation,
Signal, Terminate, and Multiple. These types define the consequence of reaching an End Event. This will be referred
to as the End Event Result.




Business Process Model and Notation, v2.0                                                                            251
Table 10.88 - End Event Types

 Trigger              Description                                                                  Marker

 None                 The None End Event does not have a defined result.
                      There is no specific EventDefinition subclass (see page 265) for
                      None End Events. If the End Event has no associated EventDefini-
                      ton, then the Event will be displayed without a marker (see the figure on
                      the right).

 Message              This type of End indicates that a Message is sent to a Participant at the
                      conclusion of the Process. See page 93 for more details on Messages.
                      The actual Participant from which the Message is received can be identi-
                      fied by connecting the Event to a Participant using a Message Flow
                      within the definitional Collaboration of the Process – see Table 10.1.

 Error                This type of End indicates that a named Error should be generated. All
                      currently active threads in the particular Sub-Process are terminated as a
                      result. The Error will be caught by a Catch Error Intermediate Event with
                      the same errorCode or no errorCode which is on the boundary of the
                      nearest enclosing parent Activity (hierarchically). The behavior of the
                      Process is unspecified if no Activity in the hierarchy has such an Error
                      Intermediate Event. The system executing the process can define addi-
                      tional Error handling in this case, a common one being termination of the
                      Process instance.

 Escalation           This type of End indicates that an Escalation should be triggered. Other
                      active threads are not affected by this and continue to be executed. The
                      Escalation will be caught by a Catch Escalation Intermediate Event with
                      the same escalationCode or no escalationCode which is on the
                      boundary of the nearest enclosing parent Activity (hierarchically). The
                      behavior of the Process is unspecified if no Activity in the hierarchy has
                      such an Escalation Intermediate Event.

 Cancel               This type of End is used within a Transaction Sub-Process. It will indi-
                      cate that the Transaction should be cancelled and will trigger a Cancel
                      Intermediate Event attached to the Sub-Process boundary. In addition,
                      it will indicate that a TransactionProtocol Cancel Message should
                      be sent to any Entities involved in the Transaction.




252                                                                       Business Process Model and Notation, v2.0
Table 10.88 - End Event Types

 Compensation          This type of End indicates that compensation is necessary. If an Activity
                       is identified, and it was successfully completed, then that Activity will be
                       compensated. The Activity MUST be visible from the Compensation
                       End Event, i.e., one of the following MUST be true:
                            • The Compensation End Event is contained in normal flow at the
                              same level of Sub-Process.
                            • The Compensation End Event is contained in a Compensation
                              Event Sub-Process which is contained in the Sub-Process
                              containing the Activity.
                            • If no Activity is identified, all successfully completed Activities
                              visible from the Compensation End Event are compensated, in
                              reverse order of their Sequence Flows. Visible means one of the
                              following:
                             • The Compensation End Event is contained in normal flow and at
                               the same level of Sub-Process as the Activities.
                             • The Compensation End Event is contained in a Compensation
                               Event Sub-Process which is contained in the Sub-Process
                               containing the Activities.
                       To be compensated, an Activity MUST have a boundary Compensation
                       Event or contain a Compensation Event Sub-Process.

 Signal                This type of End indicates that a Signal will be broadcasted when the
                       End has been reached. Note that the Signal, which is broadcast to any
                       Process that can receive the Signal, can be sent across Process levels
                       or Pools, but is not a Message (which has a specific source and target).
                       The attributes of a Signal can be found on page 278.

 Terminate             This type of End indicates that all Activities in the Process should be
                       immediately ended. This includes all instances of multi-instances. The
                       Process is ended without compensation or event handling.


 Multiple              This means that there are multiple consequences of ending the Process.
                       All of them will occur (e.g., there might be multiple Messages sent).
                       There is no specific EventDefinition subclass (see page 265) for
                       Multiple End Events. If the End Event has more than one associated
                       EventDefiniton, then the Event will be displayed with the Multiple
                       Event marker (a pentagon—see the figure on the right).




Business Process Model and Notation, v2.0                                                             253
Sequence Flow Connections

See Section “Sequence Flow Connections Rules” on page 42 for the entire set of objects and how they MAY be a source
or target of a Sequence Flow.
          An End Event MUST be a target for a Sequence Flow.
          An End Event MAY have multiple incoming Sequence Flows.

The Flow MAY come from either alternative or parallel paths. For modeling convenience, each path MAY connect to a
separate End Event object. The End Event is used as a Sink for all tokens that arrive at the Event. All tokens that are
generated at the Start Event for that Process MUST eventually arrive at an End Event. The Process will be in a
running state until all tokens are consumed.
          An End Event MUST NOT be a source for Sequence Flows; that is, there MUST NOT be outgoing Sequence
          Flows.
               An exception to this is when an End Event is used in an Expanded Sub-Process and is attached to the
              boundary of that Sub-Process. In this case, a Sequence Flow from the higher-level Process MAY connect
              from that End Event in lieu of connecting from the actual boundary of the Sub-Process.

Message Flow Connections

See Section “Message Flow Connection Rules” on page 43 for the entire set of objects and how they MAY be a source or
target of a Message Flow.

Note – All Message Flows MUST connect two separate Pools. They MAY connect to the Pool boundary or to Flow
Objects within the Pool boundary. They MUST NOT connect two objects within the same Pool.

          An End Event MUST NOT be the target of a Message Flow; it can have no incoming Message Flows..
          An End Event MAY be the source of a Message Flow; it can have zero (0) or more outgoing Message Flows.
          Each Message Flow leaving the End Event will have a Message sent when the Event is triggered.
              The Result attribute of the End Event MUST be set to Message or Multiple if there are any outgoing
              Message Flows.
              The Result attribute of the End Event MUST be set to Multiple if there is more than one (1) outgoing
              Message Flows.

10.4.4 Intermediate Event

As the name implies, the Intermediate Event indicates where something happens (an Event) somewhere between the
start and end of a Process. It will affect the flow of the Process, but will not start or (directly) terminate the Process.
Intermediate Events can be used to:

      • Show where Messages are expected or sent within the Process,
      • Show delays are expected within the Process,
      • Disrupt the normal flow through exception handling, or
      • Show the extra work needed for compensation.

The Intermediate Event shares the same basic shape of the Start Event and End Event, a circle with an open center
so that markers can be placed within the circle to indicate variations of the Event.


254                                                                              Business Process Model and Notation, v2.0
         An Intermediate Event is a circle that MUST be drawn with a double thin line. (see Figure 10.72).
             The use of text, color, size, and lines for an Intermediate Event MUST follow the rules defined in Section
             “Use of Text, Color, Size, and Lines in a Diagram” on page 41 with the exception that:
        The thickness of the line MUST remain double so that the Intermediate Event can be distinguished from the Start
        and End Events.




Figure 10.72 - Intermediate Event

One use of Intermediate Events is to represent exception or compensation handling. This will be shown by placing the
Intermediate Event on the boundary of a Task or Sub-Process (either collapsed or expanded). The Intermediate
Event can be attached to any location of the Activity boundary and the outgoing Sequence Flows can flow in any
direction. However, in the interest of clarity of the Diagram, we RECOMMEND that the modeler choose a consistent
location on the boundary. For example, if the Diagram orientation is horizontal, then the Intermediate Events can be
attached to the bottom of the Activity and the Sequence Flows directed down, then to the right. If the Diagram
orientation is vertical, then the Intermediate Events can be attached to the left or right side of the Activity and the
Sequence Flows directed to the left or right, then down.

Intermediate Event Triggers

There are twelve (12) types of Intermediate Events in BPMN: None, Message, Timer, Escalation, Error, Cancel,
Compensation, Conditional, Link, Signal, Multiple, and Parallel Multiple. Each type of Intermediate Event will
have a different icon placed in the center of the Intermediate Event shape to distinguish one from another.

There are two (2) ways that Intermediate Events are used in BPMN:

An Intermediate Event that is placed within the normal flow of a Process can be used for one of two purposes. The
Event can respond to (“catch”) the Event trigger or the Event can be used to set off (“throw”) the Event trigger. An
Intermediate Event that is attached to the boundary of an Activity can only be used to “catch” the Event trigger.

Intermediate Events in Normal Flow

When a token arrives at an Intermediate Event that is placed within the normal flow of a Process, one of two things
will happen. If the Event is used to “throw” the Event trigger, then trigger of the Event will immediately occur (e.g.,
the Message will be sent) and the token will move down the outgoing Sequence Flow. If the Event is used to “catch”
the Event trigger, then the token will remain at the Event until the trigger occurs (e.g., the Message is received). Then
the token will move down the outgoing Sequence Flow.

Ten (10) of the twelve (12) Intermediate Events can be used in normal flow. Table 10.89




Business Process Model and Notation, v2.0                                                                            255
Table 10.89 – Intermediate Event Types in Normal Flow

 Trigger               Description                                                                     Marker

 None                  The None Intermediate Event is only valid in normal flow, i.e., it MAY            Throw
                       NOT be used on the boundary of an Activity. Although there is no specific
                       trigger for this Event, it is defined as throw Event. It is used for modeling
                       methodologies that use Events to indicate some change of state in the
                       Process.
                       There is no specific EventDefinition subclass (see page 265) for
                       None Intermediate Events. If the (throw) Intermediate Event has no
                       associated EventDefiniton, then the Event MUST be displayed with-
                       out a marker (see the figure on the right).

 Message               A Message Intermediate Event can be used to either send a Message                 Throw
                       or receive a Message.
                       When used to “throw” the Message, the Event marker MUST be filled
                       (see the upper figure on the right). When used to “catch” the Message,
                       then the Event marker MUST be unfilled (see the lower figure on the
                       right). This causes the Process to continue if it was waiting for the              Catch
                       Message, or changes the flow for exception handling.
                       The actual Participant from which the Message is received can be identi-
                       fied by connecting the Event to a Participant using a Message Flow
                       within the definitional Collaboration of the Process – see Table 10.1.
                       See page 93 for more details on Messages.

 Timer                 In normal flow the Timer Intermediate Event acts as a delay mechanism              Catch
                       based on a specific time-date or a specific cycle (e.g., every Monday at
                       9am) can be set that will trigger the Event. This Event MUST be dis-
                       played with a clock marker (see the figure on the right).


 Escalation            In normal flow, the Escalation Intermediate Event raises an Escalation.           Throw
                       Since this is a Throw Event, the arrowhead marker will be filled (see the
                       figure to the right).




256                                                                          Business Process Model and Notation, v2.0
Table 10.89 – Intermediate Event Types in Normal Flow

 Compensation           In normal flow, this Intermediate Event indicates that compensation is          Throw
                        necessary. Thus, it is used to "throw" the Compensation Event, and the
                        Event marker MUST be filled (see figure on the right). If an Activity is
                        identified, and it was successfully completed, then that Activity will be
                        compensated. The Activity MUST be visible from the Compensation
                        Intermediate Event, i.e., one of the following MUST be true:
                            • The Compensation Intermediate Event is contained in normal
                              flow at the same level of Sub-Process.
                             • The Compensation Intermediate Event is contained in a
                               Compensation Event Sub-Process which is contained in the Sub-
                               Process containing the Activity.
                        If no Activity is identified, all successfully completed Activities visible
                        from the Compensation Intermediate Event are compensated, in
                        reverse order of their Sequence Flows. Visible means one of the follow-
                        ing:
                            • The Compensation Intermediate Event is contained in normal
                              flow and at the same level of Sub-Process as the Activities.
                            • The Compensation Intermediate Event is contained in a
                              Compensation Event Sub-Process which is contained in the Sub-
                              Process containing the Activities.
                        To be compensated, an Activity MUST have a boundary Compensation
                        Event, or contain a Compensation Event Sub-Process.

 Conditional            This type of Event is triggered when a condition becomes true. A condi-         Catch
                        tion is a type of Expression. The attributes of an Expression can be
                        found page 84.



 Link                   The Link Intermediate Events are only valid in normal flow, i.e. they MAY       Throw
                        NOT be used on the boundary of an Activity. A Link is a mechanism for
                        connecting two sections of a Process. Link Events can be used to create
                        looping situations or to avoid long Sequence Flow lines. Link Event uses
                        are limited to a single Process level (i.e., they cannot link a parent
                        Process with a Sub-Process). Paired Intermediate Events can also be             Catch
                        used as “Off-Page Connectors” for printing a Process across multiple
                        pages. They can also be used as generic “Go To” objects within the
                        Process level. There can be multiple source Link Events, but there can
                        only be one target Link Event.
                        When used to “throw” to the target Link, the Event marker will be filled
                        (see the top figure on the right). When used to “catch” from the source
                        Link, the Event marker will be unfilled (see the bottom figure on the right).




Business Process Model and Notation, v2.0                                                                       257
Table 10.89 – Intermediate Event Types in Normal Flow

 Signal                This type of Event is used for sending or receiving Signals. A Signal is         Throw
                       for general communication within and across Process levels, across
                       Pools, and between Business Process Diagrams. A BPMN Signal is
                       similar to a signal flare that shot into the sky for anyone who might be
                       interested to notice and then react. Thus, there is a source of the Signal,
                       but no specific intended target. This type of Intermediate Event can send         Catch
                       or receive a Signal if the Event is part of a normal flow. The Event can
                       only receive a Signal when attached to the boundary of an Activity. The
                       Signal Event differs from an Error Event in that the Signal defines a
                       more general, non-error condition for interrupting Activities (such as the
                       successful completion of another Activity) as well as having a larger
                       scope than Error Events. When used to “catch” the Signal, the Event
                       marker will be unfilled (see the middle figure on the right). When used to
                       “throw” the Signal, the Event marker will be filled (see the top figure on
                       the right). The attributes of a Signal can be found on page 278.

 Multiple              This means that there are multiple triggers assigned to the Event. If used       Throw
                       within normal flow, the Event can “catch” the trigger or “throw” the trig-
                       gers. When attached to the boundary of an Activity, the Event can only
                       “catch” the trigger. When used to “catch” the trigger, only one of the
                       assigned triggers is REQUIRED and the Event marker will be unfilled
                       (see the middle figure on the right). When used to “throw” the trigger (the       Catch
                       same as a Multiple End Event), all the assigned triggers will be thrown
                       and the Event marker will be filled (see the top figure on the right).
                       There is no specific EventDefinition subclass (see page 265) for
                       Multiple Intermediate Events. If the Intermediate Event has more than
                       one associated EventDefiniton, then the Event will be displayed with
                       the Multiple Event marker.

 Parallel Multiple     This means that there are multiple triggers assigned to the Event. If used        Catch
                       within normal flow, the Event can only “catch” the trigger. When attached
                       to the boundary of an Activity, the Event can only “catch” the trigger.
                       Unlike the normal Multiple Intermediate Event, all of the assigned trig-
                       gers are REQUIRED for the Event to be triggered.
                       The Event marker will be an unfilled plus sign (see the figure on the right).
                       There is no specific EventDefinition subclass (see page 265) for Par-
                       allel Multiple Intermediate Events. If the Intermediate Event has more
                       than one associated EventDefiniton and the parallelMultiple
                       attribute of the Intermediate Event is true, then the Event will be dis-
                       played with the Parallel Multiple Event marker.




258                                                                         Business Process Model and Notation, v2.0
Intermediate Events Attached to an Activity Boundary

Table 10.90 describes the Intermediate Events that can be attached to the boundary of an Activity.

Table 10.90 – Intermediate Event Types Attached to an Activity Boundary

 Trigger                 Description                                                                    Marker

 Message                 A Message arrives from a participant and triggers the Event. If a              Interrupting
                         Message Event is attached to the boundary of an Activity, it will change
                         the normal flow into an exception flow upon being triggered.
                         For a Message Event that interrupts the Activity to which it is attached,
                         the boundary of the Event is solid (see upper figure on the right). Note
                         that if using this notation, the attribute cancelActivity of the Activity
                                                                                                        Non-Inter-
                         to which the Event is attached is implicitly set to true.
                                                                                                         rupting
                         For a Message Event that does not interrupt the Activity to which it is
                         attached, the boundary of the Event is dashed (see lower figure on the
                         right). Note that if using this notation, the attribute cancelActivity of
                         the Activity to which the Event is attached is implicitly set to false.
                         The actual Participant from which the Message is received can be identi-
                         fied by connecting the Event to a Participant using a Message Flow
                         within the definitional Collaboration of the Process – see Table 10.1.

 Timer                   A specific time-date or a specific cycle (e.g., every Monday at 9am) can       Interrupting
                         be set that will trigger the Event. If a Timer Event is attached to the
                         boundary of an Activity, it will change the normal flow into an exception
                         flow upon being triggered.
                         For a Timer Event that interrupts the Activity to which it is attached, the
                         boundary of the Event is solid (see upper figure on the right). Note that if   Non-Inter-
                         using this notation, the attribute cancelActivity of the Activity to            rupting
                         which the Event is attached is implicitly set to true.
                         For a Timer Event that does not interrupt the Activity to which it is
                         attached, the boundary of the Event is dashed (see lower figure on the
                         right). Note that if using this notation, the attribute cancelActivity of
                         the Activity to which the Event is attached is implicitly set to false.




Business Process Model and Notation, v2.0                                                                        259
Table 10.90 – Intermediate Event Types Attached to an Activity Boundary

 Escalation             This type of Event is used for handling a named Escalation. If attached         Interrupting
                        to the boundary of an Activity, the Intermediate Event catches an
                        Escalation. In contrast to an Error, an Escalation by default is
                        assumed to not abort the Activity to which the boundary Event is
                        attached. However, a modeler can decide to override this setting by using
                        the notation described in the following.                                        Non-Inter-
                        For an Escalation Event that interrupts the Activity to which it is              rupting
                        attached, the boundary of the Event is solid (see upper figure on the
                        right). Note that if using this notation, the attribute cancelActivity of
                        the Activity to which the Event is attached is implicitly set to true.
                        For an Escalation Event that does not interrupt the Activity to which it is
                        attached, the boundary of the Event is dashed (see lower figure on the
                        right). Note that if using this notation, the attribute cancelActivity of
                        the Activity to which the Event is attached is implicitly set to false.

 Error                  A catch Intermediate Error Event can only be attached to the boundary           Interrupting
                        of an Activity, i.e., it MAY NOT be used in normal flow. If used in this con-
                        text, it reacts to (catches) a named Error, or to any Error if a name is
                        not specified.
                        Note that an Error Event always interrupts the Activity to which it is
                        attached, i.e., there is not a non-interrupting version of this Event. The
                        boundary of the Event thus always solid (see figure on the right).

 Cancel                 This type of Intermediate Event is used within a Transaction Sub-Proc-          Interrupting
                        ess. This type of Event MUST be attached to the boundary of a Sub-
                        Process. It SHALL be triggered if a Cancel End Event is reached within
                        the Transaction Sub-Process. It also SHALL be triggered if a
                        TransactionProtocol “Cancel” Message has been received while the
                        transaction is being performed.
                        Note that a Cancel Event always interrupts the Activity to which it is
                        attached, i.e., there is not a non-interrupting version of this Event. The
                        boundary of the Event thus always solid (see figure on the right).

 Compensation           When attached to the boundary of an Activity, this Event is used to
                        "catch" the Compensation Event, thus the Event marker MUST be
                        unfilled (see figure on the right). The Event will be triggered by a thrown
                        compensation targeting that Activity. When the Event is triggered, the
                        Compensation Activity that is associated to the Event will be performed
                        (see page 308).
                        Note that the interrupting a non-interrupting aspect of other Events does
                        not apply in the case of a Compensation Event. Compensations can
                        only be triggered after completion of the Activity to which they are
                        attached. Thus they cannot interrupt the Activity. The boundary of the
                        Event is always solid.


260                                                                          Business Process Model and Notation, v2.0
Table 10.90 – Intermediate Event Types Attached to an Activity Boundary

 Conditional             This type of Event is triggered when a condition becomes true. A condi-          Interrupting
                         tion is a type of Expression. The attributes of an Expression can be
                         found page 84. If a Conditional Event is attached to the boundary of an
                         Activity, it will change the normal flow into an exception flow upon being
                         triggered.
                         For a Conditional Event that interrupts the Activity to which it is              Non-Inter-
                         attached, the boundary of the Event is solid (see upper figure on the             rupting
                         right). Note that if using this notation, the attribute cancelActivity of
                         the Activity to which the Event is attached is implicitly set to true.
                         For a Conditional Event that does not interrupt the Activity to which it is
                         attached, the boundary of the Event is dashed (see lower figure on the
                         right). Note that if using this notation, the attribute cancelActivity of
                         the Activity to which the Event is attached is implicitly set to false.

 Signal                  The Signal Event can receive a Signal when attached to the boundary              Interrupting
                         of an Activity. In this context, it will change the normal flow into an excep-
                         tion flow upon being triggered. The Signal Event differs from an Error
                         Event in that the Signal defines a more general, non-error condition for
                         interrupting Activities (such as the successful completion of another
                         Activity) as well as having a larger scope than Error Events. When used          Non-Inter-
                         to “catch” the Signal, the Event marker will be unfilled. The attributes of       rupting
                         a Signal can be found on page 278.
                         For a Signal Event that interrupts the Activity to which it is attached, the
                         boundary of the Event is solid (see upper figure on the right). Note that if
                         using this notation, the attribute cancelActivity of the Activity to
                         which the Event is attached is implicitly set to true.
                         For a Signal Event that does not interrupt the Activity to which it is
                         attached, the boundary of the Event is dashed (see lower figure on the
                         right). Note that if using this notation, the attribute cancelActivity of
                         the Activity to which the Event is attached is implicitly set to false.




Business Process Model and Notation, v2.0                                                                          261
Table 10.90 – Intermediate Event Types Attached to an Activity Boundary

 Multiple               A Multiple Event indicates that there are multiple triggers assigned to the    Interrupting
                        Event. When attached to the boundary of an Activity, the Event can only
                        “catch” the trigger. In this case, only one of the assigned triggers is
                        REQUIRED and the Event marker will be unfilled upon being triggered,
                        the Event that occurred will change the normal flow into an exception
                        flow.                                                                          Non- Inter-
                        There is no specific EventDefinition subclass (see page 265) for                rupting
                        Multiple Intermediate Events. If the Intermediate Event has more than
                        one associated EventDefiniton, then the Event will be displayed with
                        the Multiple Event marker.
                        For a Multiple Event that interrupts the Activity to which it is attached,
                        the boundary of the Event is solid (see upper figure on the right). Note
                        that if using this notation, the attribute cancelActivity of the Activity
                        to which the Event is attached is implicitly set to true.
                        For a Multiple Event that does not interrupt the Activity to which it is
                        attached, the boundary of the Event is dashed (see lower figure on the
                        right). Note that if using this notation, the attribute cancelActivity of
                        the Activity to which the Event is attached is implicitly set to false.

 Parallel               This means that there are multiple triggers assigned to the Event. When        Interrupting
 Multiple               attached to the boundary of an Activity, the Event can only “catch” the
                        trigger. Unlike the normal Multiple Intermediate Event, all of the
                        assigned triggers are REQUIRED for the Event to be triggered. The
                        Event marker will be an unfilled plus sign (see the figures on the right).
                        There is no specific EventDefinition subclass (see page 265) for               Non-Inter-
                        Parallel Multiple Intermediate Events. If the Intermediate Event has            rupting
                        more than one associated EventDefiniton and the
                        parallelMultiple attribute of the Intermediate Event is true, then the
                        Event will be displayed with the Parallel Multiple Event marker.
                        For a Parallel Multiple Event that interrupts the Activity to which it is
                        attached, the boundary of the Event is solid (see the upper figure to the
                        right). Note that if using this notation, the attribute cancelActivity of
                        the Activity to which the Event is attached is implicitly set to true.
                        For a Parallel Multiple Event that does not interrupt the Activity to which
                        it is attached, the boundary of the Event is dashed (see the lower figure to
                        the right). Note that if using this notation, the attribute cancelActivity
                        of the Activity to which the Event is attached is implicitly set to false.




262                                                                         Business Process Model and Notation, v2.0
Attributes for Boundary Events

For boundary Events, the following additional attributes exists:

The BoundaryEvent element inherits the attributes and model associations of CatchEvent (see Table 8.44). Table
8.46 presents the additional attributes and model associations of the Boundary Event element:


 Table 10.91 – Boundary Event attributes

 Attribute Name               Description/Usage

 attachedTo: Activity         Denotes the Activity that boundary Event is attached to.

 cancelActivity:              Denotes whether the Activity should be cancelled or not, i.e., whether the boundary
 boolean                      catch Event acts as an Error or an Escalation. If the Activity is not cancelled,
                              multiple instances of that handler can run concurrently.
                              This attribute cannot be applied to Error Events (where it’s always true), or
                              Compensation Events (where it doesn’t apply).

Table 10.92 specifies whether the cancel Activity attribute can be set on a boundary Event depending on the
EventDefinition it catches.


 Table 10.92 – Possible Values of the cancelActivity Attribute

 Trigger                      Possible Values for the cancelActivity Attribute

 None                         N/A as this event cannot be attached to the Activity border.

 Message                      True/false

 Timer                        True/false

 Escalation                   True/false

 Error                        True

 Cancel                       True

 Compensation                 N/A as the scope was already executed and can no longer be canceled when com-
                              pensation is triggered.

 Conditional                  True/false

 Signal                       True/false

 Multiple                     True/false if all Event triggers allow this option (see this table for details). Otherwise
                              the more restrictive option, i.e. Yes in case any Error or cancel triggers are used.




Business Process Model and Notation, v2.0                                                                             263
Activity Boundary Connections

An Intermediate Event can be attached to the boundary of an Activity under the following conditions:
         (One or more) Intermediate Events MAY be attached directly to the boundary of an Activity.
              To be attached to the boundary of an Activity, an Intermediate Event MUST be one of the following
             triggers (EventDefinition): Message, Timer, Error, Escalation, Cancel, Compensation,
             Conditional, Signal, Multiple, and Parallel Multiple.
         An Intermediate Event with a Cancel trigger MAY be attached to a Sub-Process boundary only if the
         Transaction attribute of the Sub-Process is set to true.

Sequence Flow Connections

See Section “Sequence Flow Connections Rules” on page 42 for the entire set of objects and how they MAY be a source
or target of a Sequence Flow.
         If the Intermediate Event is attached to the boundary of an Activity:
             The Intermediate Event MUST NOT be a target for a Sequence Flow; it cannot have an incoming
             Sequence Flows.
                  The Intermediate Event MUST be a source for a Sequence Flow.
                   Multiple Sequence Flows MAY originate from an Intermediate Event. For each Sequence Flow
                  that has the Intermediate Event as a source, a new parallel path SHALL be generated.
                      An exception to this: an Intermediate Event with a Compensation trigger MUST NOT have an
                      outgoing Sequence Flow (it MAY have an outgoing Association).
         The Intermediate Events with the following triggers (EventDefinition) MAY be used in normal flow:
         None, Message, Timer, Escalation, Compensation, Conditional, Link, Signal, Multiple, and
         ParallelMultiple. Thus, the following MUST NOT: Cancel and Error.
              If the Intermediate Event is used within normal flow:
                  Intermediate Events MUST be a target of a Sequence Flow.

Note – this is a change from BPMN 1.2 semantics, which allowed some Intermediate Events to not have an incoming
Sequence Flow.

                  An Intermediate Event MAY have multiple incoming Sequence Flows.

Note – If the Event has multiple incoming Sequence Flows, then this is considered uncontrolled flow. This means that
when a token arrives from one of the Paths, the Event will be enabled (to catch or throw). It will not wait for the arrival of
tokens from the other paths. If another token arrives from the same path or another path, then a separate instance of the Event
will be created. If the flow needs to be controlled, then the flow should converge with a Gateway that precedes the Event
(see page 292 for more information on Gateways).

         An Intermediate Event MUST be a source for a Sequence Flow.
          Multiple Sequence Flows MAY originate from an Intermediate Event. For each Sequence Flow that has the
         Intermediate Event as a source, a new parallel path SHALL be generated.
             An exception to this: a source Link Intermediate Event (as defined below), it is NOT REQUIRED to have an
             outgoing Sequence Flow.
         A Link Intermediate Event MUST NOT be both a target and a source of a Sequence Flow.


264                                                                                Business Process Model and Notation, v2.0
To define the use of a Link Intermediate Event as an “Off-Page Connector” or a “Go To” object:
        A Link Intermediate Event MAY be the target (target Link) or a source (source Link) of a Sequence Flow,
        but MUST NOT be both a target and a source.
             If there is a source Link, there MUST be a matching target Link (they have the same name).
                 There MAY be multiple source Links for a single target Link.
                 There MUST NOT be multiple target Links for a single source Link.

Message Flow Connections

See Section “Message Flow Connection Rules” on page 42 for the entire set of objects and how they MAY be a source or
target of a Message Flow.

Note – All Message Flows MUST connect two separate Pools. They MAY connect to the Pool boundary or to Flow
Objects within the Pool boundary. They MUST NOT connect two objects within the same Pool.

        A Message Intermediate Event MAY be the target for a Message Flow; it can have one (1) incoming
        Message Flow.
        A Message Intermediate Event MAY be a source for a Message Flow; it can have one (1) outgoing
        Message Flow.
        A Message Intermediate Event MAY have an incoming Message Flow or an outgoing Message Flow, but
        not both.

10.4.5 Event Definitions

Event Definitions refers to the triggers of Catch Events (Start and receive Intermediate Events) and the
Results of Throw Events (End Events and send Intermediate Events). The types of Event Definitions are:
CancelEventDefinition, CompensationEventDefinition, ConditionalEventDefinition,
ErrorEventDefinition, EscalationEventDefinition, MessageEventDefinition,
LinkEventDefinition, SignalEventDefinition, TerminateEventDefinition, and
TimerEventDefinition (see Table 10.93). A None Event is determined by an Event that does not specify an
Event Definition. A Multiple Event is determined by an Event that specifies more than one Event Definition. The
different types of Events (Start, End, and Intermediate) utilize a subset of the available types of Event Definitions.




Business Process Model and Notation, v2.0                                                                          265
Table 10.93 – Types of Events and their Markers

 Types                            Start                                   Intermediate                        End
                    Top-    Event          Event          Catching   Boundary       Boundary       Throwing
                    Level   Sub-Process    Sub-Process               Interrupting   Non-
                            Interrupting   Non-                                     Interrupting
                                           Interrupting

 None



 Message



 Timer



 Error



 Escalation



 Cancel



 Compensation



 Conditional



 Link



 Signal



 Terminate



 Multiple




266                                                                           Business Process Model and Notation, v2.0
Table 10.93 – Types of Events and their Markers

 Parallel
 Multiple

The following sections will present the attributes common to all Event Definitions and the specific attributes for the
Event Definitions that have additional attributes. Note that the Cancel and Terminate Event Definitions do not have
additional attributes.

Event Definition Metamodel
Figure 10.73 shows the class diagram for the abstract class EventDefinition. When one of the EventDefinition
sub-types (e.g., TimerEventDefinition) is defined it is contained in Definitions, or a contained
EventDefinition contained in a throw/catch Event.




Figure 10.73 – EventDefinition Class Diagram

The EventDefinition element inherits the attributes and model associations of BaseElement (see Table 8.5)
through its relationship to RootElement, but does not contain any additional attributes or model associations.

The ErrorEventDefinition, EscalationEventDefinition and SignalEventDefinition subclasses
comprise of attributes to carry data. The data is defined as part of the Events package. The
MessageEventDefinition subclass comprises of an attribute that refers to a Message which is defined as part of
the Collaboration package.

The following sections will present the sub-types of EventDefinitions.

Business Process Model and Notation, v2.0                                                                            267
Cancel Event

Cancel Events are only used in the context of modeling Transaction Sub-Processes (see page 180 for more details
on Transactions). There are two (2) variations: a catch Intermediate Event and an End Event.
        The catch Cancel Intermediate Event MUST only be attached to the boundary of a Transaction Sub-
        Process and, thus, MAY NOT be used in normal flow.
         The Cancel End Event MUST only be used within a Transaction Sub-Process and, thus, MAY NOT be used
        in any other type of Sub-Process or Process.

Figure 10.74 shows the variations of Cancel Events.




Figure 10.74 – Cancel Events

The CancelEventDefinition element inherits the attributes and model associations of BaseElement (see Table
8.5) through its relationship to the EventDefinition element (see page 265).

Compensation Event

Compensation Events are used in the context of triggering or handling compensation (see page 308 for more details
on compensation). There are four (4) variations: a Start Event, both a catch and throw Intermediate Event, and an
End Event.
        The Compensation Start Event MAY NOT be used for a top-level Process.
        The Compensation Start Event MAY be used for an Event Sub-Process.
         The catch Compensation Intermediate Event MUST only be attached to the boundary of an Activity and,
        thus, MAY NOT be used in normal flow.
        The throw Compensation Intermediate Event MAY be used in normal flow.
        The Compensation End Event MAY be used within any Sub-Process or Process.

Figure 10.75 shows the variations of Compensation Events.




Figure 10.75 – Compensation Events

Figure 10.76 displays the class diagram for the CompensationEventDefinition.




268                                                                        Business Process Model and Notation, v2.0
Figure 10.76 - CompensationEventDefinition Class Diagram

The CompensationEventDefinition element inherits the attributes and model associations of BaseElement
(see Table 8.5) through its relationship to the EventDefinition element (see page 265). Table 10.94 presents the
additional attributes and model associations of the CompensationEventDefinition element:


 Table 10.94 – CompensationEventDefinition attributes and model associations

 Attribute Name              Description/Usage

 activityRef: Activity       For a Start Event:
 [0..1]                       This Event “catches” the compensation for an Event Sub-Process. No further
                              information is REQUIRED. The Event Sub-Process will provide the Id necessary
                              to match the Compensation Event with the Event that threw the compensation,
                              or the compensation will have been a broadcast.
                             For an End Event:
                              The Activity to be compensated MAY be supplied. If an Activity is not supplied,
                              then the compensation is broadcast to all completed Activities in the current Sub-
                              Process (if present), or the entire Process instance (if at the global level).
                             For an Intermediate Event within normal flow:
                              The Activity to be compensated MAY be supplied. If an Activity is not supplied,
                              then the compensation is broadcast to all completed Activities in the current Sub-
                              Process (if present), or the entire Process instance (if at the global level). This
                              “throws” the compensation.
                             For an Intermediate Event attached to the boundary of an Activity:
                              This Event “catches” the compensation. No further information is REQUIRED. The
                              Activity the Event is attached to will provide the Id necessary to match the Com-
                              pensation Event with the Event that threw the compensation, or the compensa-
                              tion will have been a broadcast.

 waitForCompletion:          For a throw Compensation Event, this flag determines whether the throw Interme-
 boolean = true              diate Event waits for the triggered compensation to complete (the default), or just
                             triggers the compensation and immediately continues (the BPMN 1.2 behavior).




Business Process Model and Notation, v2.0                                                                      269
Conditional Event

Figure 10.77 shows the variations of Conditional Events.




Figure 10.77 – Conditional Events

The ConditionalEventDefinition element inherits the attributes and model associations of BaseElement (see
Table 8.5) through its relationship to the EventDefinition element (see page 265). Table 10.95 presents the
additional model associations of the ConditionalEventDefinition element:

Figure 10.78 displays the class diagram for the ConditionalEventDefinition.




Figure 10.78 - ConditionalEventDefinition Class Diagram

The ConditionalEventDefinition element inherits the attributes and model associations of BaseElement (see
Table 8.5) through its relationship to the EventDefinition element (see page 265). Table 10.95 presents the
additional model associations of the ConditionalEventDefinition element:


 Table 10.95 – ConditionalEventDefinition model associations

 Attribute Name               Description/Usage

 condition: Expression        The Expression might be underspecified and provided in the form of natural lan-
                              guage. For executable Processes (isExecutable = true), if the trigger is Condi-
                              tional, then a FormalExpression MUST be entered.

Error Event

Figure 10.79 shows the variations of Conditional Events.




Figure 10.79 – Error Events


270                                                                      Business Process Model and Notation, v2.0
Figure 10.80 displays the class diagram for the ErrorEventDefinition.




Figure 10.80 - ErrorEventDefinition Class Diagram

The ErrorEventDefinition element inherits the attributes and model associations of BaseElement (see Table
8.5) through its relationship to the EventDefinition element (see page 265). Table 10.96 presents the additional
attributes and model associations of the ErrorEventDefinition element:


 Table 10.96 – ErrorEventDefinition attributes and model associations

 Attribute Name              Description/Usage

 error: Error [0..1]         If the trigger is an Error, then an Error payload MAY be provided.

Escalation Event Definition

Figure 10.81 shows the variations of Escalation Events.




Figure 10.81 – Escalation Events

Figure 10.82 displays the class diagram for the EscalationEventDefinition.




Business Process Model and Notation, v2.0                                                                     271
Figure 10.82 - EscalationEventDefinition Class Diagram

The EscalationEventDefinition element inherits the attributes and model associations of BaseElement (see
Table 8.5) through its relationship to the EventDefinition element (see page 265). Table 10.97 presents the
additional attributes and model associations of the EscalationEventDefinition element:


 Table 10.97 – EscalationEventDefinition attributes and model associations

 Attribute Name                   Description/Usage

 escalationRef: Escalation        If the trigger is an Escalation, then an Escalation payload MAY be pro-
 [0..1]                           vided.

Link Event Definition

A Link Event is a mechanism for connecting two sections of a Process. Link Events can be used to create looping
situations or to avoid long Sequence Flow lines. The use of Link Events is limited to a single Process level (i.e.,
they cannot link a parent Process with a Sub-Process).

Figure 10.83 shows the variations of Link Events.




Figure 10.83 – Link Events

Paired Link Events can also be used as “Off-Page Connectors” for printing a Process across multiple pages. They can
also be used as generic “Go To” objects within the Process level. There can be multiple source Link Events, but there
can only be one target Link Event. When used to “catch” from the source Link, the Event marker will be unfilled (see
Figure 10.84: upper right). When used to “throw” to the target Link, the Event marker will be filled (see Figure 10.84:
upper: lower Left).

272                                                                           Business Process Model and Notation, v2.0
Since Process models often extend beyond the length of one printed page, there is often a concern about showing how
Sequence Flow connections extend across the page breaks. One solution that is often employed is the use of Off-Page
connectors to show where one page leaves off and the other begins. BPMN provides Intermediate Events of type Link
for use as Off-Page connectors (see Figure 10.84--Note that the figure shows two different printed pages, not two Pools
in one diagram). A pair of Link Events is used. One of the pair is shown at the end of one page. This Event is named
and has an incoming Sequence Flow and no outgoing Sequence Flows. The second Link Event is at the beginning
of the next page, shares the same name, and has an outgoing Sequence Flow and no incoming Sequence Flow.



                                                                       Source
                                                                     Link Event
                      Request Flights
                     within Parameters

                                               Prepare and
                                                                      Receive
                                              Send Candidate
                                                                    Confirmation
                                                Itineraries
    Travel                                           +                                        A
    Order             Request Rooms
                     within Parameters


                                                                 2 Days
                                                                          Send Cancellation
                                                                               Notice


                                            Page 1




                            Target
                          Link Event



                              Book              Charge
                                                               Send Confirmation
                           Reservations         Buyer

              A                  +




                                            Page 2


Figure 10.84 - Link Events Used as Off-Page Connector

Another way that Link Events can be used is as “Go To” objects. Functionally, they would work the same as for Off-
Page Connectors (described above), except that they could be used anywhere in the diagram--on the same page or across
multiple pages. The general idea is that they provide a mechanism for reducing the length of Sequence Flow lines.
Some modelers can consider long lines as being hard to follow or trace. Go To Objects can be used to avoid very long


Business Process Model and Notation, v2.0                                                                          273
Sequence Flows (see Figure 10.85 and Figure 10.86). Both diagrams will behave equivalently. For Figure 10.86, if the
“Order Rejected” path is taken from the Decision, then the token traversing the Sequence Flow would reach the source
Link Event and then “jump” to the target Link Event and continue down the Sequence Flow. The Process would
continue as if the Sequence Flow had directly connected the two objects.



                                                        Order rejected

 Requested
                                                        Ship Order
   Order

          Receive               Order
           Order               accepted    Fill Order                                                         Close Order
          Request
                                                          Send                 Make          Accept
                                                         Invoice              Payment       Payment




                                                                    Invoice

Figure 10.85 - A Process with a long Sequence Flow




                                To Close                                                           To Close
 Requested
                    Order rejected                      Ship Order
   Order

          Receive               Order
           Order               accepted    Fill Order                                                         Close Order
          Request
                                                           Send                Make          Accept
                                                          Invoice             Payment       Payment




                                                                    Invoice

Figure 10.86 - A Process with Link Intermediate Events used as Go To Objects

Some methodologies prefer that all Sequence Flows only move in one direction; that is, forward in time. These
methodologies do not allow Sequence Flows to connect directly to upstream objects. Some consistency in modeling
can be gained by such a methodology, but situations that require looping become a challenge. Link Events can be used
to make upstream connections and create loops without violating the Sequence Flow direction restriction (see Figure
10.87).




274                                                                                     Business Process Model and Notation, v2.0
                  Configure Product              Test Product          Pass Test?      Yes    Package Product




                                                                            No

Reconfigure                                                                         Reconfigure

Figure 10.87 - Link Events Used for looping

The LinkEventDefinition element inherits the attributes and model associations of BaseElement (see Table 8.5)
through its relationship to the EventDefinition element (see page 265). Table 10.98 presents the additional attributes
of the LinkEventDefinition element:


 Table 10.98 – LinkEventDefinition attributes

 Attribute Name              Description/Usage

 name: string                If the trigger is a Link, then the name MUST be entered.

 sources: LinkEventDef-      Used to reference the corresponding 'catch' or 'target' LinkEventDefinition, when
 inition [1..*]              this LinkEventDefinition represents a 'throw' or 'source' LinkEventDefinition.

 target: LinkEventDefini-    Used to reference the corresponding 'throw' or 'source' LinkEventDefinition,
 tion [1]                    when this LinkEventDefinition represents a 'catch' or 'target' LinkEventDefinition.



Message Event Definition

Figure 10.88 shows the variations of Message Events.




Figure 10.88 – Message Events




Business Process Model and Notation, v2.0                                                                          275
Figure 10.89 displays the class diagram for the MessageEventDefinition.




Figure 10.89 - MessageEventDefinition Class Diagram

The MessageEventDefinition element inherits the attributes and model associations of BaseElement (see Table
8.5) through its relationship to the EventDefinition element (see page 265). Table 10.99 presents the additional
model associations of the MessageEventDefinition element:


 Table 10.99 – MessageEventDefinition model associations

 Attribute Name                       Description/Usage

 messageRef: Message [0..1]           The Message MUST be supplied (if the isExecutable attribute of the
                                      Process is set to true).

 operationRef: Operation [0..1]       This attribute specifies the Operation that is used by the Message Event.
                                      It MUST be specified for executable Processes.



Multiple Event

For a Start Event:

If the trigger is Multiple, there are multiple ways of starting the Process. Only one of them is necessary to trigger the
start of the Process. The EventDefinition subclasses will define which triggers apply

For an End Event:

If the Result is Multiple, there are multiple consequences of ending the Process. All of them will occur. The
EventDefinition subclasses will define which Results apply.

For an Intermediate Event within normal flow:

If the trigger is Multiple, only one EventDefinition is REQUIRED to catch the trigger. When used to throw, all
of the EventDefinitions are considered and the subclasses will define which Results apply.

For an Intermediate Event attached to the boundary of an Activity:


276                                                                             Business Process Model and Notation, v2.0
If the trigger is Multiple, only one EventDefinition is REQUIRED to "catch" the trigger.

Figure 10.90 shows the variations of Multiple Events.




Figure 10.90 – Multiple Events

None Event

None Events are Events that do not have a defined EventDefinition. There are three (3) variations of None
Events: a Start Event, a catch Intermediate Event, and an End Event (see Figure 10.91).
        The None Start Event MAY be used for a top-level Process or any type of Sub-Process (except an Event
        Sub-Process)
         The None Start Event MAY NOT be used for an Event Sub-Process.
        The catch None Intermediate Event MUST only be used in normal flow and, thus, MAY NOT be attached to the
        boundary of an Activity.
         The None End Event MAY be used within any Sub-Process or Process.

Figure 10.91 shows the variations of None Events.




Figure 10.91 – None Events

Parallel Multiple Event

For a Start Event:

If the trigger is Multiple, there are multiple triggers REQUIRED to start the Process. All of them are necessary to
trigger the start of the Process. The EventDefinition subclasses will define which triggers apply. In addition, the
parallelMultiple attribute of the Start Event MUST be set to true.

For an Intermediate Event within normal flow:

If the trigger is Multiple, all of the defined EventDefinitions are REQUIRED to trigger the Event. In addition,
the parallelMultiple attribute of the Intermediate Event MUST be set to true.

For an Intermediate Event attached to the boundary of an Activity:

If the trigger is Multiple, all of the defined EventDefinitions are REQUIRED to trigger the Event. In addition, the
parallelMultiple attribute of the Intermediate Event MUST be set to true.

Figure 10.92 shows the variations of Parallel Multiple Events.




Business Process Model and Notation, v2.0                                                                      277
Figure 10.92 – Multiple Events

Signal Event




Figure 10.93 - SignalEventDefinition Class Diagram

Figure 10.94 shows the variations of Signal Events.




Figure 10.94 – Signal Events

The SignalEventDefinition element inherits the attributes and model associations of BaseElement (see Table
8.5) through its relationship to the EventDefinition element (see page 265). Table 10.100 presents the additional
model associations of the ConditionalSignalDefinition element:


 Table 10.100 – SignalEventDefinition model associations

 Attribute Name             Description/Usage

 signalRef: Signal [0..1]   If the trigger is a Signal, then a Signal is provided.



Terminate Event

Figure 10.95 shows the Terminate Event.



278                                                                       Business Process Model and Notation, v2.0
Figure 10.95 – Terminate Event

The TerminateEventDefinition element inherits the attributes and model associations of BaseElement (see
Table 8.5) through its relationship to the EventDefinition element (see page 265).

Timer Event

Figure 10.96 shows the variations of Timer Events.




Figure 10.96 – Timer Events

The TimerEventDefinition element inherits the attributes and model associations of BaseElement (see Table
8.5) through its relationship to the EventDefinition element (see page 265). Table 10.101 presents the additional
model associations of the TimerEventDefinition element:


 Table 10.101 – TimerEventDefinition model associations

 Attribute Name                   Description/Usage

 timeDate: Expression [0..1]      If the trigger is a Timer, then a timeDate MAY be entered. Timer attributes are
                                  mutually exclusive and if any of the other Timer attributes is set, timeDate MUST
                                  NOT be set (if the isExecutable attribute of the Process is set to true). The
                                  return type of the attribute timeDate MUST conform to the ISO-8601 format for date
                                  and time representations.

 timeCycle: Expression [0..1]     If the trigger is a Timer, then a timeCycle MAY be entered. Timer attributes are
                                  mutually exclusive and if any of the other Timer attributes is set, timeCycle MUST
                                  NOT be set (if the isExecutable attribute of the Process is set to true). The
                                  return type of the attribute timeCycle MUST conform to the ISO-8601 format for
                                  recurring time interval representations.

 timeDuration: Expression         If the trigger is a Timer, then a timeDuration MAY be entered. Timer attributes
 [0..1]                           are mutually exclusive and if any of the other Timer attributes is set, timeDuration
                                  MUST NOT be set (if the isExecutable attribute of the Process is set to true).
                                  The return type of the attribute timeDuration MUST conform to the ISO-8601 for-
                                  mat for time interval representations.




Business Process Model and Notation, v2.0                                                                          279
10.4.6 Handling Events

BPMN provides advanced constructs for dealing with Events that occur during the execution of a Process (i.e., the
“catching” of an Event). Furthermore, BPMN supports the explicit creation of an Event in the Process (i.e., the
“throwing” of an Event). Both catching and throwing of an Event as well as the resulting Process behavior is referred
to as Event handling. There are three (3) types of Event handlers: those that start a Process, those that are part of the
normal Sequence Flow, and those that are attached to Activities, either via boundary Events or via separate inline
handlers in case of an Event Sub-Process.

Handling Start Events

There are multiple ways in which a Process can be started. For single Start Events, handling consists of starting a new
Process instance each time the Event occurs. Sequence Flows leaving the Event are then followed as usual. For
multiple Start Events, BPMN supports several modeling scenarios that can be applied depending on the scenario.

Exclusive start: the most common scenario for starting a Process is its instantiation by exactly one out of many
possible Start Events. Each occurrence of one of these Events will lead to the creation of a new Process instance.
The following example shows two Events connected to a single Activity (see Figure 10.97). At runtime, each
occurrence of one of the Events will lead to the creation of a new instance of the Process instance and activation of the
Activity. Note that a single Multiple Start Event that contains the Message Event Definitions would behave in
the same way.




Message 1
                         Activity




Message 2
Figure 10.97 - Exclusive start of a Process

A Process can also be started via an Event-Based Gateway, as in the following example (Figure 10.98):




280                                                                            Business Process Model and Notation, v2.0
                                    Parse E-Mail




                                      Transcribe                         Process
                                         Fax                             Request




                                     Handle SMS


Figure 10.98 - A Process initiated by an Event-Based Gateway

In that case, the first matching Event will create a new instance of the Process, and waiting for the other Events
originating from the same decision stops, following the usual semantics of the Event-Based Exclusive Gateway. Note
that this is the only scenario where a Gateway can exist without an incoming Sequence Flows.

It is possible to have multiple groups of Event-Based Gateways starting a Process, provided they participate in the
same Conversation and hence share the same correlation information. In that case, one Event out of each group needs
to arrive; the first one creates a new Process instance, while the subsequent ones are routed to the existing instance,
which is identified through its correlation information.

Event synchronization: if the modeler requires several disjoint Start Events to be merged into a single Process
instance, then the following notation MUST be applied (Figure 10.99):




                     Activity


Figure 10.99 - Event synchronization at Process start

The Parallel Start Event MAY group several disjoint Start Events each of which MUST occur once in order for an
instance of the Process to be created. Sequence Flows leaving the Event are then followed as usual.

See page 451 for the execution semantics for the Event Handling of Start Events.

Handling Events within normal Sequence Flow (Intermediate Events)

For Intermediate Events, the handling consists of waiting for the Event to occur. Waiting starts when the
Intermediate Event is reached. Once the Event occurs, it is consumed. Sequence flows leaving the Event are
followed as usual.

Business Process Model and Notation, v2.0                                                                          281
Handling Events attached to an Activity (Intermediate boundary Events and Event Sub-Processes)

For boundary Events, handling consists of consuming the Event occurrence and either canceling the Activity the Event
is attached to, followed by normal Sequence Flows leaving that Activity, or by running an Event Handler without
canceling the Activity (only for Message, Signal, Timer and Conditional Events, not for Error Events).

An interrupting boundary Event is defined by a true value of its cancelActivity attribute. Whenever the Event
occurs, the associated Activity is terminated. A downstream token is then generated, which activates the next element of
the Process (connected to the Event by an unconditional Sequence Flow called an exception flow).

For non-interrupting boundary Events, the cancelActivity attribute is set to false. Whenever the Event occurs, the
associated Activity continues to be active. As a token is generated for the Sequence Flow from the boundary Event in
parallel to the continuing execution of the Activity, care MUST be taken when this flow is merged into the main flow of
the Process – typically it should be ended with its own End Event.

The following example shows a fragment (see Figure 10.100) from a trip booking Process. It contains a Sub-Process
that consists of a main part, and three Event Sub-Processes to deal with Events within the same context: an error
Event Sub-Process that cancels the Sub-Process, a Message Event Sub-Process that updates the state of the
Sub-Process while allowing it to continue, and a Compensation Event Sub-Process.




282                                                                            Business Process Model and Notation, v2.0
                                                                                                                         Notify
                                                                                                                        Customer
                                                                                                        Retry Limit    Invalid CC
                                                                                                        Exceeded


                                                                Booking
                                                                                                        Booking

                                                  Book Flight


               Get Credit
                                                                    Cancel                           Charge
                  Card
                                                                    Flight                         Credit Card
              Information



                                                  Book Hotel



                                                                    Cancel
                                                                     Hotel




                                        Update Credit Card Information

                                                    Update
                                                  Credit Card
                                                     Info




                                                     Handle Compensation

                                                                           Update
                                                                          Customer
                                                                           Record
                                       Booking   Flight    Hotel



                                                                                                                        Notify
                                                   Handle Booking Error
                                                                                                                       Customer
                                                                                                         Retry Limit    Failed
                                                                                         Booking                       Booking
                                                                                         Error 2         Exceeded
                                                           Flight


                                       Booking                                 Booking
                                       Error 1                                 Error 2

                                                           Hotel




Figure 10.100 - Example of inline Event Handling via Event Sub-Processes

The following example (see Figure 10.101) shows the same fragment of that Process, using boundary Event handlers
rather than inline Event Sub-Processes. Note that in this example, the handlers do not have access to the context of
the “Booking” Sub-Process, as they run outside of it. Therefore, the actually compensation logic is shown as a black
box.




Business Process Model and Notation, v2.0                                                                                           283
                                                                                                                   Notify
                                                                                                                 Customer
                                                                                                   Retry Limit   Invalid CC
                                                                                                   Exceeded


                                                          Booking
                                                                                                  Booking

                                                  Book Flight


                Get Credit                                          Cancel                     Charge
                   Card                                             Flight                   Credit Card
               Information



                                                   Book Hotel



                                                                    Cancel
                                                                                              Update
                                                                     Hotel
                                                                                            Credit Card
                                                                                               Info



                                                                                              Undo
                                                                                             Booking



                                                                                                                   Notify
                                                                                                                 Customer
                                                                                                   Retry Limit     Failed
                                                                                  Booking                         Booking
                                                                                  Error 2          Exceeded




Figure 10.101 - Example of boundary Event Handling

Note that there is a distinction between interrupting and non-interrupting Events and the handling of these Events,
which is described in the sections below. For an interrupting Event (Error, Escalation, Message, Signal, Timer,
Conditional, Multiple, and Parallel Multiple), only one Event Sub-Process for the same Event Declaration
MUST be modeled. This excludes any further non-interrupting handlers for that Event Declaration.

The reason for this restriction lies in the nature of interrupting Event Sub-Processes and boundary Events. They
interrupt normal execution of the parent Activity and after their completion, the parent Activity is immediately
terminated. This implies that only one such handler can be executed at a time. However, this does not restrict the modeler
in specifying several interrupting handlers, if each handler refers to a different Event Declaration.

For non-interrupting Events (Escalation, Message, Signal, Timer, Conditional, Multiple, and Parallel Multiple),
an unlimited number of Event Sub-Processes for the same Event Declaration can be modeled and executed in
parallel. At runtime, they will be invoked in a non-deterministic order. The same restrictions apply for boundary Events.
During execution of a non-interrupting Event Sub-Process, execution of the parent Activity continues as normal.

If for a given Sub-Process, both an inline Event Sub-Process and a boundary Event handler are modeled that
Process the same EventDefinition, the following semantics apply:
         If the inline Event Sub-Process “rethrows” the Event after completion, the boundary Event is triggered.
         If the inline Event Sub-Process completes without “rethrowing” the Event, the Activity is considered to have

284                                                                             Business Process Model and Notation, v2.0
        completed and normal Sequence Flow resumes. In other terms, the Event Sub-Process “absorbs” the Event.

Interrupting Event Handlers (Error, Escalation, Message, Signal, Timer, Conditional, Multiple, and Parallel
Multiple)

Interrupting Event Handlers are those that have the cancelActivity attribute is set to true. Whenever the Event
occurs, regardless of whether the Event is handled inline or on the boundary, the associated Activity is interrupted. If an
inline error handler is specified (in case of a Sub-Process), it is run within the context of that Sub-Process. If a
boundary Error Event is present, Sequence Flows from that boundary Event are then followed. The parent Activity
is canceled after either the error handler completes or Sequence Flow from the boundary Event is followed.

In the example above, the “Booking” Sub-Process has an Error handler that defines what should happen in case a
“Booking” Error occurs within the Sub-Process, namely, the already performed bookings are canceled using
compensation. The Error handler is then continued outside the Sub-Process through a boundary Error Event.

Non-interrupting Event Handlers (Escalation, Message, Signal, Timer, Conditional, Multiple, and Parallel
Multiple)

Interrupting Event Handlers are those that have the cancelActivity attribute is set to false.

For Event Sub-Processes, whenever the Event occurs it is consumed and the associated Event Sub-Process is
performed. If there are several Events that happen in parallel, then they are handled concurrently, i.e., several Event
Sub-Process instances are created concurrently. The non-interrupting Start Event indicates that the Event Sub-
Process instance runs concurrently to the Sub-Process proper.

For boundary Events, whenever the Event occurs the handler runs concurrently to the Activity. If an Event Sub-
Process is also specified for that Event (in case of a Sub-Process), it is run within the context of that Sub-Process.
Then, Sequence Flows from the boundary Event are followed. As a token is generated for the Sequence Flow from
the boundary Event in parallel to the continuing execution of the Activity, care MUST be taken when this flow is
merged into the main flow of the Process – typically it should be ended with its own End Event.

In the example above, an Event Handler allows to update the credit card information during the “Booking” Sub-
Process. It is triggered by a credit card information Message: such a Message can be received whenever the control
flow is within the main body of the Sub-Process. Once such a Message is received, the Activities within the
corresponding Event Handler run concurrently with the Activities within the body of the Sub-Process.

See page 451 for the exact semantics of boundary Intermediate Events and page 451 for the operational semantics of
non-interrupting Event Sub-Processes.

Handling End Events

For a Terminate End Event, all remaining active Activities within the Process are terminated.

A Cancel End Event is only allowed in the context of a Transaction Sub-Process and, as such, cancels the Sub-
Process and aborts an associated Transaction of the Sub-Process.

For all other End Events, the behavior associated with the EventDefinition is performed. When there are no
further active Activities, then the Sub-Process or Process instance is completed. See page 454 for exact semantics.

10.4.7 Scopes

A scope describes the context in which execution of an Activity happens. This consists of:


Business Process Model and Notation, v2.0                                                                              285
      • The set of Data Objects available (including DataInput and DataOutput)

      • The set of Events available for catching or throwing triggers

      • The set of Conversations going on in that scope

In general, a scope contains exactly one main flow of Activities which is started, when the scope gets activated. Vice
versa, all Activities are enclosed by a scope. Scopes are hierarchically nested.

Scopes can have several scope instances at runtime. They are also hierarchically nested according to their generation. In
a scope instance several tokens can be active.

Scope instances in turn have a lifecycle, containing amongst others the states:

      • Activated

      • In execution

      • Completed

      • In Compensation

      • Compensation

      • In Error

      • In Cancellation

      • Cancelled

BPMN has the following model elements with scope characteristics:

      • Choreography

      • Pool

      • Sub-Process

      • Task

      • Activity

      • Multi-instances body

Scopes are used to define the semantics of

      • Visibility of Data Objects (including DataInput and DataOutput)

      • Event resolution

      • Starting/stopping of token execution

The Data Objects, Events and correlation keys described by a scope can be explicitly modeled or implicitly
defined.




286                                                                               Business Process Model and Notation, v2.0
10.4.8 Events Package XML Schemas
Table 10.102 – BoundaryEvent XML schema

<xsd:element name="boundaryEvent" type="tBoundaryEvent" substitutionGroup="flowElement"/>
<xsd:complexType name="tBoundaryEvent">
    <xsd:complexContent>
        <xsd:extension base="tCatchEvent">
            <xsd:attribute name="cancelActivity" type="xsd:boolean" default="true"/>
            <xsd:attribute name="attachedToRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.103 – CancelEventDefinition XML schema

<xsd:element name="cancelEventDefinition" type="tCancelEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tCancelEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.104 – CatchEvent XML schema

<xsd:element name="catchEvent" type="tCatchEvent"/>
<xsd:complexType name="tCatchEvent" abstract="true">
    <xsd:complexContent>
        <xsd:extension base="tEvent">
            <xsd:sequence>
                <xsd:element ref="dataOutput" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element ref="dataOutputAssociation" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element ref="outputSet" minOccurs="0" maxOccurs="1"/>
                <xsd:element ref="eventDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element name="eventDefinitionRef" type="xsd:QName" minOccurs="0" maxOc-
                         curs="unbounded"/>
            </xsd:sequence>
            <xsd:attribute name="parallelMultiple" type="xsd:boolean" default="false"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>




Business Process Model and Notation, v2.0                                                                287
Table 10.105 – CancelEventDefinition XML schema

<xsd:element name="cancelEventDefinition" type="tCancelEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tCancelEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.106 – CompensateEventDefinition XML schema

<xsd:element name="compensateEventDefinition" type="tCompensateEventDefinition" substitutionGroup="event-
        Definition"/>
<xsd:complexType name="tCompensateEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:attribute name="waitForCompletion" type="xsd:boolean"/>
            <xsd:attribute name="activityRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.107 – ConditionalEventDefinition XML schema

<xsd:element name="conditionalEventDefinition" type="tConditionalEventDefinition" substitutionGroup="eventDef-
        inition"/>
<xsd:complexType name="tConditionalEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
              <xsd:sequence>
                  <xsd:element name="condition" type="tExpression"/>
              </xsd:sequence>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.108 – ErrorEventDefinition XML schema

<xsd:element name="errorEventDefinition" type="tErrorEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tErrorEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:attribute name="errorRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>




288                                                                     Business Process Model and Notation, v2.0
Table 10.109 – EscalationEventDefinition XML schema

<xsd:element name="escalationEventDefinition" type="tEscalationEventDefinition"
        substitutionGroup="eventDefinition"/>
<xsd:complexType name="tEscalationEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:attribute name="escalationRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.110 – Event XML schema

<xsd:element name="event" type="tEvent" substitutionGroup="flowElement"/>
<xsd:complexType name="tEvent" abstract="true">
    <xsd:complexContent>
        <xsd:extension base="tFlowNode"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.111 – EventDefinition XML schema

<xsd:element name="eventDefinition" type="tEventDefinition"/>
<xsd:complexType name="tEventDefinition" abstract="true">
    <xsd:complexContent>
        <xsd:extension base="tBaseElement"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.112 – ImplicitThrowEvent XML schema

<xsd:element name="implicitThrowEvent" type="tImplicitThrowEvent" substitutionGroup="flowElement"/>
<xsd:complexType name="tImplicitThrowEvent">
    <xsd:complexContent>
        <xsd:extension base="tThrowEvent"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.113 – IntermediateCatchEvent XML schema

<xsd:element name="intermediateCatchEvent" type="tIntermediateCatchEvent" substitutionGroup="flowElement"/
        >
<xsd:complexType name="tIntermediateCatchEvent">
    <xsd:complexContent>
        <xsd:extension base="tCatchEvent"/>
    </xsd:complexContent>
</xsd:complexType>




Business Process Model and Notation, v2.0                                                             289
Table 10.114 – IntermediateThrowEvent XML schema

<xsd:element name="intermediateThrowEvent" type="tIntermediateThrowEvent" substitutionGroup="flowEle-
        ment"/>
<xsd:complexType name="tIntermediateThrowEvent">
    <xsd:complexContent>
        <xsd:extension base="tThrowEvent"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.115 – LinkEventDefinition XML schema

<xsd:element name="linkEventDefinition" type="tLinkEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tLinkEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:sequence>
                <xsd:element name="source" type="xsd:QName" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element name="target" type="xsd:QName" minOccurs="0" maxOccurs="1"/>
            </xsd:sequence>
            <xsd:attribute name="name" type="xsd:string" use="required"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.116 – MessageEventDefinition XML schema

<xsd:element name="messageEventDefinition" type="tMessageEventDefinition" substitutionGroup="eventDefini-
        tion"/>
<xsd:complexType name="tMessageEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
             <xsd:sequence>
                 <xsd:element name="operationRef" type="xsd:QName" minOccurs="0" maxOccurs="1"/>
             </xsd:sequence>
        <xsd:attribute name="messageRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.117 – Signal XML schema

<xsd:element name="signal" type="tSignal" substitutionGroup="reusableElement"/>
<xsd:complexType name="tSignal">
   <xsd:complexContent>
        <xsd:extension base="tRootElement">
            <xsd:attribute name="name" type="xsd:string"/>
            <xsd:attribute name="structureRef" type="xsd:QName"/>
        </xsd:extension>


290                                                                    Business Process Model and Notation, v2.0
    </xsd:complexContent>
</xsd:complexType>

Table 10.118 – SignalEventDefinition XML schema

<xsd:element name="signalEventDefinition" type="tSignalEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tSignalEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:attribute name="signalRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.119 – StartEvent XML schema

<xsd:element name="startEvent" type="tStartEvent" substitutionGroup="flowElement"/>
<xsd:complexType name="tStartEvent">
    <xsd:complexContent>
        <xsd:extension base="tCatchEvent">
            <xsd:attribute name="isInterrupting" type="xsd:boolean" default="true"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.120 – TerminateEventDefinition XML schema

<xsd:element name="terminateEventDefinition" type="tTerminateEventDefinition" substitutionGroup="eventDefini-
        tion"/>
<xsd:complexType name="tTerminateEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.121 – ThrowEvent XML schema

<xsd:element name="throwEvent" type="tThrowEvent"/>
<xsd:complexType name="tThrowEvent" abstract="true">
   <xsd:complexContent>
        <xsd:extension base="tEvent">
            <xsd:sequence>
                <xsd:element ref="dataInput" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element ref="dataInputAssociation" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element ref="inputSet" minOccurs="0" maxOccurs="1"/>
                <xsd:element ref="eventDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xsd:element name="eventDefinitionRef" type="xsd:QName" minOccurs="0" maxOc-
                        curs="unbounded"/>
            </xsd:sequence>
        </xsd:extension>
   </xsd:complexContent>

Business Process Model and Notation, v2.0                                                                  291
</xsd:complexType>

Table 10.122 – TimerEventDefinition XML schema

<xsd:element name="timerEventDefinition" type="tTimerEventDefinition" substitutionGroup="eventDefinition"/>
<xsd:complexType name="tTimerEventDefinition">
    <xsd:complexContent>
        <xsd:extension base="tEventDefinition">
            <xsd:choice>
                <xsd:element name="timeDate" type="tExpression" minOccurs="0" maxOccurs="1"/>
                <xsd:element name="timeDuration" type="tExpression" minOccurs="0" maxOccurs="1"/>
                <xsd:element name="timeCycle" type="tExpression" minOccurs="0" maxOccurs="1"/>
            </xsd:choice>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>


10.5 Gateways
Gateways are used to control how Sequence Flows interact as they converge and diverge within a Process. If the
flow does not need to be controlled, then a Gateway is not needed. The term “Gateway” implies that there is a gating
mechanism that either allows or disallows passage through the Gateway--that is, as tokens arrive at a Gateway, they can
be merged together on input and/or split apart on output as the Gateway mechanisms are invoked.

A Gateway is a diamond, which has been used in many flow chart notations for exclusive branching and is familiar to
most modelers.
         A Gateway is a diamond that MUST be drawn with a single thin line (see Figure 10.102).
            The use of text, color, size, and lines for a Gateway MUST follow the rules defined in Section “Use of Text,
            Color, Size, and Lines in a Diagram” on page 41 with the exception that:




Figure 10.102 – A Gateway

Gateways, like Activities, are capable of consuming or generating additional tokens, effectively controlling the
execution semantics of a given Process. The main difference is that Gateways do not represent ‘work’ being done and
they are considered to have zero effect on the operational measures of the Process being executed (cost, time, etc.).

Gateways can define all the types of Business Process Sequence Flow behavior: Decisions/branching (exclusive,
inclusive, and complex), merging, forking, and joining. Thus, while the diamond has been used traditionally for exclusive
decisions, BPMN extends the behavior of the diamonds to reflect any type of Sequence Flow control. Each type of
Gateway will have an internal indicator or marker to show the type of Gateway that is being used (see Figure 10.103).




292                                                                            Business Process Model and Notation, v2.0
Exclusive                       or
                                      X
Event-Based


Parallel
Event-Based


Inclusive


Complex


Parallel

Figure 10.103 – The Different types of Gateways

The Gateway controls the flow of both diverging and converging Sequence Flows. That is, a single Gateway could
have multiple input and multiple output flows. Modelers and modeling tools might want to enforce a best practice of a
Gateway only performing one of these functions. Thus, it would take two sequential Gateways to first converge and
then to diverge the Sequence Flows.




Business Process Model and Notation, v2.0                                                                        293
Figure 10.104 - Gateway class diagram

Gateways are described in this section on an abstract level. The execution semantics of Gateways is detailed on page
444.

10.5.1 Sequence Flow Considerations

Note – Although the shape of a Gateway is a diamond, it is not a requirement that incoming and outgoing Sequence
Flows MUST connect to the corners of the diamond. Sequence Flows can connect to any position on the boundary of the
Gateway shape.

This section applies to all Gateways. Additional Sequence Flow Connection rules are specified for each type of
Gateway in the sections below.
        A Gateway MAY be a target for a Sequence Flow. It can have zero (0), one (1), or more incoming Sequence
        Flows.
             If the Gateway does not have an incoming Sequence Flow, and there is no Start Event for the Process,
            then the Gateway’s divergence behavior, depending on the type of Gateway (see below), SHALL be
            performed when the Process is instantiated.



294                                                                         Business Process Model and Notation, v2.0
        A Gateway MAY be a source of a Sequence Flow; it can have zero (0), one (1), or more outgoing Sequence
        Flows.
         A Gateway MUST have either multiple incoming Sequence Flows or multiple outgoing Sequence Flows
        (i.e., it MUST merge or split the flow).
             A Gateway with a gatewayDirection of unspecified MAY have both multiple incoming and
             outgoing Sequence Flows.
             A Gateway with a gatewayDirection of mixed MUST have both multiple incoming and outgoing
             Sequence Flows.
             A Gateway with a gatewayDirection of converging MUST have multiple incoming Sequence
             Flows, but MUST NOT have multiple outgoing Sequence Flows.
             A Gateway with a gatewayDirection of diverging MUST have multiple outgoing Sequence
             Flows, but MUST NOT have multiple incoming Sequence Flows.


10.5.2 Exclusive Gateway

A diverging Exclusive Gateway (Decision) is used to create alternative paths within a Process flow. This is basically
the “diversion point in the road” for a Process. For a given instance of the Process, only one of the paths can be taken.

A Decision can be thought of as a question that is asked at a particular point in the Process. The question has a defined
set of alternative answers. Each answer is associated with a condition Expression that is associated with a Gateway’s
outgoing Sequence Flows.
        The Exclusive Gateway MAY use a marker that is shaped like an “X” and is placed within the Gateway
        diamond (see Figure 10.106) to distinguish it from other Gateways. This marker is NOT REQUIRED (see Figure
        10.105).
             A diagram SHOULD be consistent in the use of the “X” internal indicator. That is, a diagram SHOULD NOT
             have some Gateways with an indicator and other Gateways without an indicator.



                      Condition 1




                             Condition 2




                         Default




Figure 10.105 - An Exclusive Data-Based Decision (Gateway) Example without the Internal Indicator




Business Process Model and Notation, v2.0                                                                            295
                      Condition 1




                             Condition 2




                         Default




Figure 10.106 - A Data-Based Exclusive Decision (Gateway) Example with the Internal Indicator

Note – as a modeling preference, the Exclusive Gateways shown in examples within this specification will be shown
without the internal indicator.

A default path can optionally be identified, to be taken in the event that none of the conditional Expressions evaluate
to true. If a default path is not specified and the Process is executed such that none of the conditional Expressions
evaluates to true, a runtime exception occurs.

A converging Exclusive Gateway is used to merge alternative paths. Each incoming Sequence Flow token is routed
to the outgoing Sequence Flow without synchronization.




Figure 10.107 - Exclusive Gateway class diagram




296                                                                           Business Process Model and Notation, v2.0
The Exclusive Gateway element inherits the attributes and model associations of Gateway (see Table 8.46). Table
10.123 presents the additional attributes and model associations of the Exclusive Gateway element:


 Table 10.123 – ExclusiveGateway Attributes & Model Associations

 Attribute Name                            Description/Usage

 default: SequenceFlow [0..1]              The Sequence Flow that will receive a token when none of the
                                           conditionExpressions on other outgoing Sequence Flows evaluate
                                           to true. The default Sequence Flow should not have a
                                           conditionExpression. Any such Expression SHALL be ignored.


10.5.3 Inclusive Gateway

A diverging Inclusive Gateway (Inclusive Decision) can be used to create alternative but also parallel paths within a
Process flow. Unlike the Exclusive Gateway, all condition Expressions are evaluated. The true evaluation of one
condition Expression does not exclude the evaluation of other condition Expressions. All Sequence Flows with
a true evaluation will be traversed by a token. Since each path is considered to be independent, all combinations of the
paths MAY be taken, from zero to all. However, it should be designed so that at least one path is taken.
        The Inclusive Gateway MUST use a marker that is in the shape of a circle or an “O” and is placed within the
        Gateway diamond (see Figure 10.108) to distinguish it from other Gateways.



                      Condition 1




                             Condition 2




                         Default




Figure 10.108 - An example using an Inclusive Gateway

A default path can optionally be identified, to be taken in the event that none of the conditional Expressions evaluate
to true. If a default path is not specified and the Process is executed such that none of the conditional Expressions
evaluates to true, a runtime exception occurs.

A converging Inclusive Gateway is used to merge a combination of alternative and parallel paths. A control flow token
arriving at an Inclusive Gateway MAY be synchronized with some other tokens that arrive later at this Gateway. The
precise synchronization behavior of the Inclusive Gateway can be found on page 297.




Business Process Model and Notation, v2.0                                                                             297
Figure 10.109 - Inclusive Gateway class diagram

The Inclusive Gateway element inherits the attributes and model associations of Gateway (see Table 8.46). Table
10.124 presents the additional attributes and model associations of the Inclusive Gateway element:


 Table 10.124 – InclusiveGateway Attributes & Model Associations

 Attribute Name                       Description/Usage

 default: SequenceFlow [0..1]         The Sequence Flow that will receive a token when none of the
                                      conditionExpressions on other Sequence Flows evaluate to true.
                                      The default Sequence Flow should not have a conditionExpression.
                                      Any such Expression SHALL be ignored.


10.5.4 Parallel Gateway

A Parallel Gateway is used to synchronize (combine) parallel flows and to create parallel flows.
        The Parallel Gateway MUST use a marker that is in the shape of a plus sign and is placed within the Gateway
        diamond (see Figure 10.110) to distinguish it from other Gateways.




298                                                                          Business Process Model and Notation, v2.0
Figure 10.110 - An example using an Parallel Gateway

Parallel Gateways are used for synchronizing parallel flow (see Figure 10.111).




Figure 10.111 - An example of a synchronizing Parallel Gateway

A Parallel Gateway creates parallel paths without checking any conditions; each outgoing Sequence Flow receives a
token upon execution of this Gateway. For incoming flows, the Parallel Gateway will wait for all incoming flows
before triggering the flow through its outgoing Sequence Flows.




Business Process Model and Notation, v2.0                                                                    299
Figure 10.112 - Parallel Gateway class diagram

The Parallel Gateway element inherits the attributes and model associations of Gateway (see Table 8.46), but adds no
additional attributes or model associations.

10.5.5 Complex Gateway

The Complex Gateway can be used to model complex synchronization behavior. An Expression
activationCondition is used to describe the precise behavior. For example, this Expression could specify that
tokens on three out of five incoming Sequence Flows are needed to activate the Gateway. What tokens are produced
by the Gateway is determined by conditions on the outgoing Sequence Flows as in the split behavior of the Inclusive
Gateway. If tokens arrive later on the two remaining Sequence Flows, those tokens cause a reset of the Gateway and
new token can be produced on the outgoing Sequence Flows. To determine whether it needs to wait for additional
tokens before it can reset, the Gateway uses the synchronization semantics of the Inclusive Gateway.
        The Complex Gateway MUST use a marker that is in the shape of an asterisk and is placed within the Gateway
        diamond (see Figure 10.113) to distinguish it from other Gateways.



                     Alternative 1




                         Alternative 2




                         Alternative 3




                     Alternative 4



Figure 10.113 - An example using a Complex Gateway


300                                                                         Business Process Model and Notation, v2.0
The Complex Gateway has, in contrast to other Gateways, an internal state, which is represented by the boolean
instance attribute waitingForStart, which is initially true and becomes false after activation. This attribute can be
used in the conditions of the outgoing Sequence Flows to specify where tokens are produced upon activation and where
tokens are produced upon reset. It is RECOMMENDED that each outgoing Sequence Flow either get a token upon
activation or upon reset but not both. At least one outgoing Sequence Flow should receive a token upon activation but
a token MUST NOT be produced upon reset.

Figure 10.114 shows the class diagram for the Complex Gateway.




Figure 10.114 - Complex Gateway class diagram

The Complex Gateway element inherits the attributes and model associations of Gateway (see Table 8.46). Table
10.125 presents the additional model associations of the Complex Gateway element:


 Table 10.125 – Complex Gateway model associations

 Attribute Name                             Description/Usage

 activationCondition: Expression            Determines which combination of incoming tokens will be synchro-
 [0..1]                                     nized for activation of the Gateway.

 default: SequenceFlow [0..1]               The Sequence Flow that will receive a token when none of the
                                            conditionExpressions on other Sequence Flows evaluate to
                                            true. The default Sequence Flow should not have a
                                            conditionExpression. Any such Expression SHALL be ignored.




Business Process Model and Notation, v2.0                                                                        301
 Table 10.126 – Instance attributes related to the Complex Gateway

 Attribute Name                       Description/Usage

 activationCount: integer             Refers at runtime to the number of tokens that are present on an incoming
                                      Sequence Flow of the Complex Gateway.

 waitingForStart: boolean = true      Represents the internal state of the Complex Gateway. It is either waiting
                                      for start (=true) or waiting for reset (=false).


10.5.6 Event-Based Gateway

The Event-Based Gateway represents a branching point in the Process where the alternative paths that follow the
Gateway are based on Events that occur, rather than the evaluation of Expressions using Process data (as with an
Exclusive or Inclusive Gateway). A specific Event, usually the receipt of a Message, determines the path that will
be taken. Basically, the decision is made by another Participant, based on data that is not visible to Process, thus,
requiring the use of the Event-Based Gateway.

For example, if a company is waiting for a response from a customer they will perform one set of Activities if the
customer responds “Yes” and another set of Activities if the customer responds “No.” The customer’s response
determines which path is taken. The identity of the Message determines which path is taken. That is, the “Yes”
Message and the “No” Message are different Messages—i.e., they are not the same Message with different values
within a property of the Message. The receipt of the Message can be modeled with an Intermediate Event with a
Message trigger or a Receive Task. In addition to Messages, other triggers for Intermediate Events can be used,
such as Timers.

The Event Gateway shares the same basic shape of the Gateways, a diamond, with a marker placed within the
diamond to indicate variations of the Gateway.
        An Event Gateway is a diamond that MUST be drawn with a single thin line.
            The use of text, color, size, and lines for an Event Gateway MUST follow the rules defined in Section “Use of
            Text, Color, Size, and Lines in a Diagram” on page 41.
        The marker for the Event Gateway MUST look like a catch Multiple Intermediate Event (see Figure 10.115).




Figure 10.115 – Event-Based Gateway

Unlike other Gateways, the behavior of the Event Gateway is determined by a configuration of elements, rather than
the single Gateway.
        An Event Gateway MUST have two (2) or more outgoing Sequence Flows.
             The outgoing Sequence Flows of the Event Gateway MUST NOT have a conditionExpression.




302                                                                            Business Process Model and Notation, v2.0
The objects that are on the target end of the Gateway’s outgoing Sequence Flows are part of the configuration of the
Gateway.
        Event-Based Gateways are configured by having outgoing Sequence Flows target an Intermediate Event
        or a Receive Task in any combination (see Figure 10.116 and Figure 10.117) except that:
             If Message Intermediate Events are used in the configuration, then Receive Tasks MUST NOT be used
            in that configuration and vice versa.
                 Receive Tasks used in an Event Gateway configuration MUST NOT have any attached Intermediate
                 Events.
             Only the following Intermediate Event triggers are valid: Message, Signal, Timer, Conditional,
            and Multiple (which can only include the previous triggers). Thus, the following Intermediate Event
            triggers are not valid: Error, Cancel, Compensation, and Link.
        Target elements in an Event Gateway configuration MUST NOT have any additional incoming Sequence
        Flows (other than that from the Event Gateway).




                                     Message
                                        1




     Request
    Response
                                     Message
                                        2




                                       1 Day

Figure 10.116 - An Event-Based Gateway example using Message Intermediate Events




Business Process Model and Notation, v2.0                                                                       303
                                         Receive
                                        Message 1




      Request                            Receive
      Reponse                           Message 2




                                          1 Day

Figure 10.117 - An Event-Based Gateway example using Receive Tasks

When the first Event in the Event Gateway configuration is triggered, then the path that follows that Event will used
(a token will be sent down the Event’s outgoing Sequence Flows). All the remaining paths of the Event Gateway
configuration will no longer be valid. Basically, the Event Gateway configuration is a race condition where the first
Event that is triggered wins.

There are variations of the Event Gateway that can be used at the start of the Process. The behavior and marker of the
Gateway will change.

Event Gateways can be used to instantiate a Process. By default the Gateway’s instantiate attribute is false,
but if set to true, then the Process is instantiated when the first Event of the Gateway’s configuration is triggered.
         If the Event Gateway’s instantiate attribute is set to true, then the marker for the Event Gateway looks
        like a Multiple Start Event (see Figure 10.118).




Figure 10.118 – Exclusive Event-Based Gateway to start a Process

In order for an Event Gateway to instantiate a Process, it MUST not have any incoming Sequence Flows:

In some situations a modeler might want the Process to be instantiated by one of a set of Messages while still
requiring all of the Messages for the working of the same Process instance. To handle this, there is another variation
of the Event Gateway.
        If the Event Gateway’s instantiate attribute is set to true and the eventGatewayType attribute is set to
        Parallel, then the marker for the Event Gateway looks like a Parallel Multiple Start Event (see Figure
        10.119).
             The Event Gateway’s instantiate attribute MUST be set to true in order for the eventGatewayType


304                                                                           Business Process Model and Notation, v2.0
            attribute to be set to Parallel (i.e., for Event Gateway’s that do not instantiate the Process MUST be
            Exclusive—a standard Parallel Gateway can be used to include parallel Events in the middle of a
            Process).




Figure 10.119 – Parallel Event-Based Gateway to start a Process

The Parallel Event Gateway is also a type of race condition. In this case, however, when the first Event is triggered
and the Process is instantiated, the other Events of the Gateway configuration are not disabled. The other Events are
still waiting and are expected to be triggered before the Process can (normally) complete. In this case, The Messages
that trigger the Events of the Gateway configuration MUST share the same correlation information.




Figure 10.120 - Event-Based Gateway class diagram

The Event-Based Gateway element inherits the attributes and model associations of Gateway (see Table 8.46). Table
10.127 presents the additional attributes and model associations of the Event-Based Gateway element:




Business Process Model and Notation, v2.0                                                                        305
 Table 10.127 – EventBasedGateway Attributes & Model Associations

 Attribute Name                     Description/Usage

 instantiate: boolean = false       When true, receipt of one of the Events will instantiate the Process
                                    instance.

 eventGatewayType: EventGate-       The eventGatewayType determines the behavior of the Gateway when
 wayType = Exclusive                used to instantiate a Process (as described above).
 { Exclusive | Parallel }           The attribute can only be set to parallel when the instantiate
                                    attribute is set to true.

Event-Based Gateways can be used at the start of a Process, without having to be a target of a Sequence Flows.
There can be multiple such Event-Based Gateways at the start of a Process. Ordinary Start Events and Event-
Based Gateways can be used together.

10.5.7 Gateway Package XML Schemas
Table 10.128 – ComplexGateway XML schema

<xsd:element name="complexGateway" type="tComplexGateway" substitutionGroup="flowElement"/>
<xsd:complexType name="tComplexGateway">
    <xsd:complexContent>
        <xsd:extension base="tGateway">
            <xsd:sequence>
                <xsd:element name="activationCondition" type="tExpression" minOccurs="0" maxOccurs="1"/>
            </xsd:sequence>
            <xsd:attribute name="default" type="xsd:IDREF"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>


Table 10.129 – EventBasedGateway XML schema

<xsd:element name="eventBasedGateway" type="tEventBasedGateway" substitutionGroup="flowElement"/>
<xsd:complexType name="tEventBasedGateway">
    <xsd:complexContent>
        <xsd:extension base="tGateway">
            <xsd:attribute name="instantiate" type="xsd:boolean" default="false"/>
            <xsd:attribute name="eventGatewayType" type="tEventBasedGatewayType" default="Exclusive"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

<xsd:simpleType name="tEventBasedGatewayType">
   <xsd:restriction base="xsd:string">
        <xsd:enumeration value="Exclusive"/>
        <xsd:enumeration value="Parallel"/>


306                                                                      Business Process Model and Notation, v2.0
    </xsd:restriction>
</xsd:simpleType>

Table 10.130 – ExclusiveGateway XML schema

<xsd:element name="exclusiveGateway" type="tExclusiveGateway" substitutionGroup="flowElement"/>
<xsd:complexType name="tExclusiveGateway">
    <xsd:complexContent>
        <xsd:extension base="tGateway">
            <xsd:attribute name="default" type="xsd:IDREF" use="optional"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.131 – Gateway XML schema

<xsd:element name="gateway" type="tGateway" abstract="true"/>
<xsd:complexType name="tGateway">
    <xsd:complexContent>
        <xsd:extension base="tFlowElement">
            <xsd:attribute name="gatewayDirection" type="tGatewayDirection" default="Unspecified"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

<xsd:simpleType name="tGatewayDirection">
    <xsd:restriction base="xsd:string">
        <xsd:enumeration value="Unspecified"/>
        <xsd:enumeration value="Converging"/>
        <xsd:enumeration value="Diverging"/>
        <xsd:enumeration value="Mixed"/>
    </xsd:restriction>
</xsd:simpleType>

Table 10.132 – InclusiveGateway XML schema

<xsd:element name="inclusiveGateway" type="tInclusiveGateway" substitutionGroup="flowElement"/>
<xsd:complexType name="tInclusiveGateway">
    <xsd:complexContent>
        <xsd:extension base="tGateway">
            <xsd:attribute name="default" type="xsd:IDREF" use="optional"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.133 – ParallelGateway XML schema

<xsd:element name="parallelGateway" type="tParallelGateway" substitutionGroup="flowElement"/>
<xsd:complexType name="tParallelGateway">
   <xsd:complexContent>


Business Process Model and Notation, v2.0                                                             307
        <xsd:extension base="tGateway"/>
    </xsd:complexContent>
</xsd:complexType>


10.6 Compensation
Compensation is concerned with undoing steps that were already successfully completed, because their results and
possibly side effects are no longer desired and need to be reversed. If an Activity is still active, it cannot be compensated,
but rather needs to be canceled. Cancellation in turn can result in compensation of already successfully completed
portions of an active Activity, in case of a Sub-Process.

Compensation is performed by a compensation handler. A compensation handler performs the steps necessary to reverse
the effects of an Activity. In case of a Sub-Process, the compensation handler has access to Sub-Process data at the
time of its completion (“snapshot data”).

Compensation is triggered by a throw Compensation Event, which typically will be raised by an error handler, as part
of cancellation, or recursively by another compensation handler. That Event specifies the Activity for which
compensation is to be performed, either explicitly or implicitly.

10.6.1 Compensation Handler

A compensation handler is a set of Activities that are not connected to other portions of the BPMN model. The
compensation handler starts with a catch Compensation Event. That catch Compensation Event either is a
boundary Event, or, in case of a Compensation Event Sub-Process, the handler’s Start Event.

A compensation handler connected via a boundary Event can only perform “black-box” compensation of the original
Activity. This compensation is modeled with a specialized Compensation Activity, which is connected to the boundary
Event through an Association (see Figure 10.121). The Compensation Activity, which can be either a Task or a
Sub-Process, has a marker to show that it is used for compensation only and is outside the normal flow of the
Process.




   Book Hotel



                          Cancel
                           Hotel

Figure 10.121- Compensation through a boundary Event

A Compensation Event Sub-Process is contained within a Process or a Sub-Process (see Figure 10.122). Like
the Compensation Activity, the Compensation Event Sub-Process is outside the normal flow of the Process.
The Event Sub-Process, which is marked with a dotted line boundary, can access data that is part of its parent, a
snapshot at the point in time when its parent completed. A Compensation Event Sub-Process can recursively trigger
compensation for Activities contained in its parent.


308                                                                                Business Process Model and Notation, v2.0
                                  Booking


                  Boo k F lig ht



                                       C anc el
                                        F li ght




                  B ook H o tel



                                       C an ce l
                                        H ote l



                      Handle Com pens ation

                                             U p date
                                            C us to me r
    Bo ok ing   F lig ht     H otel          R e co rd




Figure 10.122 - Monitoring Class Diagram

It is possible to specify that a Sub-Process can be compensated without having to define the compensation handler. The
Sub-Process attribute compensable, when set, specifies that default compensation is implicitly defined, which
recursively compensates all successfully completed Activities within that Sub-Process.

The example in Figure 10.122, above contains a custom Compensation Event Sub-Process, triggered by a
Compensation Start Event. Note that this compensation handler deviates from default compensation in that it runs
Compensation Activities in an order different from the order in the forward case; it also contains an additional
Activity adding Process logic that cannot be derived from the body of the Sub-Process itself.

10.6.2 Compensation Triggering

Compensation is triggered using a compensation throw Event, which can either be an Intermediate or an End
Event. The Activity which needs to be compensated is referenced. If the Activity is clear from the context, it doesn’t
have to be specified and defaults to the current Activity. A typical scenario for that is an inline error handler of a Sub-
Process that cannot recover the error, and as a result would trigger compensation for that Sub-Process. If no Activity
is specified in a “global” context, all completed Activities in the Process are compensated.

By default, compensation is triggered synchronously, that is, the compensation throw Event waits for the completion of
the triggered compensation handler. Alternatively, compensation can just be triggered without waiting for its completion,
by setting the throw Compensation Event’s waitForCompletion attribute to false.

Multiple instances typically exist for Loop or Multi-Instance Sub-Processes. Each of these has its own instance of
its Compensation Event Sub-Process, which has access to the specific snapshot data that was current at the time of
completion of that particular instance. Triggering compensation for the Multi-Instance Sub-Process individually




Business Process Model and Notation, v2.0                                                                              309
triggers compensation for all instances within the current scope. If compensation is specified via a boundary
compensation handler, this boundary compensation handler also is invoked once for each instance of the Multi-Instance
Sub-Process in the current scope.

10.6.3 Relationship between Error Handling and Compensation

The following items define the relationship between error handling and compensation:

      • Compensation employs a “presumed abort principle”, with the following consequences: Compensation of a failed
        Activity results in a null operation.

      • When an Activity fails, i.e., is left because an error has been thrown, it’s the error handlers responsibility to ensure
        that no further compensation will be necessary once the error handler has completed.

      • If no error Event Sub-Process is specified for a particular Sub-Process and a particular error, the default
        behavior is to automatically call compensation for all contained Activities of that Sub-Process if that error is
        thrown, ensuring the behavior in for auditing and monitoring.


10.7 Lanes
A Lane is a sub-partition within a Process (often within a Pool) and will extend the entire length of the Process
level,, either vertically (see Figure 10.122) or horizontally (see Figure 10.123).. Text associated with the Lane (e.g., its
name and/or that of any Process element attribute) can be placed inside the shape, in any direction or location,
depending on the preference of the modeler or modeling tool vendor. Our examples place the name as a banner on the left
side (for horizontal Pools) or at the top (for vertical Pools) on the other side of the line that separates the Pool name,
however, this is not a requirement.
          A Lane is a square-cornered rectangle that MUST be drawn with a solid single line (see Figure 10.123 and Figure
          10.124).
                The label for the Lane MAY be placed in any location and direction within the Lane, but MUST NOT be
               separated from the contents of the Lane by a single line (except in the case that there are sub-Lanes within the
               Lane).




310                                                                                   Business Process Model and Notation, v2.0
     Name
  Name Name




Figure 10.123 - Two Lanes in a Vertical Pool
  Name N ame
     Name




Figure 10.124 - Two Lanes in a horizontal Pool

Lanes are used to organize and categorize Activities within a Pool. The meaning of the Lanes is up to the modeler.
BPMN does not specify the usage of Lanes. Lanes are often used for such things as internal roles (e.g., Manager,
Associate), systems (e.g., an enterprise application), an internal department (e.g., shipping, finance), etc. In addition,
Lanes can be nested (see Figure 10.125) or defined in a matrix. For example, there could be an outer set of Lanes for
company departments and then an inner set of Lanes for roles within each department.




Business Process Model and Notation, v2.0                                                                              311
                                                   Sell to
            Sales




                                                  Customer
                          Pre-Sales




                                       Accumulate
                                        Require-
                                         ments
            Marketing

                          Post-Sales




                                                                         Verify
 Supplier




                                                                        Require-
                                                                         ments
            Consulting




                                                                        Consulting           Bugs
                                                                        Required          Diagnosed
                                                             Bug List
            Engineering




                                        Develop                                                     Develop
                                        Product                                                      Patch




Figure 10.125 - An Example of Nested Lanes

Figure 10.126 shows the Lane class diagram. When a Lane is defined it is contained within a LaneSet, which is
contained within a Process.




312                                                                                Business Process Model and Notation, v2.0
Figure 10.126 - The Lane class diagram

The LaneSet element defines the container for one or more Lanes. A Process can contain one or more LaneSets.
Each LaneSet and its Lanes can partition the Flow Nodes in a different way.

The LaneSet element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.134
presents the additional attributes and model associations of the LaneSet element:


 Table 10.134 – LaneSet attributes and model associations

 Attribute Name               Description/Usage

 name: sting [0..1]           The name of the LaneSet. A LaneSet is not visually displayed on a BPMN dia-
                              gram. Consequently, the name of the LaneSet is not displayed as well.

 process: Process             The Process owning the LaneSet

 lanes: Lane [0..*]           One or more Lane elements, which define a specific partition in the LaneSet

 parentLane: Lane [0..1]      The reference to a Lane element which is the parent of this LaneSet.

A Lane element defines one specific partition in a LaneSet. The Lane can define a partition element which specifies
the value and element type, a tool can use to determine the list of Flow Nodes to be partitioned into this Lane. All Lanes
in a single LaneSet MUST define partition element of the same type, e.g., all Lanes in a LaneSet reference a
Resource as the partition element, but each Lane references a different Resource instance.

The Lane element inherits the attributes and model associations of BaseElement (see Table 8.5). Table 10.135
presents the additional attributes and model associations of the Lane element:


Business Process Model and Notation, v2.0                                                                             313
 Table 10.135 – Lane attributes and model associations

 Attribute Name                 Description/Usage

 name: string                   The name of the Lane

 partitionElement:              A reference to a BaseElement which specifies the partition value and partition
 BaseElement [0..1]             type. Using this partition element a BPMN compliant tool can determine the
                                FlowElements which have to be partitioned in this Lane.

 partitionElementRef:           A reference to a BaseElement which specifies the partition value and partition
 BaseElement [0..1]             type. Using this partition element a BPMN compliant tool can determine the
                                FlowElements which have to be partitioned in this Lane.

 childLaneSet: LaneSet          A reference to a LaneSet element for embedded Lanes.
 [0..1]

 flowNodeRefs:                  The list of FlowNodes partitioned into this Lane according to the
 FlowNode [0..*]                partitionElement defined as part of the Lane element.



10.8 Process Instances, Unmodeled Activities, and Public Processes
A Process can be executed or performed many times, but each time is expected to follow the steps laid out in the
Process model. For example, the Process in Figure 10.1 will occur every Friday, but each instance is expected to
perform Task “Receive Issue List,” then Task “Review Issue List,” and so on, as specified in the model. Each instance
of a Process is expected to be valid for the model, but some instances might not, for example if the Process has
manual Activities, and the performers have not had proper instruction on how to carry out the Process.

In some applications it is useful to allow more Activities and Events to occur when a Process is executed or
performed than are contained in the Process model. This enables other steps to be taken as needed without changing the
Process. For example, instances of the Process in Figure 10.1 might execute or perform an extra Activity between
Task “Receive Issue List” and Task “Review Issue List.” These instances are still valid for the Process model in
Figure 10.1, because the instances still execute or perform the Activities in the Process, in the order they are modeled
and under conditions specified for them.

There are two ways to specify whether unmodeled Activities are allowed to occur in Process instances:

      • If the isClosed attribute of a Process has a value of false or no value, then interactions, such as sending and
        receiving Messages and Events, MAY occur in an instance without additional flow elements in the Process.
        Unmodeled interactions can still be restricted on particular Sequence Flow in the Process (see next bullet). If the
        isClosed attribute of a Process has a value of true, then interactions, such as sending and receiving Messages
        and Events, MAY NOT occur without additional flow elements in the Process. This restriction overrides any
        unmodeled interactions allowed by Sequence Flows in the next bullet.

      • If the isImmediate attribute of a Sequence Flow in a Process has a value of false, then other Activities and
        interactions not modeled in the Process MAY be executed or performed during the Sequence Flow. If the
        isImmediate attribute has a value of true, then Activities and interactions not modeled in the Process MAY
        NOT be executed or performed during Sequence Flow. In non-executable Processes (isExecutable attribute
        has value false, or defaults to false), Sequence Flows with no value for isImmediate are treated as if the

314                                                                               Business Process Model and Notation, v2.0
      value were false. In executable Processes (isExecutable attribute has value true, or defaults to true),
      Sequence Flows with no value for isImmediate are treated as if the value were true. Executable Processes
      cannot have a false value for the isImmediate attribute.

Restrictions on unmodeled Activities specified with isClosed and isImmediate apply only under executions or
performances (instances) of the Process containing the restriction. These Activities MAY occur in instances of other
Processes.

When a Process allows Activities to occur that the Process does not model, those Activities might appear in other
Process models. The executions or performances (instances) of these other Processes might be valid for the original
Process. For example, a Process might be defined similar to the one in Figure 10.1 that adds an extra Activity
between Task “Receive Issue List” and Task “Review Issue List.” The Process in Figure 10.1 might use isClosed or
isImmediate to allow other Activities to occur in between Task “Receive Issue List” and Task “Review Issue List.”
When the Process is executed or performed, then instances of the other Process (the one with the extra step in
between Task “Receive Issue List” and Task “Review Issue List”) will be valid for the Process in Figure 10.1.
Modelers can declare that they intend all instances of one Process will be valid for another Process using the supports
association between the Processes. During development of these Processes, support might not actually hold, because
the association just expresses modeler intent.

A common use for model support is between private and public Processes, see Section “Overview” (page 23). A public
Process contain Activities visible to external parties, such as Participants in a Collaboration, while a private
Process includes other Activities that are not visible to external parties. The hidden Activities in a private Process
are not modeled in the public Process. However, it is expected that instances of the private Process will appear to
external parties as if they could be instances of the public Process. This means the private Process supports the public
Process (it is expected that all instances of the private Process will be valid for the public one).

A Process that supports another, as a private Process can to a public Process, does not need to be entirely similar to
the other Process. It is only REQUIRED that instances of the Process appear as if they could be instance of the other
Process. For example Figure 10.127 shows a public Process at the top with a Send Task and Receive Task. A
supporting private Process is shown at the bottom. The private Process sends and receives the same Messages, but
using Events instead of Tasks. It also introduces Activities not modeled in the public Process. However all instances
of the private Process will appear as if they could be instances of the public one, because the Messages are sent and
received in the order REQUIRED by the public Process, and the public Process allows unmodeled Activities to
occur.




Business Process Model and Notation, v2.0                                                                           315
 Public Process                        A                               B




                                                  X



Private Process                                                                    Y
                       A


                                                  B

Figure 10.127 - One Process supporting to another

In practice, a public Process looks like an underspecified private Process. Anything not specified in the public
Process is determined by the private one. For example, if none of the outgoing Sequence Flows for an Exclusive
Gateway have conditionExpressions, the private Process will determine which one of the Activities targeted
by the Sequence Flows will occur. Another example is a Timer Event with no EventDefinition. The private
Process will determine when the timer goes off.


10.9 Auditing
The Auditing element and its model associations allow defining attributes related to auditing. It leverages the BPMN
extensibility mechanism. This element is used by FlowElements and Process. The actual definition of auditing
attributes is out of scope of this specification. BPMN 2.0 implementations can define their own set of attributes and their
intended semantics.




316                                                                              Business Process Model and Notation, v2.0
Figure 10.128 - Auditing Class Diagram


10.10 Monitoring
The Monitoring and its model associations allow defining attributes related to monitoring. It leverages the BPMN
extensibility mechanism. This element is used by FlowElements and Process. The actual definition of monitoring
attributes is out of scope of this specification. BPMN 2.0 implementations can define their own set of attributes and their
intended semantics.




Figure 10.129 - Monitoring Class Diagram


10.11 Process Package XML Schemas


Business Process Model and Notation, v2.0                                                                              317
Table 10.136 – Process XML schema

<xsd:element name="process" type="tProcess" substitutionGroup="rootElement"/>
<xsd:complexType name="tProcess">
    <xsd:complexContent>
        <xsd:extension base="tCallableElement">
            <xsd:sequence>
                 <xsd:element ref="auditing" minOccurs="0" maxOccurs="1"/>
                 <xsd:element ref="monitoring" minOccurs="0" maxOccurs="1"/>
                 <xsd:element ref="processRole" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="laneSet" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="flowElement" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="artifact" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="resourceRole" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element ref="correlationSubcription" minOccurs="0" maxOccurs="unbounded"/>
                 <xsd:element name="supports" type="xsd:QName" minOccurs="0" maxOccurs="unbounded"/>
            </xsd:sequence>
            <xsd:attribute name="processType" type="tProcessType" default="None"/>
            <xsd:attribute name="isExecutable" type="xsd:boolean"use="optional"/>
            <xsd:attribute name="isClosed" type="xsd:boolean" default="false"/>
            <xsd:attribute name="definitionalCollaborationRef" type="xsd:QName" use="optional"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>
<xsd:simpleType name="tProcessType">
    <xsd:restriction base="xsd:string">
        <xsd:enumeration value="None"/>
        <xsd:enumeration value="Public"/>
        <xsd:enumeration value="Private"/>
    </xsd:restriction>
</xsd:simpleType>

Table 10.137 – Auditing XML schema

<xsd:element name="auditing" type="tAuditing"/>
<xsd:complexType name="tAuditing">
    <xsd:complexContent>
        <xsd:extension base="tBaseElement"/>
    </xsd:complexContent>
</xsd:complexType>

Table 10.138 – GlobalTask XML schema

<xsd:element name="globalTask" type="tGlobalTask" substitutionGroup="rootElement"/>
<xsd:complexType name="tGlobalTask">
   <xsd:complexContent>
        <xsd:extension base="tCallableElement">
           <xsd:sequence>
               <xsd:element ref="resourceRole" minOccurs="0" maxOccurs="unbounded"/>
           </xsd:sequence>

318                                                                Business Process Model and Notation, v2.0
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>

Table 10.139 – Lane XML schema

<xsd:element name="lane" type="tLane"/>
<xsd:complexType name="tLane">
    <xsd:complexContent>
        <xsd:extension base="tBaseElement">
            <xsd:sequence>
                <xsd:element name="partitionElement" type="tBaseElement" minOccurs="0" maxOccurs="1"/>
                <xsd:element name="flowNodeRef" type="xsd:IDREF" minOccurs="0"
maxOccurs="unbounded"/>
                <xsd:element name="childLaneSet" type="tLaneSet" minOccurs="0" maxOccurs="1"/>
            </xsd:sequence>
            <xsd:attribute name="name" type="xsd:string"/>
            <xsd:attribute name="partitionElementRef" type="xsd:QName"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>



Table 10.140 – LaneSet XML schema

<xsd:element name="laneSet" type="tLaneSet"/>
<xsd:complexType name="tLaneSet">
    <xsd:complexContent>
        <xsd:extension base="tBaseElement">
            <xsd:sequence>
                <xsd:element ref="lane" minOccurs="0" maxOccurs="unbounded"/>
            </xsd:sequence>
            <xsd:attribute name="name" type="xsd:string"/>
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexType>



Table 10.141 – Monitoring XML schema

<xsd:element name="monitoring" type="tMonitoring"/>
<xsd:complexType name="tMonitoring">
    <xsd:complexContent>
        <xsd:extension base="tBaseElement"/>
    </xsd:complexContent>
</xsd:complexType>




Business Process Model and Notation, v2.0                                                            319
Table 10.142 – Performer XML schema

<xsd:element name="performer" type="tPerformer" substitutionGroup="resourceRole"/>
<xsd:complexType name="tPerformer">
    <xsd:complexContent>
        <xsd:extension base="tResourceRole"/>
    </xsd:complexContent>
</xsd:complexType>




320                                                                  Business Process Model and Notation, v2.0
